# 프로그래머, 수학의 시대
### 지은이 : 이재현, 이정설
### 출판사 : 로드북
### 읽은 날 : 2019.05.30

1. 동시다발적으로 모든 컴퓨터가 다른 모든 컴퓨터와 소통하는 방법을 도입하기 위해서는 시스템이 달라도 주고받는 정보는 일정하게 유지하도록 '소켓socket'과 '패킷packet'에 대한 개념을 통일해야 했고, 아울러 그런 패킷들이 지나다닐 수 있는 '공용망network'이 필요했다.

2. TCP/IP가 소켓과 패킷에 관한 규약이라면, 우리가 아는 인터넷, 즉 월드 와이드 웹(WWW : World Wide Web)이라는 것은 그 소켓과 패킷을 이용해서 주고 받는 데이터를 일정한 방식으로 통일한 거싱라고 할 수 있다.

3. 나중에 윈도우즈냐 리눅스냐의 운영체제 논쟁이 불붙었을 때도 사람들은 엑셀 때문에 윈도우즈를 포기할 수 없다는 데에 의견을 같이했다. 운영체제가 소프트웨어를 결정하는 것이 아니라 소프트웨어가 운영체제를 결정하는 단계까지 가버린 것이다.

4. 그렇게 무안가를 외면하는 사람의 눈에는 아무것도 보이지 않는다.

5. 불만족한 사람들이야말로 스스로를 변방으로 이끌고, 거기서 죽든지, 아니면 새로운 방법을 찾아서 다시 돌아오게 되는 것이다.

6. 하지만, 무언가를 '잘'하기 시작한다는 것은 사실은, '그것'에 대한 흥미를 잃게 된다는 것을 의미한다. '엑셀이 뭐지?'하고 스스로에게 묻는 것은 '호기심'의 발현이고, 이제 그것을 잘 안다는 것은 이미 그것이 호기심의 대상이 아니라는 것이다.

7. 답을 찾기 위해서 필요했던 건 물어볼 사람, 좋은 자료, 좋은 성생님이 아니라 그 질문을 포기하지 않고 끝까지 간직하고 유지하려는 나의 마음가짐이었던 것이다.

8. C프로그래밍 언어라고 해서 특별히 배우는 게 어렵지는 않다. 다만, 요새처럼 객체지향이 주류고, 메모리 관리를 가비지 컬렉터(GC, Garbage Collector)가 능숙하게 해 주는 환경에서 '포인터pointer'를 직접 다룰 수 있다는 것만으로도 C는 해 볼 가치가 있다. 포인터는 메모리의 주소값을 저장하는 변수인데, 변수를 그저 변수값으로만 생각하는 것과 변수값이 저장된 공간으로 생각하는 것과는 차이가 많다. 자료를 '값'과 '주소'로 분리해서 생각하는 건 프로그래밍 능력에서 거대한 도약이다(이 차이에 대한 논의만으로도 책 한 권을 구성할 수 있겠지만 여기서는 이에 그친다). 여하튼 C를 공부한다는 건, 어떤 면에선 포인터를 공부하는 것과 같다고 볼 수도 있다.

9. 우선, 나는 처음 보는 플랫폼과 처음 보는 언어였지만, 재빠르게 그 언어의 패턴을 파악했고, 적응했다. 개발을 늦게 배운 나에게 '새로운 언어를 배우는 일'은 매우 익숙한 일이었기 때문에 그게 가능했다고 생각한다. 다른 개발자들에겐 '익숙한 언어'라는 게 있었지만, 나에겐 그런 게 없었고, 나에게 익숙한 것이 있다면 그건 새로운 언어를 배우는 일이었다. 새로운 언어가 장애물이라고 생각하는 개발자들과, 새로운 걸 배우는 게 당연한 개발자들 사이에는, 비록 그게 단지 마인드의 차이일 뿐이라 하더라도, 하늘과 땅만큼 차이가 있다.

10. 우리는 일상생활에서 수학, 철학, 인생 같은 어휘를 쓰지만, 실상 그 어휘들에 대한 엄밀한 정의는 존재하지 않는다. 오로지 그 어휘를 써서 생기는 '이익'만이 존재할 뿐이다.

11. 약간 우습게 들릴 수도 있지만, 우리는 '모호성'속에서는 살 수가 없는 존재다. 그래서 수학이니, 철학이니, 인생이니 하는 개념을 쓸 수밖에 없다. 하지만, 이게 우습게 들리는 이유는 모호성을 없애기 위해 모호한 개념들을 쓴다는 얘기나 다름이 없기 때문이다. 어쨌거나 수학은 완전히 정의되긴 힘든 개념이지만, 우리는 수학이라는 어휘를 쓴다. 우리는 '수와 관련되었거나 수와 관련되어 보이는 것'이라는 모호한 말로 대화를 나눌 수는 없는 존재들이다. 누군가 그런 의미에 '수학'이라는 이름을 붙였고, 그 이름은 이것저것 주워담은 보자기 같은 엉성한 개념일 수는 있어도, 아예 없는 것보단 낫다는 이유로 널리 쓰이고, 사람들은 그 이름을 오용하고, 남용하고, 그리고 그 오용과 남용을 합리화하면서 '발전'해 나갔다. 그러니까 '수학'이라는 개념이 엉성했음에도 사람들은 발전해 나간 것이다.

12. 나만의 새로운 걸 만드는 것보다 남들이 미리 만들어 놓은 걸 받아들이는 게 더 이익일 때는 지체 없이 그렇게 해야 한다. 그러하지 않았을 때 얻을 것은 '재앙'뿐이다.

13. 유리수는 무한대지만 셀 수 있다고 말했다. 그럼 무리수는 셀 수 있을까? 실수가 유리수와 무리수로 구성되어 있다는 것을 얼핏 아는 사람들도 무리수가 '대수적 수algebraic number'와 '초월수transcendental number'로 구성되어 있다는 것은 잘 모를 수도 있다(나는 문과라서, 혹은 내가 무지해서 인생의 대부분을 모르고 살았다). 대수적 수라는 것은 비록 유리수는 아니지만 '식으로 만들 수 있는' 수를 뜻한다(전문적으로 말하면 '다항방정식의 해가 될 수 있는 수'이다). 유리수는 무한소수일 수 있기 때문에 직접 쓸 수 없을 때가 있다. 그런 경우에는 그저 분수로만 표시한다. 예를 들면 1/3은 0.3333...인데, 그저 분수로 표시하는 게 간략하고 좋을 것이다. 대표적인 무리수 중의 하나인 '루트2'는 x^2=2라는 방정식의 해이므로, '루트2'라고 표시하지 않으려면 그저 식으로 표현하는 수밖에 없다. 이렇게 방정식으로나마 표시할 수 있는 수를 '대수적 수'라고 하는 것이다. 이 대수적 수도 역시 가산집합으로 알려져 있다. 즉, 자연수와 개수가 같다.  
하지만, 방정식으로조차 표시할 수 없는 수를 초월수라고 하는데, 이 초월수에는 자연상수 e, 원주율 파이 등이 있다.

13. 수의 체계 중에서 가장 포괄적인 개념을 '복소수'라고 부른다. 복소수는 실수와 허수를 포함하는 개념인데, 지나치게 전문적인 걸 피하기 위해 허수를 제외하면, '실수'가 우리가 다루는 가장 큰 개념일 것이다. 실수는 '비가산집합', 즉, 셀 수 없는 집합이라고 하는데, 그 이유는 실수를 구성하는 유리수와 무리수 중에서 무리수가 비가산집합이기 때문이고, 무리수가 비가산집합인 이유는 무리수를 구성하는 '대수적 수'와 '초월수' 중에서 초월수가 비가산집합이기 때문이다. 그러므로 결론적으로 말하면 모든 수의 체계 중에서 비가산집합은 '초월수' 밖에 없다고 생각해 볼 수 있다.

14. 그러나 실수는 그렇지 않다. 실수는 어떤 방식으로도 이산적으로 늘어 놓을 수가 없는 것이다. 내 능력으로는 증명할 수 없지만, 수학자들에 의하면 '대수적 수'는 늘어 놓을 수 있다고 한다. 즉, 대수적 수는 이산수인 것이고, 이 말은 어떤 대수적 수와 그 다음의 대수적 수 사이에는 다른 수가 들어갈 수 없음이 증명되어 있는 것이다. 하지만, 실수는, 다시 말하면 '초월수'는 초월수와 초월수 사이에 다른 수가 없음을 증명할 수가 없다. 아무리 잘게 초월수와 초월수를 늘어 놓아도 그 사이에는 다른 초월수가 존재할 수 있는 것이다.

15. 무한대에 대한 그(칸토어, Georg Cantor)의 증명법은 힐베르트, 라마누잔, 러셀, 괴델, 그리고 튜링으로 이어지는 매우 중요한 수학적 흐름을 낳았고, 지금껏 우리 삶에 큰 영향을 미치고 있다.

16. 자연수 a의 다음 수는 a+1이라고 할 수 있다. 그러나 실수  b의 다음 수는 사칙 연산으로 정의할 수 없다. 마치 자연수의 끝 수를 확정할 수 없는 것처럼(확정한 자연수의 끝을 n이라고 하면, 우리는 즉시 n+1로 그게 끝이 아님을 반증할 수 있다), 실수의 다음 수는 '비록 존재한다 하더라도' 절대 무어라고 말할 수 없는 것이다(존재하는데 말할 수 없다). 이것이 실수가 자연수보다 큰 집합인 이유고, 연속수와 이산수와의 차이고, 어쩌면 실제 세계와 디지털 세계의 차이라고 할 수 있을 것이다.  
컴퓨터는 실수를 다루기보단 이산수를 다루기로 했다. 컴퓨터를 만드는 우리의 선배 인류들은 이렇게 컴퓨터의 한계에서 컴퓨터의 위대성을 정의했다. 다른 식으로 말하면, 컴퓨터 연산은 그 한계를 인식했기 때문에 위대한 기계가 될 수 있었던 것이다.

17. 차원의 이야기를 할 때 꼭 빼놓을 수 없는 것 중의 하나는 차원이 서로 환원 가능한가 이다. 가령, 4차원이 2차원이 될 수 있고, 1차원이 5차원이 될 수 있는가의 문제인데, 결론적으로 말하면, 얼마든지 가능하고, 이걸 가능하게 만들어 주는 체계적인 방법이 바로 '선형 대수학'이다.

18. 주의할 것은 높은 차원의 정보가 낮은 차원으로 환원될 때는 필연적으로 '정보 손실'이 발생한다는 것이다. 우리는 마주보고 있는 벽 뒤에도 공간이 존재하며, 그 공간으로 쥐, 거미, 지네, 바퀴벌레 등이 지나다닌다는 사실을 잘 알고 있지만, 우리는 볼 수 없다. 우리 망막은 이차원이고, 삼차원 정보를 모두 저장할 순 없는 것이다(그리고 그 덕분에 우리가 지저분하고 혐오스러운 것들과 평화롭게 공존할 수 있는 것이고). 그래서 한 번 낮은 차원으로 저장된 정보들을 다시 삼차원으로 재구성하는 일은 매우 까다로운 일이다. 하지만 정수가 자연수와 일대일 대응인 것처럼, 삼차원 정보들도 이차원으로 모두 저장될 수 있어서, 일정한 체계만 잡혀 있으면 100% 환원은 가능하다.  
이 환원의 극치를 보여주는 것이 컴퓨터 메모리RAM이다. 컴퓨터에 들어온 모든 정보는 RAM이라는 일차원 공간으로 저장된다. 그리고 필요하면, 여기에 저장된 정보를 꺼내어 보통 스크린이라는 이차원 평면에 표시하고, 경우에 따라선 삼차원 그래픽으로도 보여줄 수 있다. 동영상과 같은 사차원 그래픽도 얼마든지 가능하다.

19. 개발을 직업으로 선택한 뒤로 나는 코드를 작성하면서 많은 시간을 보냈다. 회사에서 하는 일도 일이지만, 궁금하거나 호기심 당기는 일이 있을 때마다 과감하게 개인 프로젝트를 진행했고, 덕분에 하루에 최대 18시간 정도 코드를 작성하는 일이 잦았다. 내가 성실해서 그랬다기 보다는 코딩이라는 작업 자체의 성격상, 어떤 주제를 다루다 보면 시간이 그렇게 순식간에 사라진다(게임 하다가 밥과 잠을 잃는 현상과 동일하다).  
그런 일을 십여 년 가까이 하다 보면 처음엔 다양하고 휘황찬란해 보였던 개발계의 여러 테마들이 어느 정도 질서 있게 눈에 들어오고, 그런 상황이 더 진행되면 심지어 단순하게도 느껴지게 된다.

20. 하지만, 내가 나를 정의할 때의 나는 아무리 잘 보려 해도 '잘 훈련된 코더coder'를 넘지 않는다. 나는 '잘 훈련된well-trained'이란 말에 자부심과 자긍심을 느낀다. 나는 스스로에게 부과한 과제에 매우 충실했던 사람이고, 그 과정에서 열매를 수확한 사람이기 때문이다. 나는 개발자를 특정한 '작업'에 한정 짓지 않고, 개발과 관련된 모든 일(기술적일 뿐 아니라, 물리학, 수학과 같은 학문적인 일도)에 특별한 관심을 두고, 어느 것도 함부로 무시하지 않는 사람으로 정의했기 때문에, 무엇이든 구현 가능한 개발자가 될 수 있었다. 나는 서버를 다루면서도 프론트 코딩을 할 수 있고, 때론 솔루션 개발자이기도 하면서도, 때론 보수적인 데이터 관리자이기도 하다.

21. 그렇다고 하더라도 여전히 미숙하고 배울 게 많은 것이 현재의 나고, 그것이 개발자라는 직업의 특징이다. 개발 환경은 늘 변하고, 그래서 개발자는 늘 배워야 하고, 무언가에 익숙해졌으면, 미련 없이 자리를 털고 일어나 새로운 기술을 배우러 가야 한다. 늘 처음인 것처럼 배우고, 늘 초보자인 것처럼 갈급해야 한다. 그렇게 살면서도 늘 새롭고, 늘 배울 것이 있다는 것이 이 직업의 '단점'이자, 그 단점을 압도하는 '장점'이다. 더 이상 배울 것이 없을 정도로 많이 안다는 것은 얼마나 허망한 일이겠는가!

22. 인공지능은 결국 '개발자'를 대체하려는 하나의 흐름에 다름이 아니다.

23. 트렌드를 모두 따라갈 수 있는 개발자들은 트렌드를 미리 보고 준비한 사람들이거나 혹은 순식간에 트렌드를 따라잡을 수 있을 정도로 개발의 기초가 튼튼한 사람들이었다. 하지만 '인공지능'의 시대가 왔을 때, 그런 기초가 튼튼한 개발자들조차도 당황할 수밖에 없었다. 인공지능 패러다임은 누가 뭐라해도 '순수이론의 시대', 혹은 '수학의 시대'를 의미했기 때문이다. 수학을 그저 개발의 선수과목 정도로 취급하고, 딱 그정도의 지식만 가지고 있던 개발자가 있다면, 매우 당황스러울 것이다(이것은 현장 개발자들뿐 아니라, 학교에서 가르치는 교수들도 마찬가지다). 이런 사람들이 새로운 시대에 대한 숨은 저항 세력이 되곤 하는데, 헛된 시도일 뿐이다. 대세는 거스를 수 없고, 첫차를 못 타면 막차라도 타야 한다.

24. 혼자만의 길을 걷는 것의 장점은, 자주 그러다 보면 어느새 익숙해져서, 혼자가는 일에 대한 두려움이 없어진다는 것이다. 물론 단점도 있다. 지금의 것을 전부 혹은 일부를 포기해야 하고, 지금의 친구들과 작별의 인사를 해야하며, 그렇게 떠난 길에서 '죽을' 수도 있다는 것이다. 새로운 길을 떠나는 것이 지금보다 나으리라는 보장 같은 건 전혀 없다(그래서 새로운 길은 보통 잃을 게 없는 사람들의 길이기도 하다).

25. 만약 내 알고리즘이 수학적으로 완전하게 기술될 수만 있다면, 나는 내 알고리즘에 대한 회의에서 놓여 날 뿐만 아니라, 어쩌면 새로운 사고나 연산 방법론을 개발한 사람이 될 수도 있는 것이다(보통 그런 능력이나 의사가 없는 사람들이 주로 학위나 권위에 의존하는 것이다).

26. 하지만 나는 내 안의 호기심을 억누르지 않고 진실을 추구했고, 진실을 찾았을 땐 다시 그 진실 너머의 진실을 추구했기 때문에 여기까지 오게되었고, 오늘도 삶과 연구를 위해 열심히 살아야 하는 사람이 되었다.

27. 국토 면적이 한국의 50배가 넘는 미국에서 소비자가 주문한 제품이 어떻게 하루만에 배달될 수 있을까. 이것은, 소비자가 인터넷 상점에서 구매한 구매 목록을 기반으로 그 소비자가 그 다음 구매할 가능성이 제일 높은 품목을 소비자가 주문하기 이전에 주소지 근처의 물류 센터로 이동시켜 놓음으로써 가능하다. 이때, 얼마나 많은 양의 물품을 그렇게 '미리'옮겨 놓아야 하는가, 역시 수학적으로 추정하여 정할 것이다. 물류 수송 역시 비용이고 그것을 최소화하기 위하여 그렇게 미리 옮겨 놓아야 하는 양을 적절히 정해야 하는데, 그 때 역시 수학적 분석이 필요하다.

28. 지금은 세계 여러 곳의 공개 강의를 인터넷으로 볼 수 있기 때문에 기초 과목들은 충분히 기본적인 개념 정도는 인터넷으로도 배울 수 있다. 항상 그렇듯 단지 의지가 부족할 뿐이다.

29. 선형 대수는 이과대/공대 학생들이 1학년 때 공통 필수로 배우는 미적분학에 있는 선형대수가 전부가 아니다. 선형 대수를 말하면 흔히 '행렬식' 구하는 거 아니냐, 역행렬, 고유값, 고유벡터 구하는 거 아니냐, 생각할 수 있다. 물론 그러한 것들 역시 매우 중요하다. 그러나 그에 더해 '공간'에 대한 수학적 개념을 배울 수 있고, 선형대수에서부터 여러 개념들이 파생되어 나올 수 있다. 특히 '차원'의 개념을 숫자를 이용하여 파악할 수 있게 된다.

30. 수치해석학에 대한 내용을 더 살펴 보고자 한다면 일명 '빨간책'으로 불리는 <Numerical Recipes in C> 혹은 <Numerical Recipes in C++>을 살펴 보자.

31. 수학과 수업이나 관련 서적 및 참고 자료들은 대부분 수학관련자를 위하여 작성되어 있기 때문에 프로그래머에게 적합한 것을 찾기는 쉽지 않은 실정이다. 그래서 결국 프로그래머 스스로 수학을 배우며 자신이 어떻게 그것을 이용할 것인지를 찾아야 한다. 그런데, 수학은 극단적으로 추상화된 개념들을 대상으로 한 것이기 때문에 현실의 문제를 그렇게 수학적인 것으로 바꾸기 위해서는 이미 수학에 익숙해지는 기간이 필요하다.

32. 오늘 씨를 심고 그 씨가 잘 자라는지 내일 땅을 파 보는 농부는 없다. 마찬가지로 한두 달 잠깐씩 공부하고 결론을 내리지 말고 꾸준히, 적어도 1년 이상은 수학 공부를 하면서 그 활용을 궁리하면 좋을 것이다. 어느 스님의 말씀으로 이 장을 끝맺도록 하겠다.  
"(어떤 일을) 하고 있으면서 (그 일이) 안 된다고 하는 사람은 없어. 안 된다고 하는 사람들은 죄다 안 하고 있는 사람들이야."

33. 공학의 3대장인 열역학, 유체역학, 동역학 책 아무거나 하나 펼쳐 보자.
