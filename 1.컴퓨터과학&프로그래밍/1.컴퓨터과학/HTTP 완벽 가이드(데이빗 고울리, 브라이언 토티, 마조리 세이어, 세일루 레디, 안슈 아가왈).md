# HTTP 완벽 가이드
### 지은이 : 데이빗 고울리, 브라이언 토티, 마조리 세이어, 세일루 레디, 안슈 아가왈
### 옮긴이 : 이응준, 정상일
### 출판사 : 인사이트(O'REILLY)
### 읽은 날 : 2020.03.21 ~

# 목차
# Part 1. HTTP: 웹의 기초
### 1. HTTP 개관
### 2. URL과 리소스
### 3. HTTP 메시지
### 4. 커넥션 관리

# Part 2. HTTP 아키텍처
### 5. 웹 서버
### 6. 프락시
### 7. 캐시
### 8. 통합점 : 게이트웨이, 터널, 릴레이
### 9. 웹 로봇
### 10. HTTP/2.0

# Part 3. 식별, 인가, 보안
### 11. 클라이언트 식별과 쿠키
### 12. 기본 인증
### 13. 다이제스트 인증
### 14. 보안 HTTP

# Part 4. 엔터티, 인코딩, 국제화
### 15. 엔터티와 인코딩
### 16. 국제화
### 17. 내용 협상과 트랜스코딩

# Part 5. 콘텐츠 발행 및 배포
### 18. 웹 호스팅
### 19. 배포 시스템
### 20. 리다이렉션과 부하 균형
### 21. 로깅과 사용 추적

# Part 6. 부록
### 부록 A. URI 스킴
### 부록 B. HTTP 상태 코드
### 부록 C. HTTP 헤더 레퍼런스
### 부록 D. MIME 타입
### 부록 E. base-64 인코딩
### 부록 F. 다이제스트 인증
### 부록 G. 언어 태그
### 부록 H. MIME 문자집합 등록

# Part 1. HTTP: 웹의 기초
### 1. HTTP 개관
1. 웹 서버는 모든 HTTP 객체 데이터에 MIME 타입을 붙인다. 웹브라우저는 서버로부터 객체를 돌려받을 때, 다룰 수 있는 객체인지 MIME 타입을 통해 확인한다. 대부분의 웹브라우저는 잘 알려진 객체 타입 수백 가지를 다룰 수 잇다. 이미지 파일을 보여주고, HTML 파일을 분석하거나 포맷팅하고, 오디오 파일을 컴퓨터의 스피커를 통해 재생하고, 특별한 포맷의 파일을 다루기 위해 외부 플러그인 소프트웨어를 실행한다.

2. 서버 리소스 이름은 통합 자원 식별자(uniform resource identifier), 혹은 URI로 불린다.

3. URI에는 두 가지가 있는데, URL과 URN이라는 것이다.

### 2. URL과 리소스
4. 일반적으로 HTTP 서버는 객체 일부가 아닌 전체만 다루기 때문에, 클라이언트는 서버에 프래그먼트를 전달하지 않는다. 브라우저가 서버로부터 전체 리소스를 내려받은 후, 프래그먼트를 사용하여 당신이 보고자 하는 리소스의 일부를 보여준다.

5. 인코딩 체계  
안전한 문자 집합을 이용하는 경우 그 표현의 한계를 넘기 위해, URL에 있는 안전하지 않은 문자들을 표현할 수 있는 인코딩 방식이 고안되었다. 인코딩은 안전하지 않은 문자를 퍼센티지 기호(%)로 시작해, ASCII 코드로 표현되는 두 개의 16진수 숫자로 이루어진 ‘이스케이프’ 문자로 바꾼다.

### 3. HTTP 메시지
6. HTTP는 인바운드와 아웃바운드라는 용어를 트랜잭션 방향을 표현하기 위해 사용한다. 메시지가 원 서버로 향하는 것은 인바운드로 이동하는 것이고, 모든 처리가 끝난 뒤에 메시지가 사용자 에이전트로 돌아오는 것은 아웃바운드로 이동하는 것이다.

7. 메시지는 결코 업스트림으로 흐르지 않는다.

8. HTTP 헤더는 다음과 같이 분류된다.
- 일반 헤더 : 요청과 응답 양쪽에 모두 나타날 수 있음
- 요청 헤더 : 요청에 대한 부가 정보를 제공
- 응답 헤더 : 응답에 대한 부가 정보를 제공
- Entity 헤더 : 본문 크기와 콘텐츠, 혹은 리소스 그 자체를 서술
- 확장 헤더 : 명세에 정의되지 않은 새로운 헤더

9. 안전한 메서드(Safe Method)  
HTTP는 안전한 메서드라 불리는 메서드의 집합을 정의한다. GET과 HEAD 메서드는 안전하다고 할 수 있는데, 이는 GET이나 HEAD 메서드를 사용하는 HTTP 요청의 결과로 서버에 어떤 작용도 없음을 의미한다.

10. HEAD  
HEAD 메서드는 정확히 GET처럼 행동하지만, 서버는 응답으로 헤더만을 돌려준다. 엔터티 본문은 결코 반환하지 않는다. 이는 클라이언트가 리소스를 실제로 가져올 필요 없이 헤더만을 조사할 수 있도록 해준다. HEAD를 사용ㅇ하면,
- 리소스를 가져오지 않고도 그에 대해 무엇인가(타입이라거나)를 알아낼 수 있다.
- 응답의 상태 코드를 통해, 개체가 존재하는지 확인할 수 있다.
- 헤더를 확인하여 리소스가 변경되었는지 검사할 수 있다.

11. PUT 메서드의 의미는, 서버가 요청의 본문을 가지고 요청 URL의 이름대로 새 문서를 만들거나, 이미 URL이 존재한다면 본문을 상요해서 교체하는 것이다.

12. TRACE 메서드는 주로 진단을 위해 사용된다. 예를 들면 요청이 의도한 요청/응답 연쇄를 거쳐가는지 검사할 수 있다. 또한 프락시나 다른 애플리케이션들이 요청에 어떤 영향을 미치는지 확인해보고자 할 때도 좋은 도구다.

13. OPTIONS  
OPTIONS 메서드는 웹 서버에게 여러 가지 종류의 지원 범위에 대해 물어본다. 서버에게 특정 리소스에 대해 어떤 메서드가 지원되는지 물어볼 수 있다(몇몇 서버는 특정 종류의 객체에 대해 특정 동작만을 지원한다).

14. 확장 메서드(그리고 대부분의 HTTP 확장)를 다룰 때는 “엄격하게 보내고 관대하게 받아들여라”라는 오랜 규칙에 따르는 것이 가장 좋다.
 
### 4. 커넥션 관리
15. 신뢰할 수 있는 데이터 전송 통로인 TCP  
HTTP 커넥션은 몇몇 사용 규칙을 제외하고는 TCP 커넥션에 불과하다. TCP 커넥션은 인터넷을 안정적으로 연결해준다. 신속 정확하게 데이터를 보내고자 한다면 TCP의 기초적은 내용을 알아야 한다.

16. TCP 커넥션은 네 가지 값으로 식별한다.
<발신지 IP주소, 발신지 포트, 수신지 IP주소, 수신지 포트>
이 네 가지 값으로 유일한 커넥션을 생성한다. 서로 다른 두 개의 TCP 커넥션은 네 가지 주소 구성요소의 값이 모두 같을 수 없다(하지만 주소 구성요소 일부가 같을 수는 있다).

17. 소켓 API는 HTTP 프로그래머에게 TCP와 IP 세부사항들을 숨긴다. 소켓 API는 유닉스 운영체제용으로 먼저 개발되었지만, 지금은 소켓 API의 다양한 구현체들 덕분에 대부분의 운영체제와 프로그램 언어에서 이를 사용할 수 있게 되었다.

18. 병렬 커넥션  
앞서 언급했듯이 브라우저는 HTML 페이지에 이어 첫 번째 첨부된 객체, 두 번째 첨부된 객체를 하나씩 내려받는 식으로 웹페이지를 보여줄 수 있다. 하지만 이 방식은 너무 느리다!
HTTP는 클라이언트가 여러 개의 커넥션을 맺음으로써 여러 개의 HTTP 트랜잭션을 병렬로 처리할 수 있게 한다.

19. 백 명의 가상 사용자가 각각 100개의 커넥션을 맺고 있다면, 서버는 총 10,000개의 커넥션을 떠안게 되는 것이다. 이는 서버의 성능을 크게 떨어뜨린다. 이런 상황은 고부하 프락시에서도 동일하게 발생할 수 있다.
브라우저는 실제로 병렬 커넥션을 사용하긴 하지만 적은 수(대부분 6~8개)의 병렬 커넥션만을 허용한다. 서버는 특정 클라이언트로부터 과도한 수의 커넥션이 맺어졌을 경우, 그것을 임의로 끊어버릴 수 있다.

20. 지속 커넥션  
웹 클라이언트는 보통 같은 사이트에 여러 개의 커넥션을 맺는다. 예를 들어 웹페이지에 첨부된 이미지들 대부분은 같은 웹 사이트에 있고, 상당수의 하이퍼링크도 같은 사이트를 가리킨다.  따라서 서버에 HTTP 요청을 하기 시작한 애플리케이션은 웹페이지 내의 이미지 등을 가져오기 위해서 그 서버에 또 요청하게 될 것이다. 이 속성을 사이트 지역성(site locality)라 부른다.

21. 따라서 HTTP/1.1(HTTP/1.0의 개선 버전)을 지원하는 기기는 처리가 완료된 후에도 TCP 커넥션을 유지하여 앞으로 있을 HTTP 요청에 재사용할 수 있다. 처리가 완료된 후에도 계속 연결된 상태로 있는 TCP 커넥션을 지속 커넥션이라 부른다. 비지속 커넥션은 각 처리가 끝날 때마다 커넥션을 끊지만, 지속 커넥션은 클라이언트나 서버가 커넥션을 끊기 전까지는 트랜잭션 간에도 커넥션을 유지한다.

22. 해당 서버에 이미 맺어져 있는 지속 커넥션을 재사용함으로써, 커넥션을 맺기 위한 준비작업에 따르는 시간을 절약할 수 있다. 게다가 이미 맺어져 있는 커넥션은 TCP의 느린시작으로 인한 지연을 피함으로써 더 빠르게 데이터를 전송할 수 있다.

23. Keep-Alive와 멍청한(dumb) 프락시  
특히 문제는 프락시에서 시작되는데, 프락시는 Connection 헤더를 이해하지 못해서 해당 헤더들을 삭제하지 않고 요청 그대로 다음 프락시에 전달한다. 오래되고 단순한 수많은 프락시들이 Connection 헤더에 대한 처리 없이 요청을 그대로 전달한다. 웹 클라이언트가 무조건 전달을 하는 멍청한 프락시를 거쳐 웹 서버에 메시지를 전송한다고 생각해보자.

24. HTTP/1.1의 지속 커넥션  
HTTP/1.1에서는 keep-alive 커넥션을 지원하지 않는 대신, 설계가 더 개선된 지속 커넥션을 지원한다. 지속 커넥션의 목적은 kepp-alive 커넥션과 같지만 그에 비해 더 잘 동작한다.
HTTP/1.0의 keep-alive 커넥션과는 달리 HTTP/1.1의 지속 커넥션은 기본으로 활성화되어 있다. HTTP/1.1에서는 별도 설정을 하지 않는 한, 모든 커넥션을 지속 커넥션으로 취급한다. HTTP/1.1 애플리케이션은 트랜잭션이 끝난 다음 커넥션을 끊으려면 Connection : close 헤더를 명시해야 한다.

25. 한 번 혹은 여러 번 실행됐는지에 상관없이 같은 결과를 반환한다면 그 트랜잭션은 멱등(idempotent)하다고 한다. GET, HEAD, PUT, DELETE, TRACE 그리고 OPTIONS 메서드들은 멱등하다고 이해하면 된다. 클라이언트는 POST와 같이 멱등이 아닌 요청은 파이프라인을 통해 요청하면 안 된다. 그렇지 않으면 전송 커넥션이 예상치 못하게 끊어져 버렸을 때, 알 수 없는 결과를 초래할 수 있다. 비멱등인 요청을 다시 보내야 한다면, 이전 요청에 대한 응답을 받을 때까지 기다려야 한다.
