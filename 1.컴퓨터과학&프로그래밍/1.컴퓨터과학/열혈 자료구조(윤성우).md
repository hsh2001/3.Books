# 열혈 자료구조
### 지은이 : 윤성우
### 출판사 : 오렌지 미디어
### 읽은 날 : 2020.02.03

‘이렇듯 자료구조와 알고리즘은 밀접한 관계를 갖는다. 자료구조가 결정되어야 그에 따른 효율적인 알고리즘을 결정할 수 있기 때문이다.’

‘사실 메모리를 적게 쓰고 속도도 빨라야 최적의 알고리즘이라 할 수 있다. 그런데 일반적으로 알고리즘을 평가할 때는 메모리의 사용량보다 실행속도에 초점을 둔다. 대게는 속도에 관심이 더 많고, 또 중요한 요소로 판단되기 때문이다. 물론 특정 알고리즘에 대해서 상대적인 우월성을 입증해야 하는 경우에는 메모리의 사용량도 함께 고려가 되지만, 이미 검증이 끝난 알고리즘의 적용을 고려하는 경우에는 속도에 초점을 두어 적합성 여부를 판단하게 된다.’

‘정답이 없는 것이 아니라 상황에 맞게 답을 내려야 하는 것이다. 따라서 필자는 여러분이 알고리즘의 구현능력에만 관심을 두는 것을 바라지 않는다. 어찌 보면 구현보다 중요한 것은 종합적으로 사고하고 판단하는 능력이기 때문이다.’

‘값의 동등을 비교하는 == 연산을 적게 수행하는 탐색 알고리즘이 좋은 탐색 알고리즘이다.’

‘O(n)의 알고리즘을 O(logn)의 알고리즘으로 개선시키는 것은 약간의 개선이 아닌, 혁신적인 성능의 개선으로 간주되기 때문이다.’

‘Recursive 함수를 실행하는 중간에 다시 Recursive 함수가 호출되면, Recursive 함수의 복사본을 하나 더 만들어서 복사본을 실행하게 됩니다.’

‘return Fibo(n-1) + Fibo(n-2);
즉 두개의 Fibo 함수가 다시 호출되는데, + 연산자의 왼편에 있는 Fibo 함수호출이 완료되어야 비로소 + 연산자의 오른편에 있는 Fibo 함수호출이 진행이 된다.’

‘구체적인 기능의 완성과정을 언급하지 않고, 순수하게 기능이 무엇인지를 나열한 것을 가리켜 ‘추상 자료형’ 또는 간단히 ADT라 한다.’

‘리스트 자료구조는 데이터를 나란히 저장합니다. 그리고 중복된 데이터의 저장을 막지 않습니다.’

‘솔직히 말하자면 자료구조는 코드를 통해서 공부하는 과목이 아니다. 코드를 통한 학습 이전에, 그림으로 설명하고 그림으로 이해해야 하는 과목이다.’

‘자료구조를 제대로 공부하려면 가급적 다음 세가지 순서를 지켜서 공부해야 한다.
1. 자료구조의 ADT 정의
2. 정의한 ADT의 구현
3. 구현이 완료된 자료구조의 활용’

‘우리는 자료구조의 구현 능력을 중요시하는 경향이 있다. 물론 어느 정도 필요한 능력인 것은 맞다. 하지만 절대시할 필요는 없다.’

‘하지만 양방향 연결 리스트는 양방향으로 얼마든지 조회가 가능하다. 따라서 포인터 변수 before가 불필요하고, before를 유지하기 위해 곳곳에 존재하는 문장들도 불필요하다.’

‘기능적인 부분만 고려를 한다면 배열은 대부분 연결 리스트로 교체가 가능하다. 배열도 연결 리스트도 기본적인 선형 자료구조이기 때문이다.’

‘위의 트리를 가리켜 ‘완전 이진 트리(complete binary tree)’라 한다. 이는 포화 이진 트리처럼 모든 레벨이 꽉 찬 상태는 아니지만, 차곡차곡 빈 틈 없이 노드가 채워진 이진 트리를 뜻한다. 그리고 여기서 말하는 ‘차곡차곡 빈 틈 없이 노드가 채워진 상태’가 갖는 의미는 다음과 같다.
“노드가 위에서 아래로, 그리고 왼쪽에서 오른쪽의 순서대로 채워졌다!”’

‘완전 이진 트리의 구조를 갖는 ‘힙(heap)’이라는 자료구조는 배열을 기반으로 구현한다. 힙이 요구하는 바를 만족시키기가 배열이 훨씬 용이하기 때문이다.’

‘힙은 ‘이진 트리’이되 ‘완전 이진 트리’이다. 그리고 모든 노드에 저장된 값은 자식 노드에 저장된 값보다 크거나 같아야 한다. 즉 루트 노드에 저장된 값이 가장 커야 한다.(max heap의 경우)’

‘이렇듯 힙은 루트 노드에 우선순위가 가장 높은 데이터를 위치시킬 수 있는 자료구조이니, 이를 기반으로 하면 우선순위 큐를 간단히 구현할 수 있지 않겠는가! 참고로 위의 두 그림에서 보이듯이, 힙은 무엇인가를 쌓아 놓은 더미와 흡사하다 하여 지어진 이름이다. 영단어 heap은 ‘무엇인가를 차곡차곡 쌓아 올린 더미’라는 뜻을 지닌다.’

‘힙을 기반으로 하면 트리의 높이에 해당하는 수만큼만 비교연산을 진행하면 됩니다.
-힙 기반 데이터 저장의 시간 복잡도 O(logn)
-힙 기반 데이터 삭제의 시간 복잡도 O(logn)’

‘하지만 우리의 생각과 달리 완전 이진 트리의 구조를 갖고 또 그 구조를 유지해야 하는 ‘힙’은 배열을 기반으로 구현해야 한다. 실제로 힙의 구현은 배열을 기반으로 구현하는 것이 원칙으로 여겨지고 있는데, 그 이유는 다음과 같다.
“연결 리스트를 기반으로 힙을 구현하면, 새로운 노드를 힙의 ‘마지막 위치’에 추가하는 것이 쉽지 않다.”’

‘정렬 알고리즘의 성능은 다음 두 가지 근거로 판단되는 것이 일반적이다. ‘비교연산’과 데이터의 이동을 위한 ‘대입연산’이 정렬과정의 핵심연산이기 때문이다.
-비교의 횟수 : 두 데이터간의 비교연산의 횟수
-이동의 횟수 : 위치의 변경을 위한 데이터의 이동횟수’

‘Selection Sort
정렬순서상 가장 앞서는 것을 선택해서 가장 왼쪽으로 이동시키고, 원래 그 자리에 있던 데이터는 빈 자리에 가져다 놓는다.’

‘최악의 경우를 놓고 보면 버블 정렬보다 선택 정렬에 좋은 성능을 기대할 수 있겠지만, 버블 정렬은 최선의 경우에 단 한 번의 데이터 이동도 발생하지 않는다는 점과, 실제로 데이터들이 늘 최악의 상황으로 배치되지 않는다는 사실을 감안하면, 이 둘의 우열을 가리는 것은 무의미하다고 할 수 있다.’

‘”효율적인 탐색을 위해서는 ‘어떻게 찾을까’만을 고민해서는 안 된다. 그보다는 ‘효율적인 탐색을 위한 저장방법이 무엇일까’를 우선 고민해야 한다.”
그런데 효율적인 탐색이 가능한 대표적인 저장방법은 ‘트리’이다.’

‘보간 탐색은 이러한 이진 탐색의 비효율성을 개선시킨 알고리즘이다. 개선의 원리는 다음과 같다.
“이진 탐색처럼 그냥 중앙에서 탐색을 시작하지 않고, 탐색대상이 앞쪽에 위치해 있으면 앞쪽에서 탐색을 시작하자!”’

‘이진 탐색 트리의 단점을 해결한 트리를 가리켜 ‘균형 잡힌 이진 트리’라 하며, 그 종류는 대략 다음과 같다.
- AVL 트리
- 2-3 트리
- 2-3-4 트리
- Red-Black 트리
- B트리’

‘”키(key)가 존재하지 않는 ‘값’은 저장할 수 없다. 그리고 모든 키는 중복되지 않는다.”
이렇듯 테이블의 핵심은, 키와 값이 하나의 쌍을 이루어 저장되는 데이터 유형에 있다.’

‘좋은 해쉬 함수는 키의 일부분을 참조하여 해쉬 값을 만들지 않고, 키 전체를 참조하여 해쉬 값을 만들어 낸다.’

‘(해쉬)충돌이 발생했을 때 그 옆자리가 비었는지 살펴보고, 비었을 경우 그 자리에 대신 저장하는 것이 바로 ‘선형 조사법(Linear Probing)’이다.’

‘체이닝(Chaining)
이번에 소개할 충돌 해결책은 앞서 소개한 방법들과 해결방식이 근본적으로 다르다. 앞서 소개한 유형의 방법들을 가리켜 ‘열린 어드레싱 방법(open addressing method)’이라 하는데, 이는 충돌이 발생하면 다른 자리에 대신 저장한다는 의미가 담겨 있다. 반면 이번에 소개하는 유형의 방법을 가리켜 ‘닫힌 어드레싱 방법(closed addressing method)’이라 한다. 그리고 여기에는 무슨 일이 있어도 자신의 자리에 저장을 한다는 의미가 담겨 있다.

‘DFS 알고리즘의 요구대로 정점을 이동하는데 있어서 스택은 매우 중요한 역할을 한다. 때문에 DFS 알고리즘은 스택의 용도를 이해하는 것이 전부라고 해도 과언이 아니다.’

‘사이클을 형성하지 않는 그래프들을 가리켜 ‘신장 트리(spanning tree)’라 한다.’

‘MST(Minimum Spanning Tree, 최소비용신장트리)는 다음의 특성을 지닌다.
간선의 수 + 1 = 정점의 수’