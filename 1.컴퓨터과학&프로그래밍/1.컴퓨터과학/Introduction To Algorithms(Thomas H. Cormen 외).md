# Introduction To Algorithms
### 지은이 : Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, Clifford Stein
### 옮긴이 : 문병로, 심규석, 이충세
### 출판사 : The MIT Press, 한빛아카데미
### 읽은 날 : 2020.02.07 ~

### 목차

1. 기초

1)알고리즘의 역할

2)시작하기

3)함수의 증가

4)분할정복

5)확률적 분석과 랜덤화된 알고리즘

2. 정렬과 순서 통계량

6)힙 정렬

7)퀵 정렬

8)선형 시간 정렬

9)중앙값과 순서 통계량

3. 자료구조

10)기본 자료구조

11)해시 테이블

12)이진 검색 트리

13)레드블랙 트리

14)자료구조의 확장

4. 고급 설계 및 분석 기법

15)동적 프로그래밍

16)그리디 알고리즘

17)분할상환 분석

5. 고급 자료구조

18)B-트리

19)피보나치 힙

20)반 엠데 보아스 트리

21)서로 소 집합의 자료구조

6. 그래프 알고리즘

22)기본 그래프 알고리즘

23)최소 신장 트리

24)단일 출발지 최단 경로

25)모든 쌍의 최단 경로

26)최대 플로우

7. 알고리즘 분야의 중요한 토픽

27)멀티스레드 알고리즘

28)행렬의 연산

29)선형 계획법

30)다항식과 FFT

31)정수론 알고리즘

32)스트링 매칭

33)계산 기하학

34)NP-완비성

35)근사 알고리즘

8. 부록 : 수학적 기초

A)합

B)집합과 기타

C)계산과 통계

D)행렬

### Chapter 1. 알고리즘의 역할

1. 알고리즘은 간단히 말해 어떤 값이나 값의 집합을 입력으로 받아 또 다른 값이나 값의 집합을 출력하는 잘 정의된 계산 절차를 말한다. 따라서 알고리즘은 어떤 입력을 어떤 출력으로 변환하는 일련의 계산 과정이라고 할 수 있다.

2. 게다가 응용 프로그램 수준에서 알고리즘이 필요 없는 프로그램도 실제로는 알고리즘에 상당히 의존한다. 프로그램에서 빠른 하드웨어가 중요하다면 그 하드웨어 설계에 알고리즘이 중요하다. 그래픽 사용자 인터페이스가 중요하다면 역시 그 설계 단계에서 알고리즘이 중요한 역할을 한다. 네트워킹이 중요한 프로그램이라면 네트워크에서 경로를 찾는 문제는 전적으로 알고리즘에 달렸다. 또한 기계어 코드 외의 프로그래밍 언어로 만든 프로그램이라면, 이 프로그램은 컴파일러, 인터프리터, 어셈블러 등으로 만들어지며 모두 알고리즘에 상당히 의존한다. 결국 알고리즘은 현대 컴퓨터 분야에서 거의 모든 기술의 중심에 있다고 할 수 있다.

3. “알고리즘에 대한 지식과 기술을 얼마나 알차게 학습했느냐”가 숙련된 프로그래머와 초보자를 구분하는 기준이 될 수 있다. 알고리즘에 대한 별다른 지식 없이도 최신 컴퓨터 기술을 통해 어떤 일을 할 수 있을지 모른다. 하지만 알고리즘에 대한 훌륭한 배경 지식을 쌓으면 훨씬 더 많은 일을 할 수 있을 것이다.

### Chapter 2. 시작하기

4. INSERTION-SORT의 수행시간은 입력에 의해 결정된다. … 일반적으로 입력 크기가 커질수록 알고리즘의 수행시간이 증가하므로 수행시간을 입력 크기의 함수로 표현한다.

5. 병합 정렬은 분할정복 기법을 아주 잘 이용한다. 직관적으로 설명하면 다음과 같다.
- 분할 : 정렬할n개 원소의 배열을 n/2개씩 부분 수열 두 개로 분할한다.
- 정복 : 병합 정렬을 이용해 두 부분 배열을 재귀적으로 정렬한다.
- 결합 : 정렬된 두 개의 부분 배열을 병합해 정렬된 배열 하나로 만든다.

6. 병합 정렬 알고리즘에서 핵심 작업은 “결합”단계에서 정렬된 두 부분 수열을 병합하는 것이다. 병합을 하기 위해 보조 프로시저 MERGE(A, p, q, r)이 필요한데, 여기서 A는 배열이고 p, q, r은 인덱스로 p <= q < r을 만족한다. 프로시저 MERGE는 두 부분배열 A[p..q]와 A[q+1..r]이 정렬되어 있다고 가정하고 이를 병합해서 정렬된 배열 하나를 만드는데, 이것이 원래의 부분 배열 A[p..r]을 대체한다.

### Chapter 3. 함수의 증가

### Chapter 4. 분할정복

7. 부분 문제가 재귀적으로 풀 수 있을 만큼 충분히 클 때 재귀 대상이라고 한다. 부분 문제가 충분히 작아져 더 이상 재귀 호출을 할 수 없을 때 재귀가 “바닥을 쳤다”고 하고, 베이스 케이스까지 내려왔다고 이야기한다. 때로는 입력의 크기가 더 작은 완전히 동일한 부분 문제 외에 원래의 문제와 다른 부분 문제를 풀어야 할 때도 있다. 그런 부분 문제는 결합 단계의 일부로 간주한다.

8. 치환법이 점화식의 해가 맞는지에 대한 간결한 증명을 제공해 준다고 하더라도 좋은 추측을 해내기가 어려울 때가 있다. 2.3.2절의 병합 정렬의 점화식을 분석하면서 한 것 같이 재귀 트리를 그리는 것은 좋은 추측식을 고안해내기 위한 직접적인 방법이다. 재귀 트리(recursion tree)에서는 각 노드가 재귀 호출되는 하위 문제 하나의 비용을 나타낸다. 레벨당 비용의 집합을 얻기 위해 트리의 각 레벨마다 그 비용을 합한 후, 재귀의 모든 레벨에서의 총 비용을 결정하기 위해 모든 레벨당 비용을 합한다.

### Chapter 5. 확률적 분석과 랜덤화된 알고리즘

9. 확률적 분석은 문제를 분석할 때 확률을 사용하는 것이다. 확률적 분석은 주로 알고리즘의 수행시간을 분석하기 위해 사용한다. 때로는 HIRE-ASSISTANT 프로시저에서의 고용 비용처럼 다른 값을 분석하기 위해서도 쓰인다.
확률적 분석을 하기 위해서는 입력의 분포에 대한 정보를 이용하거나 그에 관한 가정을 해야 한다. 그리고 평균 수행시간을 계산하기 위해 알고리즘을 분석해야 한다. 그러한 기댓값은 모든 가능한 입력의 분포에 따라 결정된다. 그러므로 가능한 모든 입력에 대한 수행시간의 평균을 구해야 한다. 모든 입력에 대한 수행시간의 평균을 평균 수행시간이라 한다.

10. 랜덤화된 알고리즘
확률적 분석을 이용하기 위해서는 입력의 분포에 대해 어느 정도 알아야 한다. 많은 경우, 입력 분포에 대해 알 수 있는 것이 거의 없다. 설사 입력 분포에 대해 어느 정도 아는 경우에도 그러한 지식을 계산 모델로 만들기 어려울 수 있다. 그래서 확률과 무작위성을 통해 알고리즘의 일부가 랜덤하게 동작하도록 함으로써 알고리즘 설계와 분석을 위한 도구로 종종 사용하게 된다.

