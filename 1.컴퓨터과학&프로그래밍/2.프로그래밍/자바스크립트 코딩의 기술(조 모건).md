# 자바스크립트 코딩의 기술
### 지은이 : 조 모건
### 출판사 : 길벗
### 읽은 날 : 2020.02.05 ~

Chapter.1 ~ Chapter.6

1. 그러나 자바스크립트에서는 재할당할 수 없는 const를 기본으로 선택하면 좋습니다. 값을 할당한다는 것은 단순히 정보를 선언하는 것이 아닙니다. 무엇을 정보로 할지에 대한 신호를 보내는 것이기도 합니다. 값을 할당하고 변경하지 않을 것이라는 점을 표시하면, 미래의 개발자(여러분 자신이 될 수도 있습니다)에게 다음 사실, 즉 코드를 훑어볼 때 해당 변수를 신경 쓰지 않아도 된다고 알려줄 수 있습니다. 처음 보는, 그리고 양도 많은 코드를 읽을 때 읽은 내용의 일부를 잊어버려도 괜찮다면 행복하겠지요? Const 덕분입니다.

2. 실제로 키-값 쌍을 사용해 맵 객체와 배열 간의 데이터를 변환합니다. 그리고 현재 TC39위원회는 Object.entries()를 이용해서 객체를 키-값 쌍 배열로 변환하는 명세를 확정했습니다. 따라서 객체를 빠르게 변환해서 배열에 사용하는 모든 기술을 객체에도 사용할 수 있습니다.

3. splice() 메서드가 for문의 괜찮은 대안처럼 보이겠지만, 조작은 너무나 많은 혼란을 가져오므로 가능하면 피하는 것이 좋습니다. 끝으로 방법이 하나 더 있습니다. 배열에는 slice()라는 메서드가 있습니다. Slice() 메서드는 원본 배열을 변경하지 않고 배열의 일부를 반환합니다.

4. 조작이 항상 골치 아픈 일을 만들어내는 것은 아니지만 잠재적으로 문제가 되는 것은 사실이므로, 가능하면 조작을 피하는 것이 좋습니다. 실제로 리덕스를 비롯한 인기 있는 자바스크립트 라이브러리는 조작을 이용하는 함수를 허용하지 않습니다.
또한 모던 자바스크립트의 상당수가 함수형 프로그래밍 형식을 취하기 때문에 부수 효과와 조작이 없는 코드를 작성해야 합니다.

5. 사용해야 할 메서드가 원본을 조작할 때, 어떻게 하면 조작을 막을 수 있을까요? 답은 간단합니다. 원본 데이터를 조작하지 않으면 됩니다. 그 대신에 사본을 만들고, 사본을 조작하세요.
배열을 정렬하기 전에 원본 배열과 펼침 연산자로 새로운 배열을 만들기만 하면 됩니다.

6. ES6는 Object.assign()을 새롭게 추가해 다른 객체의 키-값으로 객체의 필드를 생성하고 갱신할 수 있도록 했습니다. 즉, Object.assign()을 이용하면 다른 객체의 속성을 이용해서 객체를 갱신할 수 있습니다.

7. 중첩된 객체가 있는 객체를 복사하는 것을 깊은 복사(deep copy) 또는 깊은 병합(deep merge)이라고 합니다. 위 예제 코드에서 years 속성은 문제없이 복사할 수 있지만, name 속성은 복사할 수 없습니다. 실제로 키 name에 할당된 독립적인 객체에 대한 참조만 복사됩니다. 중첩된 객체는 해당 객체를 담고 있는 객체와 독립적으로 존재합니다. 중첩된 객체를 담고 있는 객체가 가지고 있는 것은 중첩된 객체에 대한 참조뿐입니다. 참조에 대한 복사만으로는 중첩된 객체에 깊은 복사를 적용할 수 없습니다. 단지 참조의 위치를 복사하는 것에 불과합니다.

8. Object.assign()에서 경험했던 깊은 병합 문제는 객체 펼침 연산자를 사용해도 여전히 발생합니다. 중첩된 객체가 있는 경우에는 객체를 복사하지 않고 참조만 복사하기 때문에 조작으로 인한 잠재적인 문제를 만듭니다.

9. 객체 펼침 연산자는 환상적입니다. 코드를 작성하는 훌륭한 문법인 동시에 여러분의 코드베이스에서 실험적인 기능을 통합할 수 있는 기회도 됩니다.

10. 맵은 특정 작업을 매우 쉽게 처리하는 특별한 종류의 컬렉션입니다. MDN에는 일반적인 객체보다 맵을 컬렉션으로 선택하는 것이 더 나은 상황이 잘 정리되어 있습니다. 전체 목록을 살펴보는 것을 추천합니다. 이번 팁에서는 그중 다음 두 가지 상황을 살펴보겠습니다.
- 키-값 쌍이 자주 추가되거나 삭제되는 경우
- 키가 문자열이 아닌 경우

11. 맵은 좀 더 특화된 컬렉션이므로 자바스크립트 엔진 개발자들은 코드가 좀 더 빠르게 동작하도록 최적화할 수 있습니다. 객체에서 키 탐색은 선형 시간이 소요됩니다. 반면에 맵이 브라우저에 내장 구현된 경우 맵의 키 탐색은 로그 시간이 될 수 있습니다. 즉, 큰 객체가 큰 맵보다 비용이 더 큽니다.

12. 리액트 같은 몇몇 프로젝트에서 단순히 성능 개선을 목적으로 객체 대신 브라우저에 내장된 맵으로 전환한 사례도 있습니다. 객체와 맵을 두고 성능을 가늠할 필요는 없지만, 브라우저 엔진에서 둘을 서로 다르게 다룬다는 점을 기억하길 바랍니다.

13. 객채의 경우 키에 사용할 수 있는 자료형에 제약이 있습니다. 객체에는 특정한 자료형의 키만 사용할 수 있습니다. 가장 중요한 점은 정수를 키로 사용할 수 없다는 것입니다. 이는 수와 관련된 키를 저장할 때 문제가 될 수 있습니다.

14. 정수를 키로 하는 경우는 점 표기법으로 접근할 수 없습니다. Errors[100]처럼 배열 표기법으로 정보에 접근할 수는 있지만, 다소 꼼수에 가깝습니다. 정보에 접근할 수 있는 이유는 오류 코드 객체를 생성했을 때 모든 정수가 문자열로 변환됐기 때문입니다. 그리고 배열 표기법을 사용하면 탐색에 앞서 정수가 문자열로 변경됩니다. 키 목록을 확인해보면 문자열이 담긴 배열이 반환됩니다.

15. 삼항 연산자는 코드를 단순화할 수 있어서 사용할 만한 가치가 있는 경우에만 쓰고, 삼항 연산자로 인해 지나치게 코드가 모호해진다면 일반적인 if문으로 돌아가는 것이 바람직합니다.

16. 불 표현식 true 또는 false를 검사할 때 참 값을 사용할 수 있으므로, 언어 입장에서는 참 값을 구태여 true로 변경ㅎ아는 것이 별 이득이 없습니다. 따라서 OR연산자로 검사한 값 중 하나가 true를 반환하면, 실제로는 true 대신 검사를 통과한 참 값이 반환됩니다.

17. 단순함은 훌륭합니다. 또한, 코드를 한 줄로 줄이는 똑똑한 방법을 찾는 것은 즐거운 일입니다. 그렇지만 목표는 항상 코드를 통한 의사소통과 가독성입니다. 단락 평가를 사용해 코드를 좀 더 읽기 좋게 만드세요. 그저 코드를 줄이기 위한 용도는 아닙니다.

18. for문과 for..of 문을 절대 사용하지 말라는 말이 아닙니다. 그렇지만 적게 사용하는 것이 좋습니다. 왜 그럴까요? 이유는 간단합니다. for문과 for…of문이 불필요할 정도로 어수선하기 때문입니다. 모던 자바스크립트를 작성한다는 것은 간결함, 가독성, 예측 가능성을 갖춘 코드를 작성하는 것을 의미하며, 이러한 목표에 전통적인 반복문은 부합하지 않습니다. 이러한 목표에 적합한 도구는 배열 메서드입니다.

19. find() 메서드를 사용할 때의 유일한 단점은 반환값을 확신할 수 없다는 점입니다.

20. forEach()가 가치 있는 이유는 다른 메서드처럼 코드를 단순하게 만들기 때문이 아닙니다. 그보다는 예측 가능하면서도 다른 배열 메서드와 같이 작동해 함께 연결할 수 있기 때문에 가치가 있는 것입니다.

21. 배열 메서드 체이닝의 유일한 단점은 새로운 메서드를 호출할 때마다 반환된 배열 전체를 다시 반복한다는 점입니다. 모든 작업에 for 문을 사용한다면 name, active, email에 각 한 번씩 총 세 번을 순회하는 것이 전부이지만, 체이닝을 사용하면 모든 작업을 수행하기 위해 일곱 번 반복합니다(원본 배열에 filter()를 적용할 때 세 번, map()에 두 번, forEach()를 호출할 때 두 번). 그렇지만 여기에 지나치게 신경을 쓸 필요는 없습니다. 대규모 데이터를 다루는 것이 아니라면 그리 중요하지 `. 가끔은 약간의 성능 향상보다 가독성이 주용한 경우도 있습니다. 또 때로는 그렇지 않은 경우도 있지요. 그저 반복이 좀 더 많다는 것을 기억해두면 충분합니다.

22. 예를 들어, 인기 있는 에어비엔비의 스타일 가이드는 항상 배열 메서드를 사용하고 for…of 문과 for…in문의 사용을 제한해야 한다고 주장합니다. 그렇지만 모든 사람이 이에 동의하지는 않습니다.

23. 자바스크립트에서는 해체 할당이라는 과정을 통해 객체에 있는 정보를 곧바로 변수에 할당할 수 있습니다. 해체 할당의 작동 원리는 이렇습니다. 먼저 객체에 있는 키와 같은 이름의 변수를 생성하고, 객체에 있는 키에 연결된 값을 생성한 변수의 값으로 할당합니다.
