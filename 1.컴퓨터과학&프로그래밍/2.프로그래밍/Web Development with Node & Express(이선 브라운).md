# Web Development with Node & Express
### 지은이 : 이선 브라운(Ethan Brown)
### 출판사 : 길벗
### 읽은 날 : 2020.03.14 ~

### Overview
1. 익스프레스 소개
2. 노드 시작하기
3. 익스프레스로 시간 절약
4. 모양새 갖추기
5. 품질보증
6. 요청과 응답 객체
7. 핸들바를 사용한 템플릿
8. 폼 처리
9. 쿠키와 세션
10. 미들웨어
11. 이메일 보내기
12. 실무 관심사
13. 지속성
14. 라우팅
15. REST API와 JSON
16. 정적 콘텐츠
17. 익스프레스에서 MVC 구현
18. 보안
19. 타사 API와의 통합
20. 디버그

### 1. 익스프레스 소개
1. 익스프레스 웹사이트에서는 익스프레스를 ‘단일, 다중 페이지, 하이브리드 웹 애플리케이션을 만드는 데 필요한 견고한 기능 집합을 제공하는, 최소화되고 유연한 노드 웹 애플리케이션 프레임워크’라고 설명합니다.

2. 개발자로서 가장 짜증 나는 일은 다른 사람의 패키지를 쓰면서 소스를 여기저기 뒤져 라이선스 정책을 찾아보는 일이고, 라이선스가 아예 없음을 발견하면 절망스럽기까지 합니다.

### 2. 노드 시작하기
3. 노드는 전통적 웹 서버와 다른 패러다임, 즉 ‘지금 만드는 앱이 곧 웹 서버이다’라는 패러다임을 제시합니다. 노드는 단순히 웹 서버를 만드는 프레임워크를 제공할 뿐입니다.

4. 자바스크립트 안에서 HTML을 쓰지 않으려 하기 때문입니다.

5. 노드의 핵심 철학은 이벤트 기반 프로그래밍입니다. 이벤트 기반 프로그래밍에서는 프로그래머가 어떤 이벤트를 사용할 수 있는지, 거기에 어떻게 응답해야 하는지 이해해야 합니다.

6. 라우팅  
라우팅이란 요청받은 콘텐츠를 클라이언트에 보내는 메커니즘입니다. 웹 기반 클라이언트/서버 애플리케이션에서는 클라이언트가 원하는 콘텐츠를 URL에 표시, 즉 경로와 쿼리스트링에 표시합니다.

7. 개발 도중 혹은 작은 프로젝트를 진행할 때는 노드에서 정적 자원을 전송해도 별 문제가 없지만, 큰 프로젝트를 진행할 때는 엔진X 같은 프록시(proxy) 서버나 CDN을 사용해야 할 겁니다.

8. 아파치나 IIS를 써봤다면 HTML 파일을 만들어 클라이언트가 그 파일로 이동하게 하고 브라우저가 자동으로 그것을 전송하게 하는 방식에 익숙할 겁니다. 노드는 그런 식으로 동작하지 않습니다. 파일을 열고 내용을 읽어서 콘텐츠를 브라우저에 전송하는 작업을 직접 해야 합니다.

### 3. 익스프레스로 시간 절약
9. 이 책에서는 스캐폴딩 유틸리티를 사용하지 않지만, 책을 다 읽은 다음에는 한번 살펴보길 권합니다. 책을 다 읽고 나면 스캐폴딩 유틸리티가 생성하는 템플릿이 자신에게 유용한지 직접 판단할 수 있는 지식을 다 갖췄을 겁니다.

10. app.get 메서다가 바로 라우트를 추가하는 메서드입니다. 익스프레스 문서를 보면 app.VERB라는 표현을 볼 수 있습니다. 이는 문자 그대로 VERB라는 메서다가 있다는 뜻이 아닙니다. VERB는 (소문자인) HTTP 동사verb(대개 ‘get’과 ‘post’)의 플레이스홀더입니다. 이 메서드는 매개변수로 경로와 함수를 받습니다.

11. 경로 매개변수는 라우트를 정의합니다. App.VERB는 여러분이 해야 할 번거로운 작업을 상당히 덜어줍니다. 기본적으로 대소문자를 구분하지 않고 맨 뒤의 슬래시는 무시하며, 매칭할 때는 쿼리스트링을 무시한 채 매칭합니다. 따라서 어바웃 페이지의 라우트는 /about, /About(대소문자를 구분하지 않음), /about/(맨 뒤의 슬래시 무시), /about?foo=bar(쿼리스트링 무시), /about/?foo=bar(맨 뒤의 슬래시 무시, 쿼리스트링 무시) 등에 대해 모두 작동합니다.

12. 노드의 저수준 메서드 res.end 대신에 익스프레스의 확장 메서드 res.send를 사용했습니다. 또 노드의 res.writeHead를 res.set과 res.status로 교체했습니다. 익스프레스는 Content-Type 헤더를 설정하는 편리한 메서드 res.type을 제공합니다. 물론 res.wrtieHead와 res.end를 써도 되지만, 그럴 필요는 없습니다.

13. 커스텀 404와 500 페이지는 반드시 조금 다르게 처리해야 합니다. app.get 대신 app.use를 썼습니다. app.use는 익스프레스에서 미들웨어를 추가할 때 쓰는 메서드입니다. 미들웨어는 10장에서 더 깊이 다룰 테니, 일단 지금은 라우트와 일치하지 않는 모든 것을 처리하는 폴백(catch-all) 핸들러라고 생각하십시오. 중요한 요점은 이겁니다. 익스프레스에서는 라우트와 미들웨어를 추가하는 순서가 중요합니다. 404 핸들러를 라우트 앞에 두었다면 홈페이지와 어바웃 페이지는 동작하지 않고 404 에러가 일어났을 겁니다. 지금은 라우트 구조가 매우 단순하지만, 와일드카드를 지원하므로 순서 문제가 생길 수 있습니다.

14. 제이드는 매우 매력적이지만, 추상화 수준이 높은 만큼 지불해야 할 비용도 있습니다. 프론트엔드 개발자라면 HTML을 아주 잘 이해하고 있어야 하지만, 제이드로 뷰를 만들면 HTML을 쓰지 않게 됩니다. 필자가 알고 있는 프론트엔드 개발자 대부분은 주로 쓰는 마크업 언어가 사라진다는 사실에 불편해합니다. 따라서 추상화 수준이 좀 덜한 템플릿 프레임워크인 핸들바를 권합니다. 핸들바는 인기 있는 언어 독립적 템플릿 언어 머스태시에 기반을 두고 만들어졌습니다. 핸들바는 HTML을 없애지 않습니다. HTML에 특별한 태그를 쓰면 핸들바가 이를 인식하고 콘텐츠를 주입합니다.

15. 지금은 미들웨어에서 정규화를 해주므로 요청 처리가 더 쉽다는 것만 기억하면 충분합니다.

16. static 미들웨어는 정적 자원을 담고 있는 하나 이상의 디렉터리를 지목해서 특별한 처리 없이 클라이언트에 전송할 수 있게 해줍니다. 이 디렉터리에 이미지, CSS 파일, 클라이언트 자바스크립트 파일 등을 저장합니다.

17. 프로젝트 디렉터리 안에 public 서브디렉터리를 만듭니다. 이 디렉터리를 public이라 부르는 건 이 디렉터리 안에 들어 있는 것은 조건 없이 클라이언트에 보내기 때문입니다. 라우트를 선언하기 전에 static 미들웨어를 다음과 같이 추가합니다.
app.use(express.static(__dirname + ‘/public’));

18. static 미들웨어는 클라이언트에 전송할 각 정적 파일마다 라우트를 만들고 그 파일을 반환하는 것과 같은 효과가 있습니다.

19. 무언가를 모듈 밖에서 사용할 수 있게 하려면 exports에 추가해야 합니다. 이 예제에서는 getFortune 함수를 이 모듈 바깥에서도 쓸 수 있지만, fortuneCookies 배열은 완벽히 감춰집니다. 이것은 좋은 방식입니다. 캡슐화를 통해, 잠재적 에러나 취약한 코드를 방지할 수 있으니까요.

### 4. 모양새 갖추기
19. 나쁜 습관을 반복하면 그 나쁜 습관이 기계적이 됩니다. 완벽한 연습을 통해 완벽해지는 규칙을 따라야 합니다.

20. 무언가를 모듈 밖에서 사용할 수 있게 하려면 exports에 추가해야 합니다. 이 예제에서는 getFortune 함수를 이 모듈 바깥에서도 쓸 수 있지만, fortuneCookies 배열은 완벽히 감춰집니다. 이것은 좋은 방식입니다. 캡슐화를 통해, 잠재적 에러나 취약한 코드를 방지할 수 있으니까요.

### 5. 품질보증
21. QA(Quality Assuarance)  
범위(SEO), 기능(Func), 사용성(UX), 미학(UI)

22. 논리 영역은 가능한 한 명확하고 단순해야 하지만, 표현 영역은 필요에 따라 복잡할 수도, 단순할 수도 있습니다. 또 표현은 사용성과 미학을 고려해야 하지만, 논리는 그렇지 않습니다.

23. QA 테크닉 개관  
이 책에서는 다음과 같은 테크닉과 소프트웨어를 사용합니다.
- 페이지 테스트 : Mocha
- 교차 페이지 테스트 : Zombi.js
- 논리 테스트 : Javascript
- 린트 : JSHint
- 링크 체크 : LinkChecker

24. 자바스크립트를 변경한 후 웹사이트를 재시작하는 걸 자주 잊어버린다면, 자바스크립트 변경을 감지하고 자동으로 서버를 재시작하는 모니터 유틸리티를 추천합니다. 노드몬(nodemon)이 매우 널리 쓰이고, 그런트 플러그인도 있습니다.

25. –save가 아니라 –save-dev를 썼습니다. 이 옵션은 npm에 이 패키지를 실무 환경이 아니라 개발할 때만 사용한다고 알리는 옵션입니다. 이 옵션을 쓰면 웹사이트를 실제로 사용할 때 필요한 패키지가 줄어듭니다.

26. 요점은 테스트 코드가 항상 존재해선 안 된다는 겁니다. 웹사이트를 느리게 할 뿐 아니라, 사용자는 테스트 결과에 관심이 없습니다. 테스트는 기본적으로 비활성 상태이지만 다시 켜기도 쉬워야 합니다. URL 매개변수를 써서 테스트를 끄고 켜도록 합시다. http://localhost:3000으로 이동하면 평상시 홈페이지를, http://localhost:3000?test=1로 이동하면 테스트 기능이 켜진 홈페이지를 불러오게 될 겁니다.

27. JSHint는 ===가 아니라 ==를 썼다고 지적할 겁니다. 추가로, 중괄호가 없다는 것도 지적할 겁니다.

### 6. 요청과 응답 객체
28. 포트를 생략하면 HTTP는 80, HTTPS는 443이라고 가정합니다. 일반적으로 80이나 443 포트를 쓰지 않는다면 1023보다 큰 포트 번호를 써야 합니다. 보통 3000이나 8080, 8088 같은 기억하기 쉬운 포트 번호를 씁니다.

29. 해시  
해시(hash)는 프래그먼트(fragment)라고도 부르며, 서버에는 전혀 전달되지 않습니다. 해시는 오직 브라우저에서만 사용합니다. 단일 페이지 애플리케이션이나 AJAX를 많이 쓰는 애플리케이션들이 해시를 이용해 애플리케이션을 컨트롤하는 사례가 점점 더 늘어나고 있습니다.

30. HTTP 요청 규칙  
브라우저에 URL을 입력하거나 링크를 클릭하면 브라우저는 서버에 HTTP GET 요청을 보냅니다. 서버로 보내지는 중요한 정보는 URL 경로와 쿼리스트링입니다. 앱은 규칙, 경로, 쿼리스트링에 따라 어떻게 응답할지 결정합니다.

31. 웹사이트의 대부분 페이지는 GET 요청에 응답합니다. POST 요청은 보통 서버에 정보를 보낼 때 사용합니다. 서버는 요청에 포함된 정보를 처리한 후 응답을 보내는데, 정보가 POST 요청으로 들어왔든 GET 요청으로 들어왔든 응답 HTML은 대개 같습니다. 브라우저는 서버와 통신할 때 AJAX 또는 GET과 POST만 사용합니다.

32. 반면 웹 서비스는 HTTP 규칙을 좀 더 창의적으로 쓸 때가 많습니다. 예를 들어 API 호출을 통해 뭔가를 지울 때 유용한 DELETE라는 HTTP 규칙이 있습니다.

33. 브라우저는 URL 경로보다 Content-Type 헤더를 더 우선시합니다.

34. 단지 경로는 추상적이며 브라우저는 Content-Type을 이용해 콘텐츠를 어떻게 렌더링할지 결정한다는 것을 이해해야 한다는 뜻입니다. 헤더에는 응답이 압축됐는지 아닌지, 어떤 인코딩을 사용하는지 같은 정보도 들어 있습니다. 브라우저에서 자원을 얼마나 오래 캐시하고 있을지 결정하는데 필요한 힌트도 들어 있습니다.

35. 요청 본문  
요청에는 헤더 외에도 본문(body)이 있습니다. 일반적으로 GET 요청에는 본문이 없지만, POST 요청에는 보통 본문이 있습니다. POST 본문에 가장 널리 쓰이는 미디어 타입은 application/x-www-form-urlencoded이며, 단순히 앰퍼샌드로 구분한 이름/값 쌍(기본적으로 쿼리스트링과 같은 형식)을 인코드한 것입니다.

36. AJAX 요청에서는 본문에 application/json을 쓸 수 있습니다.

37. 콘텐츠 렌더링  
콘텐츠를 렌더링할 때는 레이아웃 안에서 뷰를 렌더링하는 res.render를 가장 자주 사용할 겁니다. 가끔 테스트 페이지를 빨리 만들어보고자 할 때는 res.send를 쓸 수도 있습니다. 쿼리스트링 값이 필요할 때는 req.query, 세션 값이 필요할 때는 req.session, 쿠키가 필요할 때는 req.cookie/req.signedCookies를 씁니다.

### 7. 핸들바를 사용한 템플릿
38. 자바스크립트로 HTML을 생성하면 다음과 같이 문제가 아주 많습니다.  
어떤 문자를 이스케이프해야 하는지, 어떻게 이스케이프해야 하는지 끊임없이 신경을 써야 합니다.
- 자바스크립트로 생성한 HTML에 자바스크립트가 포함돼 있으면 순식간에 문제가 커집니다.
- 에디터에서 제공하는 문법 강조나 언어별로 제공하는 편리한 기능들이 무색해집니다.
- 잘못된 HTML을 찾기가 훨씬 어렵습니다.
- 한 번 보고는 무슨 뜻인지 알기 어렵습니다.
- 다른 사람들이 당신의 코드를 이해하기 어렵습니다.
템플릿을 쓰면 해당 언어를 쓰는 것과 비슷하면서도 동적 데이터를 삽입할 수 있어서 이런 문제가 해결됩니다.

39. 정말 단순한 걸 빼면 자바스크립트로 HTML을 생성하는 일은 피하십시오.

40. 핸들바는 다른 인기 있는 템플릿 엔진인 머스태시의 확장입니다. 필자가 핸들바를 권하는 이유는, 서버에서든 프론트엔드에서든 자바스크립트와 통합하기 쉬우며 문법도 친숙하기 때문입니다.

41. 서버 쪽 템플릿은 HTML을 클라이언트로 보내기 전에 렌더링합니다. 클라이언트 쪽 템플릿을 쓰면 HTML 소스를 볼 줄 아는 사용자는 템플릿까지 볼 수 있지만, 서버 쪽 템플릿을 쓰면 사용자는 최종 HTML을 생성하는 데 쓰인 템플릿이나 콘텍스트 객체에 대해 전혀 알 수 없습니다.

42. 템플릿은 또한 브라우저 호환성 문제를 막고 유효한 HTML을 지키는 1차 방어선입니다. 템플릿은 프론트엔드 개발에 정통한 사람이 애정을 가지고 관리해야 합니다. 출발점으로 삼기 좋은 곳은 (특히 템플릿에 대해 잘 모른다면) HTML5 보일러플레이트입니다. 이 책에서는 최소한의 HTML5 템플릿을 썼지만, 실제 프로젝트에서는 HTML5 보일러플레이트를 쓸 겁니다.

### 8. 폼 처리
43. 사용자에게서 정보를 받을 때는 보통 HTML 폼을 사용합니다. 브라우저에서 일반적 방법으로 폼을 전송하든, AJAX를 사용하든, 멋진 프론트엔드 컨트롤을 사용하든 간에, 근본적인 메커니즘은 대부분 HTML 폼입니다.

44. 클라이언트 데이터를 서버로 보내기  
클라이언트 데이터를 서버로 보내는 방법은 크게 말해 쿼리스트링과 요청 본문입니다. 일반적으로 쿼리스트링을 쓸 때는 GET 요청을, 요청 본문을 쓸 때는 POST 요청을 사용합니다.(HTTP 프로토콜에 어떤 제한이 있는 건 아니므로 두 요청을 반대로 해도 안 될 건 없지만, 그렇게 할 이유는 전혀 없습니다. 표준 관행을 따르는 편이 가장 좋습니다.)

45. POST는 안전하고 GET은 그렇지 않다고 오해하는 사람이 많은데 그렇지 않습니다. HTTPS를 쓰면 둘 다 안전하고, 쓰지 않으면 어느 쪽도 안전하지 않습니다.

46. GET 요청을 쓰면 숨긴 필드를 포함해 사용자가 입력한 내용이 모두 쿼리스트링에 나타나는데, 보기도 좋지 않고 문제도 많습니다. 또한 브라우저는 대개 쿼리스트링 길이에 제한을 두지만, POST 요청 본문에는 길이 제한이 없습니다. 따라서 필자는 일반적으로 폼 전송에 POST를 권합니다.

47. 이 예제에서는 <form> 태그에 명시적으로 POST를 지정했는데, 지정하지 않았을 때 기본값은 GET입니다. Action 속성은 폼의 정보를 받을 URL입니다. 이 필드를 생략하면 폼이 있는 URL, 즉 자기 자신으로 전송됩니다. 설령 AJAX를 쓰더라도 항상 action 속성에 유효한 값을 지정하길 바랍니다. 데이터 손실의 위험을 피하기 위해서입니다.

48. 익스프레스는 두 가지 간편 프로퍼티 req.xhr과 req.accepts를 제공합니다. Req.톡은 요청이 AJAX 요청이면 true입니다(XHR은 AJAX에서 의존하는 XML HTTP Request의 약자입니다). req.accepts는 반환하기 가장 적절한 응답 타입을 결정합니다.

49. 파일 업로드에는 버스보이(Busboy)와 포미더블(Formidable)이 널리 쓰입니다. 필자는 포미더블이 조금 더 쉽다고 생각합니다. 포미더블은 필드와 파일이 들어 있는 객체가 콜백으로 제공되어 편리하지만, 버스보이는 각 필드와 이벤트에 모두 리스너를 붙여야 하기 때문입니다.

### 9. 쿠키와 세션
50. 쿠키의 아이디어는 단순합니다. 서버는 정보를 조금 보내고 브라우저는 일정 시간 그 정보를 저장하는데, 그 시간은 설정할 수 있습니다. 어떤 정보를 보낼지는 온전히 서버의 몫입니다. 보통은 고유한 ID 숫자 하나만 보내고 이 숫자로 특정 브라우저를 식별해 ‘상태’를 관리합니다.

51. 잠시 뒤에 서명된 쿠키에 대해 설명할 텐데, 이런 쿠키는 콘텐츠를 조금 가리긴 하지만 해커로부터 안전할 정도로 암호화하는 건 아닙니다.

52. 사용자의 컴퓨터에 쿠키를 너무 많이 저장하거나 데이터를 너무 많이 저장하면 사용자를 거슬리게 합니다. 이런 일은 피해야 합니다. 쿠키는 최소한으로 유지하십시오.

53. 세션을 쿠키보다 우선시하십시오  
대부분 세션을 써서 상태를 관리할 수 있으며 일반적으로 세션을 쓰는 편이 더 낫습니다. 세션은 더 쉽고 사용자 스토리지를 남용할 걱정도 없으며, 보안도 더 낫습니다. 물론 세션도 쿠키에 의존하지만, 세션을 쓰면 익스프레스가 어려운 작업을 많이 덜어줍니다.

54. 세션을 써야 할 곳  
세션은 여러 페이지에 적용되는 사용자 선호 설정을 저장할 때 유용합니다. 가장 흔한 사용처는 사용자 인증 정보입니다. 로그인하면, 세션이 만들어집니다. 세션이 만들어지면 페이지를 새로고침할 때마다 다시 로그인하지 않아도 됩니다. 물론 세션은 사용자 계정이 없어도 유용합니다. 웹사이트에서 로그인하지 않아도 어떤 날짜 형식을 좋아하는지, 데이터는 어떻게 정렬하는지 기억하는 건 매우 흔한 사례입니다.

55. 필자는 쿠키보다 세션을 권장하지만, 쿠키가 어떻게 동작하는지 이해하는 건 중요합니다. 쿠키가 있어야 세션이 가능하니까요. 쿠키에 대해 이해하면 애플리케이션의 문제를 분석하고 보안과 개인 정보에 관한 고려 사항을 이해하는 데 도움이 됩니다.

### 10. 미들웨어
56. 개념적으로 말하면 미들웨어는 기능, 특히 애플리케이션에 대한 HTTP 요청에서 동작하는 기능을 캡슐화하는 방법입니다. 현실적으로 말하면 미들웨어는 단순히 매개변수 세 가지를 받는 함수입니다. 세 가지 매개변수란 요청 객체와 응답 객체, 그리고 곧 설명할 ’next’ 함수입니다.

57. 파이프라인 맨 마지막 미들웨어에는 다른 어떤 라우트와도 일치하지 않는 요청을 처리하는 폴백 핸들러를 두는 게 일반적입니다. 이 미들웨어는 보통 상태 코드 404(찾을 수 없음)을 반환합니다.

58. 파이프라인에서 요청은 어떻게 ‘종료’될까요? 각 미들웨어에 전달된 next 함수가 하는 일이 요청 전달입니다. next()를 호출하지 않으면 해당 요청은 그 미들웨어에서 종료됩니다.

59. 미들웨어와 라우트 핸들러에 대해 유연하게 생각할 수 있어야 익스프레스가 어떻게 동작하는지 이해하기 쉬워집니다.

60. 익스프레스에 포함된 미들웨어는 static 하나뿐입니다. 익스프레스에서 미들웨어를 분리하면서 익스프레스는 수많은 의존성을 관리해야 하는 부담을 덜었고, 분리된 미들웨어 프로젝트들은 익스프레스와 독립적으로 발전할 수 있게 되었습니다.

### 11. 이메일 보내기
61. SMTP, MSA, MTA  
가장 기본적인 이메일 전송은 단순 메일 전송 프로토콜(Simple Mail Transfer Protocol, SMTP)입니다. SMTP를 통해 이메일을 직접 수신자의 메일 서버로 보낼 수 있긴 하지만, 일반적으로는 좋은 생각이 아닙니다. 구글이나 야후!같은 ‘신뢰할 수 있는 발신자’가 아니면 이메일이 스팸함으로 직행할 수 있으니까요. 메일 발송 에이전트(Mail Submission Agent, MSA)를 사용하면 신뢰할 수 있는 채널을 통해 메일을 배달흐므로 스팸으로 분류될 확률이 줄어듭니다. MSA는 일시적인 정지나 반송 이메일도 처리합니다. 마지막은 이메일을 마지막 목적지로 실제 전송하는 서비스인 메일 전송 에이전트(Mail Transfer Agent, MTA)입니다. 이 책에서 MSA, MTA, ‘SMTP 서버’는 사실 동등합니다.

62. 이메일 메시지는 HTTP 요청과 마찬 가지로 헤더와 본문 두 부분으로 구성됩니다. 헤더에는 누가 보냈는지, 누구에게 보냈는지, 언제 받았는지, 주제가 무엇인지 등 이메일에 관한 정보가 들어 있습니다. 일반적으로 이메일 애플리케이션은 이러한 정보를 사용자에게 보여주지만, 헤더에는 훨씬 더 많은 정보가 들어 있습니다. 대부분의 이메일 클라이언트는 사용자가 헤더를 볼 수 있게 허용합니다. 아직 본 적이 없다면 한번 보길 권합니다. 헤더에는 이메일이 어떻게 전달됐는지에 관한 정보가 전부 들어 있습니다. 즉 이메일이 배달되면서 거쳐온 서버와 MTA는 모두 헤더에 표시됩니다.

63. 대부분의 메일 클라이언트는 HTML의 극히 일부만 지원합니다. 이메일에 HTML을 쓸 때는 마치 1996년을 사는 듯한 기분으로 만들어야 합니다. 재미있는 일은 아니죠. 심지어 테이블 레이아웃을 써야 합니다.

### 12. 실무 관심사
64. 노드 웹사이트를 개발할 때는 항상 수평적 확장 가능성을 고려해야 합니다. 설령 애플리케이션이 항상 매우 제한된 사용자만 사용하는 인트라넷 애플리케이션처럼 아주 작고, 확장해야 할 필요를 전혀 느낄 수 없다 하더라도 항상 대비해두는 게 좋은 습관입니다.

65. 이후 확장될 웹사이트를 만들 때 기억해야 할 가장 중요한 것은 지속성입니다. 파일 기반 스토리지에 의존해 지속성을 설계해왔다면, 당장 멈추십시오.

66. 노드의 비동기적 세게에서는 잡히지 않은(uncaught) 예외에 특히 관심을 기울여야 합니다.

67. 항상 커스텀 에러 페이지를 제공하는 게 좋습니다. 그렇게 해야 에러가 일어났을 때 사용자에게 더 전문가처럼 보일 뿐 아니라, 에러에 대처할 수도 있습니다.

68. 잡히지 않는 예외를 처리할 방법이 아주 없는 건 아니지만, 노드가 애플리케이션의 안정성을 판단할 수 없다면 당신도 할 수 없습니다. 달리 말하자면, 잡히지 않는 예외가 일어났을 대 유일한 방법은 서버 셧다운뿐입니다. 이 상황에서 할 수 있는 가장 좋은 방법은 가능한 한 우아하게 서버를 다운시키고 장애 복구(failover) 메커니즘을 마련하는 것입니다. 가장 쉬운 장애 복구 메커니즘은 앞 섹션에서 설명한 앱 클러스터입니다. 애플리케이션이 클러스터 모드로 동작한다면 워커가 다운되더라도 마스터에서 새 워커를 만들어 대체할 겁니다. 워커가 여럿 있을 필요도 없습니다. 워커가 실행되는 클러스터 하나면 충분합니다. 장애 복구가 조금 느려질 수는 있지만요.

69. 그러면 장애 복구를 염두에 두고, 잡히지 않는 예외에 직면했을 때 가능한 한 우아하게 서버를 다운시키는 방법은 무엇일까요? 노드에는 uncaughtException 이벤트와 도메인 두 가지 메커니즘이 있습니다.

70. 도메인이 더 최근에 만들어졌고 권장하는 방법입니다. uncaughtException는 나중에 노드에서 제거될 수 있습니다. 도메인은 기본적으로 자신 안에서 일어나는 에러를 받는catch 실행 콘텍스트입니다. 도메인을 사용하면 에러를 더 유연하게 처리할 수 있습니다.

71. 고객과 사장에게 당신이 훌륭한 전문가라고 어필할 방법이 한 가지 있다면, 그건 항상 그들보다 먼저 재난에 대해 파악하는 겁니다.

72. 스트레스 테스트(부하 테스트)는 요청이 동시에 수백, 수천씩 들어오더라도 서버가 제대로 동작할 수 있는지 테스트합니다.

### 13. 지속성
73. 정말 단순한 형태가 아닌 한, 웹사이트나 웹 애플리케이션에는 일종의 지속성(persistence)이 필요합니다. 지속성이란, 데이터를 불안정한 메모리보다 더 영구적인 곳에 저장해서 서버가 충돌하거나, 전기가 나가거나, 업그레이드되거나, 이전한다 해도 데이터가 유지되도록 하는 겁니다. 이 장에서는 지속성을 유지할 수 있는 옵션을 몇 가지 설명하며, 문서 데이터베이스에 중점을 둡니다.

74. 일반적으로 사용자가 올린 것은 아무것도 믿어선 안 됩니다. 사용자를 믿으면 웹사이트 공격에 문을 열어주게 됩니다. 예를 들어 악의적인 사용자가 해로운 실행 파일을 만드렁 확장자만 .jpg로 바꿔 올릴 수도 있습니다. 나중에 어떻게든 그 파일을 실행할 기회가 생기길 기대하면서 말입니다. 마찬가지로 브라우저가 제공한 name 프로퍼티를 그대로 써서 파일 이름을 정하는 것도 조금 위험합니다. 파일 이름에 특수문자를 써서 악용할 수 있으니까요. 우리는 파일 이름은 무작위로 정하고, 확장자만(영문과 숫자로만 구성된 걸 확인하고) 그대로 써서 이 코드를 완벽히 안전하게 만들겠습니다.

75. 전통적으로 관계형 데이터베이스의 높은 성능은 단단한 자료구조와 수십 년 동안의 최적화 ㅇ녀구에서 비롯됩니다. 반면 NoSQL 데이터베이스는 인터넷의 본질인 분산성을 받아들였고, 노드와 마찬가지로 동시 실행을 통해 성능을 끌어올리는 데 집중했습니다. (관계형 데이터베이스도 동시 실행을 지원하지만, 이 기능은 정말 무거운 애플리케이션을 위해 보통은 남겨집니다).

76. 몽구스  
몽고DB에서 쓸 수 있는 저수준 드라이버가 존재하긴 하지만, 객체 문서 매퍼(object document mapper, ODM)를 쓰는 게 더 편할 겁니다. 몽고DB에서 공식적으로 지원하는 ODM은 몽구스(Mongoose)입니다.

### 14. 라우팅
77. 그리고 아직 눈치채지 못했다면 말이지만, URL에 ‘HTML’을 쓰는 일 자체가 상당히 구습입니다.

78. 익스프레스 라우팅의 기술적인 측면을 설명하기 전에, 먼저 정보 구조(information architecture, IA)라는 개념에 대해 이해해야 합니다. IA는 콘텐츠의 개념적 구성을 말합니다. 라우팅에 관해 생각하기 전에 먼저 확장성 있는(지나치게 복잡하지는 않은) IA를 계획하면 이후 과정에 크나큰 도움이 됩니다.

79. 2년이 지나도, 20년이 흘러도, 200년 뒤에도 여전히 쓸 수 있는 URI를 만드는 게 웹마스터의 책임이다. 이렇게 하려면 숙고하고, 조직하고, 헌신해야 한다. – 팀 버너스리

80. 오래 지속될 IA를 만드는 데 도움이 될 만한 몇 가지 제안입니다.  
- 기술적인 세부 사항을 절대 URL에 노출하지 마십시오.
- URL에 무의미한 정보를 두지 마십시오.
- 필요 없이 긴 URL은 피하십시오.
- 단어 구분자는 통일하십시오.
- 공백 문자나 타이핑할 수 없는 문자는 절대 쓰지 마십시오.
- URL에는 소문자만 쓰십시오.

81. 라우트와 SEO  
웹사이트가 검색엔진에 걸리게 하려면(틀림없이 그렇겠죠) SEO에 대해 생각해야 하고, URL이 SEO에 미치는 영향도 생각해야 합니다. 특히 매우 중요한 키워드가 있고 상식적이기도 하다면, 그 키워드를 URL에 넣는 것도 좋습니다.

82. 라우트를 어떻게 정리할지 결정하는 데 지침이 되는 원칙 네 가지를 권고하겠습니다.
- 라우트 핸들러에 이름 붙은 함수를 쓰십시오.
- 라우트가 불가사의해서는 안 됩니다.
- 라우트 정리 규칙을 확장할 수 있어야 합니다.
- 뷰 기반 자동 라우트 핸들러를 무시하지 마십시오.

83. 라우트 정리에 가장 널리 쓰이는 두 가지 방법은 네임스페이스 라우팅과 자원 라우팅입니다. 네임스페이스 라우팅은 여러 라우트가 같은 접두사(/vacations 등)로 시작할 때 잘 어울립니다. 노드 모듈 express-namespace를 사용하면 이 정리법을 쉽게 적용할 수 있습니다. 자원 라우팅은 객체의 메서드에 따라 자동으로 라우트를 추가합니다. 이 정리법은 사이트 로직이 애초에 객체 지향적일 때 잘 어울립니다. Express-resource 패키지가 이 스타일을 구현한 패키지입니다.
