# You don't knwo JS(this와 객체 프로토타입, 비동기와 성능)
### 지은이 : 카일 심슨
### 옮긴이 : 이일웅
### 출판사 : 한빛미디어
### 읽은 날 : 2020.03.20 ~

# Part1. this와 객체 프로토타입
### 1. this라나 뭐라나
### 2. this가 이런 거로군!
### 3. 객체
### 4. 클래스와 객체의 혼합
### 5. 프로토타입
### 6. 작동 위임
# Part2. 비동기와 성능
### 1. 비동기성: 지금과 나중
### 2. 콜백
### 3. 프라미스
### 4. 제너레이터
### 5. 프로그램 성능
### 6. 벤치마킹과 튜닝
### Appendix A. ES6 class
### Appendix B. asynquence 라이브러리
### Appendix C. 고급 비동기 패턴

# Part1. this와 객체 프로토타입
### 1. this라나 뭐라나
1. 렉시컬 스코프를 사용하지 말라는 게 아니다. 렉시컬 스코프 그 자체는 훌륭하고 유용한 시스템이다. 그러나 this에 대해 어렴풋이 짐작만 하다가 뭐가 좀 안 된다 싶으면 그냥 렉시컬 스코프를 다시 찾는 식으로는 발전이 없다.
ㅤ
2. this는 작성 식점이 아닌 런타임 시점에 바인딩 되며 함수 호출 당시 상황에 따라 콘텍스트가 결정된다고 말했다. 함수 선언 위치와 상관없이 this 바인딩은 오로지 어떻게 함수를 호출했느냐에 따라 정해진다.
ㅤ
3. 어떤 함수를 호출하면 활성화 레코드(Activation Record), 즉 실행 콘텍스트(Execution Context)가 만들어진다. 여기엔 함수가 호출된 근원(콜스택, Call-Stack)과 호출 방법, 전달된 인자 등의 정보가 담겨있다. this 레퍼런스는 그중 하나로, 함수가 실행되는 동안 이용할 수 있다.
ㅤ
### 2. this가 이런 거로군!
4. 두 메서드는 this에 바인딩 할 객체를 첫째 인자로 받아 함수 호출 시 이 객체를 this로 세팅한다. this를 지정한 객체로 직접 바인딩 하므로 이를 ‘명시적 바인딩(Explicit Binding)’이라 한다.
ㅤ
5. Function.prototype.call()의 두 번째 이후 인자들은 호출된 함수에 차례로 전달되며 Function.prototype.apply()는 단지 이 인자를 배열 형태로 전달합니다.
Ex)
foo.call( obj, ‘인자1’, ‘인자2’, … );
foo.apply( obj, [‘인자1’, ‘인자2’, …]);
ㅤ
6. 함수 앞에 new를 붙여 생성자 호출을 하면 다음과 같은 일들이 저절로 일어난다.
1) 새 객체가 툭 만들어진다.
2) 새로 생성된 객체의 [[Prototype]]이 연결된다.
3) 새로 생성된 객체는 해당 함수 호출 시 this로 바인딩 된다.
4) 이 함수가 자신의 또 다른 객체를 반환하지 않는 한 new와 함께 호출된 함수는 자동으로 새로 생성된 객체를 반환한다.
ㅤ
7. 명시적 바인딩이 암시적 바인딩보다 우선순위가 높음을 알 수 있다. 따라서 암시적 바인딩을 확인하기 전에 먼저 명시적 바인딩이 적용됐는지 반드시 살펴야 한다.
ㅤ
8. this 확정 규칙  
이제 함수 호출부에서 this가 결정되는 규칙을 우선순위에 따라 차례대로 정리해보자. 다음 항목을 순서대로 따져보고 그중 맞아떨어지는 최초 규칙을 적용한다.
1) new로 함수를 호출(new 바인딩)했는가? -> 맞으면 새로 생성된 객체가 this다.
2) call과 apply로 함수를 호출(명시적 바인딩), 이를테면 bind 하드 바인딩 내부에 숨겨진 형태로 호출됐는가? -> 맞으면 명시적으로 지정된 객체가 this다.
3) 함수를 콘텍스트(암시적 바인딩), 즉 객체를 소유 또는 포함하는 형태로 호출했는가? -> 맞으면 바로 이 콘텍스트 객체가 this다.
4) 그 외의 경우에 this는 기본값(엄격 모드는 undefined, 비엄격 모드는 전역 객체)으로 세팅된다(기본 바인딩).
이 네 가지가 대부분 함수 호출 시 this가 바인딩 되는 규칙의 전부다. 음 … 거의 전부다.
ㅤ
9. call, apply, bind 메서드에 첫 번째 인자로 null 또는 undefined를 넘기면 this 바인딩이 무시되고 기본 바인딩 규칙이 적용된다.
ㅤ
10. 변수명이야 어떻든 빈 객체를 만드는 가장 간단한 방법은 Object.create(null)이다. Object.create(null)은 {}와 비슷하나 Object.prototype으로 위임하지 않으므로 {}보다 ‘더 텅 빈(More Empty)’ 객체라고 볼 수 있다.
ㅤ
11. 화살표 함수의 어휘적 바인딩은 절대로 (심지어 new로도!) 오버라이드할 수 없다.
ㅤ
12. 어쨌거나 this 스타일의 코드를 작성해야 할 경우 어휘적 self = this 든, 화살표 함수 꼼수든 꼭 다음 두 가지 중 하나만 선택하자.
1) 오직 렉시컬 스코프만 사용하고 가식적인 this 스타일의 코드는 접어둔다.
2) 필요하면 bind()까지 포함하여 완전한 this 스타일의 코드를 구사하되 self = this나 화살표 함수 같은 소위 ‘어휘적 this’ 꼼수는 삼가야 한다.
3) 두 스타일 모두 적절히 혼용하여 효율적인 프로그래밍을 할 수도 있겠지만 동일 함수 내에서 똑 같은 것을 찾는데 서로 다른 스타일이 섞여 있으면 관리도 잘 안 되고 개발자가 천재가 아닌 이상 이해하기 곤란한 골칫덩이 코드로 남게 될 것이다.
ㅤ
### 3. 객체
13. 객체 프로퍼티명은 언제나 문자열이다. 문자열 이외의 다른 원시 값을 쓰면 우선 문자열로 변환된다. 배열 인덱스로 사용하는 숫자도 마찬가지이므로 공연히 객체와 배열 사이에 숫자를 써서 헷갈리는 코드를 만들지 않도록 하자.
ㅤ
14. Object.freeze()를 적용하면 지금까지는 전혀 영향을 받지 않았던 해당 객체가 참조하는 모든 객체를 재귀 순회하면서 Object.freeze()를 적용하여 깊숙히 동결(Deep Freeze)한다. 하지만 자칫 의도하지 않은 다른 공유된 객체까지 동결시킬 수 있어 주의해야 한다.
ㅤ
### 4. 클래스와 객체의 혼합
15. 자바스크립트 클래스  
꽤 오래전부터 클래스와 비슷하게 생긴 (new나 instanceof 등의) 구문 요소도 갖추고 있고 최근 ES6부터는 아예 class라는 키워드가 명세에 정식으로 추가됐다. 그럼 정말 자바스크립트는 클래스가 있는 것일까? 단도직입적으로 말해서 ‘아니다’.
ㅤ
16. 클래스는 디자인 패턴이므로 적잖이 공을 들이면 고전적인 클래스 기능과 얼추 비슷하게 구현할 수 있는 건 사실이다. 그간 자바스크립트는 적어도 외관상으로는 클래스처럼 생긴 구문을 제공하여 클래스 디자인 패턴을 실현하려는 욕구를 충족시키고자 많은 변신을 거듭해왔다.
ㅤ
17. 자식 클래스가 마치 부모 클래스에 연결된 양 다형성을 혼동하지 않길 바란다. 자식은 그저 부모에게서 자신이 필요한 내용을 베껴왔을 뿐이니… 클래스 상속은 한 마디로 ‘복사’다.
ㅤ
18. 일반적으로 자바스크립트에서 클래스를 모방하는 건(믹스인 패턴) 당장 닥친 문제를 해결할 순 있어도 앞으로 터질 시한폭탄을 심어놓는 것과 다름없다.
ㅤ
### 5. 프로토타입
19. [[Prototype]] 연쇄가 끝나는 지점은 정확히 어디일까? 일반 [[Prototype]] 연쇄는 결국 내장 프로토타입 Object.prototype에서 끝난다. 모든 자바스크립트 객체(호스트에 의해 확장되지 않은 내장 객체)는 Object.prototype 객체(최상위 [[Prototype]] 연쇄는 Object.prototype이다)의 ‘자손’이므로 Object.prototype에는 자바스크립트에서 두루 쓰이는 다수의 공용 유틸리티가 포함되어 있다.
ㅤ
20. 
1) [[Prototype]] 연쇄의 상위 수준에서 foo라는 이름의 일반 데이터 접근 프로퍼티가 존재하는데, 읽기 전용이 아닐 경우(writable:false), myObject의 직속 프로퍼티 foo가 새로 추가되어 결국 ’가려짐 프로퍼티(Shadowed Property)’가 된다.
2) [[Prototype]] 연쇄의 상위 수준에서 발견한 foo가 읽기 전용(writable:false)이면 이 프로퍼티를 세팅하거나 myObject 객체에 가려짐 프로퍼티를 생성하는 따위의 일은 일어나지 않는다. 엄격 모드에선 에러가 나며 비엄격 모드에선 프로퍼티 세팅은 조용히 무시된다. 어쨌든 가려짐은 발생하지 않는다.
3) [[Prototype]] 연쇄의 상위 단계에서 발견된 foo가 세터일 경우 항상 이 세터가 호출된다. myObject에 가려짐 프로퍼티 foo를 추가하지 않으며 foo 세터를 재정의하는 일 또한 없다.
ㅤ
21. [[Prototype]] 연쇄의 상위 수준에 이미 존재하는 프로퍼티에 값을 할당하려면([[Put]]) 반드시 가려짐이 발생할 것 같지만 보다시피 1)번 경우에만 해당하는 얘기다.
2), 3)번에서 foo를 가리려면 = 할당 연산자를 쓰면 안 되고 Object.defineProperty() 메서드를 사용하여 myObject에 foo를 추가해야 한다.
ㅤ
22. 상속은 기본으로 복사를 수반하지만, 자바스크립트는 객체 프로퍼티를 복사하지 않는다(원래 처음부터 그랬다). 대신 두 객체에 링크를 걸어두고 한쪽이 다른 쪽의 프로퍼티/함수에 접근할 수 있게 위임한다. 위임(Delegation)이야말로 자바스크립트 객체-연결 체계를 훨씬 더 정확하게 나타낸 용어다.
ㅤ
23. 자바스크립트는 앞에 new를 붙여 호출한 함수를 모두 ‘생성자’라 할 수 있다. 함수는 결코 생성자가 아니지만 new를 사용하여 호출할 때에만 ‘생성자 호출’이다.
ㅤ
24. Bar.prototype = Object.create( Foo.prototype ) 부분이 중요하다. Object.create()를 실행하면 난데없이 ‘새로운’ 객체를 만들고 내부 [[Prototype]]을 지정한 객체(Foo.prototype)에 링크한다. 다른 말로, “Foo 점 프로토타입과 연결된 새로운 Bar 점 프로토타입 객체를 생성하라”는 뜻이다.
ㅤ
25. 기묘한 이름의 .__proto__ 프로퍼티(ES5까지는 비표준이다!)로 객체 내부의 [[Prototype]]을 ‘마술처럼’ 엿볼 수 있다. 프로토타입 연쇄를 직접 확인하고 싶을 때 (.__proto__.__proto__ 식으로 체이닝도 가능) 매우 유용하다.
ㅤ
26. 객체에 존재하지 않는 프로퍼티를 접근하려고 시도하면 [[Get]]은 해당 객체의 내부 [[Prototype]] 링크를 따라 다음 수색 장소를 결정한다. 프로퍼티를 찾아 이 객체에서 저 객체로 줄줄이 삼만리 순회를 하기 위한 연결 경로는 (중첩된 스코프 연쇄와 비슷한) ‘프로토타입 연쇄’에 잘 정의되어 있다.
ㅤ
27. 모든 일반 객체의 최상위 프로토타입 연쇄(스코프 식으로 말하면 전역 스코프)에는 내장 Object.prototype이 버티고 있다. 겨국, 이 지점까지 이르러서도 발견되지 않으면 프로퍼티 수색 작전은 그대로 종료된다. toString(), valueOf() 등의 공용 유틸리티들은 바로 Object.prototype에 구현된 덕분에 자바스크립트의 모든 객체가 언제든지 이용할 수 있다.
ㅤ
### 6. 작동 위임
