# 모던 자바스크립트 입문
### 지은이 : 이소 히로시
### 출판사 : 길벗
### 읽은 날 : 2020.02.05 ~

### Chapter.1 ~ Chapter.7

1. 반면에 프로그램을 한 줄마다 기계어로 번역해서 실행하는 프로그래밍 언어를 인터프리터 언어라고 하며, 프로그램을 번역해서 실행시키는 소프트웨어를 인터프리터라고 합니다. 자바스크립트는 인터프리터 언어입니다.

2. 프로그램에 직접 작성할 수 있는 상수 값은 리터럴이라고 합니다.

3. 이스케이프 시퀀스

4. const 문으로 선언한 상수 값은 수정할 수 없지만, 상수 값이 객체이거나 배열일 경우에는 프로퍼티 또는 프로퍼티 값을 수정할 수 있습니다.

5. 실제로 msgObj는 실행하는 순간에 일시적으로 생성되는 String 객체이므로 사용자에게는 보이지 않습니다. 처리가 끝나면 곧바로 메모리에서 삭제됩니다. 이러한 객체를 가리켜 래퍼 객체(wrapper object)라고 합니다. 자바스크립트에서는 원시 값을 처리할 때 원시 값을 래퍼 객체로 자동 변환합니다. 그리고 래퍼 객체의 기능을 활용해서 다양한 작업을 수행합니다. 문자열은 String 객체, 숫자는 Number 객체, 논리값은 Boolean 객체로 변환됩니다. 단, null과 undefined에는 래퍼 객체가 없습니다.

6. 자바스크립트의 문자열은 불변(immutable)이라는 점도 기억하세요. Replace와 toUpperCase 메서드 등은 새로운 문자열을 반환하며 메서드를 호출한 문자열은 수정하지 않습니다.

7. 문자열을 읽을 때는 charAt 메서드 대신 대괄호 연산자를 사용할 수 있습니다. 그러나 배열처럼 값을 대입해서 수정할 수는 없습니다. 대입해도 무시됩니다.

8. a && b
A를 평가한 값이 false면 b의 값에 관계없이 표현식 전체 값이 false가 됩니다. 따라서 b의 값을 평가하지 않습니다. 이때 &&연산자는 false 대신에 a의 값 자체를 반환합니다. 또한 a를 평가한 값이 true면 전체 표현식 값이 b의 값으로 경정됩니다. 이때 && 연산자는 true나 false 대신에 b의 값 자체를 반환합니다. 이렇게 작성하더라도 논리값이 필요한 장소에서는 논리값으로 타입이 변환되기 때문에 논리식 자체는 정상적으로 동작합니다.
&& 연산자는 객체의 프로퍼티를 이용할 때와 객체가 null인지 아닌지를 확인하고자 할 때 유용하게 사용됩니다.

9. || 연산자는 여러 개의 값 후보 중에서 null 또는 undefined가 아닌 값을 선택하고자 할 때 유용하게 사용됩니다. 예를 들어 봅시다.
var time = time_interval || animationSetting.time || 33;
이렇게 작성하면 time_interval이 정의되어 있을 때는 time_interval 값을 사용합니다. 정의되지 않았을 때는 animationSettings 객체의 time 프로퍼티를 사용합니다. 이 프로퍼티도 정의되지 않았을 때는 정수(33)를 사용합니다.

10. 대화상자는 모달(modal) 창입니다. 대화상자가 떠 있는 중에는 부모 창의 작업이 일시적으로 정지 상태가 되어 부모 창을 조작할 수 없게 된다는 뜻입니다.

11. 에라토스테네스의 체는 소수를 구하는 알고르즘으로 고대 그리스의 수학자인 에라토스테네스가 고안했다고 알려져 있습니다. 알고리즘은 다음과 같습니다.
-정수 n을 지정하고, 2 이상 n 이하 정수의 목록을 만든다. 가장 작은 수인 2는 소수다.
-그것만 남겨 두고 2의 배수를 목록에서 모두 지운다. 남은 숫자 중 가장 작은 수인 3은 소수다.
-그것만 남겨 두고 3의 배수를 목록에서 모두 지운다.
-이처럼 아직 지우지 않은 가장 작은 수만 남기고 그 배수를 목록에서 지우는 작업을 반복하면 목록에는 소수만 남는다.

12. 라벨을 지정한 break 문은 주로 중첩된 반복문의 안쪽 반복문 안에서 전체 반복문을 빠져나올 때 사용합니다.

### Chapter 8. 함수

13. 재귀 함수는 재귀 호출이 멈출 때까지 몇 번이고 자기 자신을 호출하는 함수입니다. 호출된 각각의 재귀 함수는 메모리의 다른 영역을 사용합니다. 따라서 호출된 횟수만큼 메모리 소비량이 늘어납니다. 반복문을 재귀 함수로 바꾸어 표현할 수는 있지만 대부분은 while 문이나 for 문으로 작성하는 편이 이해하기 쉽고 메모리 공간도 적게 차지합니다. 따라서 재귀 함수는 재귀 호출로 문제를 더 간단하게 해결할 수 있을 때만 사용하는 것이 바람직합니다.

14. 자바스크립트에서는 작업을 싱글 스레드로 처리합니다. 호출 스택에 쌓인 실행 문맥(함수 또는 코드)을 위에서부터 아래로 차례차례 실행해 나갑니다. 그리고 실행 문맥 하나의 작업이 끝나면 pop을 하고 바로 아래에 있는 실행 문맥을 실행합니다. 즉, 실행 문맥 단위의 작업을 차례대로 실행하므로 실행 문맥(함수나 코드) 하나의 작업이 끝날 때까지 또 다른 실행 문맥의 작업을 실행하지 않습니다.

15. 이벤트 처리와 같은 비동기 처리도 똑 같은 방식으로 실행합니다. 실행할 준비를 마친 이벤트 처리기 함수와 비동기 처리는 실행하기에 앞서 이벤트 큐에 대기 행렬을 만듭니다. 그리고 현재 실행 중인 함수의 작업이 끝나면 대기 행렬에서 실행을 기다리는 첫 번째 실행 문맥(함수 또는 코드)부터 차례대로 호출 스택에 push해서 실행해 나갑니다.

16. 함수는 객체에 묶여 있지 않다(객체가 함수를 참조할 뿐)

17. 최상위 레벨 코드의 this는 전역 객체를 가리킵니다.
Console.log(this); //Window

18. 함수 객체의 apply와 call 메서드를 사용하면 함수를 호출할 때 this가 가리키는 객체를 바꿀 수 있습니다. 즉 그 함수가 실행되는 실행 문맥의 디스 바인딩 컴포넌트가 가리키는 객체를 명시적으로 설정할 수 있습니다.

19. 가비지 컬렉션
프로그램에서 객체를 생성하면 메모리 공간이 동적으로 확보됩니다. 사용하지 않는 객체의 메모리 영역은 가비지 컬렉터가 자동으로 해제합니다. 이 메커니즘을 가리켜 ‘가비지 컬렉션(garbage collection)’이라고 합니다. 이때 사용하지 않는 객체란 다른 객체의 프로퍼티와 변수가 참조하지 않는 객체를 말합니다.

20. 최근의 주요 웹 브라우저는 마크 앤 스윕(Mark-and-Sweep) 알고리즘을 사용합니다. 전역 객체가 참조할 수 없는 객체를 검색하고 해당하는 객체가 있다면 필요 없는 객체라고 판단하여 메모리에서 해제하는 방식입니다. 순환 참조 상태인 객체는 고립되어 있습니다. 따라서 전역 객체가 참조할 수 없으므로 메모리에서 해제합니다. 그래서 이 방식을 사용하면 순환 참조에 의한 메모리 누수가 발생하지 않습니다.

21. 자바스크립트의 모든 함수는 클로저를 정의합니다. 클로저는 자바스크립트가 가진 강력한 기능으로, 이를 활용하면 변수를 은닉하여 지속성을 보장하는 등의 다양한 기능을 구현할 수 있습니다. 자바스크립트는 스킴(Scheme)이라는 언어에서 큰 영향을 받았습니다. 클로저 또한 스킴에서 받아들인 기능입니다.

22. 클로저
클로저(closure, 함수 폐포)를 프로그래밍 언어적인 관점에서 설명하면 다음과 같은 동작을 하는 함수와 그 기능을 구현한 자료 구조의 모음이라고 할 수 있습니다.
-	자기 자신이 정의된 환경에서 함수 안에 있는 자유 변수의 식별자 결정을 실행한다.

23. 클로저 = 함수 객체 + 렉시컬 환경 컴포넌트

24. 클로저의 어원
위의 예에 등장한 중첩 함수 g는 열린 함수입니다. 그러나 유효 범위 체인으로 주변 환경의 변수 b와 a를 들여와서 실질적으로는 폐쇄 함수가 되었습니다. 이러한 ‘열려 있던 것을 닫는다’는 개념이 클로저(closure)의 어원입니다.

25. 객체의 프로퍼티를 외부에서 읽고 쓸 수 있지만 클로저 내부 상태는 외부로부터 숨겨진 상태입니다. 객체 지향 프로그래밍에서는 객체의 프로퍼티를 외부로부터 은폐하는 행위를 가리켜 캡슐화라고 합니다. 즉, ‘클로저는 캡슐화된 객체’라고 할 수 있습니다.

26. 클로저를 이해하기 위한 핵심 사항
- 외부 함수를 호출하면 그 함수의 렉시컬 환경 컴포넌트가 생성됩니다. 그리고 그 안에 중첩된 중첩 함수의 함수 객체를 생성해서 반환합니다. 그 결과 외부 함수의 렉시컬 환경 컴포넌트를 참조하는 중첩 함수가 정의한 클로저가 생성됩니다. 즉, 외부 함수는 클로저를 생성하는 팩토리 함수라고 할 수 있습니다.
- 외부 함수가 속한 렉시컬 환경 컴포넌트는 클로저 내부 상태 자체입니다. 외부 함수가 호출될 때마다 새로 생성됩니다.
- 중첩 함수의 함수 객체가 있는 한 외부 함수가 속한 렉시컬 환경 컴포넌트는 지워지지 않습니다. 외부 함수의 함수 객체가 사라져도 지워지지 않습니다.
- 클로저 내부 상태(외부 함수의 지역 변수, 선언적 환경 레코드)는 외부로부터 은폐되어 있으며 중첩 함수안에서만 읽거나 쓸 수 있습니다.

27. Function.prototype의 프로퍼티
- apply() : 선택한 this와 인수를 사용하여 함수를 호출한다. 인수는 배열 객체다.
- bind() : 선택한 this와 인수를 적용한 새로운 함수를 반환한다.
- call() : 선택한 this와 인수를 사용하여 함수를 호출한다. 인수는 쉼표로 구분한 값이다.
- constructor : Function 생성자의 참조
- toString() : 함수의 소스 코드를 문자열로 만들어 변환한다.

28. Function 객체의 메서드에는 apply와 call이 있습니다. This 값과 함수의 인수를 사용하여 함수를 실행하는 메서드입니다. Apply와 call 의 동작은 본질적으로 같습니다. 차이점은 함수에 인수를 넘기는 방법뿐입니다. Apply는 배열이고 call의 인수는 쉼표로 구분한 값의 목록입니다.

29. 이처럼 apply와 call 메서드의 첫 번째 인수는 함수의 this 값입니다. Apply 메서드의 두 번째 인수는 함수의 인수를 순서대로 담은 배열입니다. 이때 실제 배열 객체 대신 유사 배열 객체를 넘겨도 동작합니다. 예를 들어 현재 실행 중인 함수의 arguments를 apply 메서드에 넘겨도 실행할 수 있습니다. Call 메서드의 두 번째 이후 인수는 함수의 인수 목록입니다.

30. 이처럼 say.bind(tom)은 tom객체를 함수 say의 this로 설정한 새로운 함수를 만들어서 반환합니다.

31. 고차 함수
고차 함수란 함수를 인수로 받는 함수 또는 함수를 반환하는 함수를 말합니다. 자바스크립트의 함수는 일급 객체고 함수의 인수로 함수를 넘길 수 있으며 함수를 반환할 수 있으므로 고차 함수를 쉽게 정의할 수 있습니다. 고차 함수를 사용하면 처리 패턴이 같은 작업을 추상화하여 하나로 합칠 수 있습니다. 고차 함수는 함수형 프로그래밍을 할 때 자주 사용합니다.

32. 함수 f(x)와 g(x)가 있을 때 함수 f(g(x))를 f와 g의 합성 함수라고 합니다.

33. 인수를 여러 개 받는 함수의 몇몇 인수를 상수로 지정해서 새로운 함수를 생성하는 기법을 가리켜 부분 적용이라고 합니다.

34. 커링이란 인수를 두 개 이상 받는 함수를 분해하여 인수가 하나인 함수의 중첩 함수로 변환하는 작업을 말합니다. 커링이라는 이름은 크리스토퍼 스트래치(Christopher Strachey)라는 컴퓨터 과학자가 논리학자인 해스켈 커리(Haskell Curry)의 이름을 따서 지었다고 알려져 있습니다.

35. 화살표 함수의 함수 리터럴은 다음과 같은 차이점이 있습니다.
1) this의 값이 함수를 정의할 때 결정된다.
화살표 함수는 call이나 apply 메서드를 사용하여 this를 바꾸어 호출해도 this 값이 바뀌지 않습니다.
2) arguments 변수가 없다
화살표 함수 안에는 arguments 변수가 정의되어 있지 않으므로 사용할 수 없습니다.
3) 생성자로 사용할 수 없다.
화살표 함수 앞에 new 연산자를 붙여서 호출할 수 없습니다.
4) yield 키워드를 사용할 수 없다.
화살표 함수 안에서는 yield 키워드를 사용할 수 없습니다. 따라서 화살표 함수는 제너레이터로 사용할 수 없습니다.

36. 인수의 기본값
ECMAScript 6부터는 함수의 인자에 대입(=) 연산자를 사용해서 기본값을 설정할 수 있습니다. 기본값을 설정한 인자에 호응하는 인수를 생략하거나 undefined를 넘기면 대입 연산자 우변의 값이 기본값이 됩니다.
function multiply(a, b=1) {
return a*b;
}

37. ECMAScript 6의 이터레이터는 일반적으로 다음 두 가지 항목을 만족하는 객체입니다.
 - next 메서드를 가진다.
 - next 메서드의 반환값은 value 프로퍼티와 done 프로퍼티를 가진 객체이다. 이때 value에는 꺼낸 값이 저장되고 done에는 반복이 끝났는지를 뜻하는 논리값이 저장된다.

38. 일반적으로 for/of 문은 다음 두 가지 조건을 만족하는 객체를 반복 처리합니다.
 - Symbol.iterator 메서드를 가지고 있다.
 - Symbol.iterator 메서드는 반환값으로 이터레이터를 반환한다.
Symbol.iterator 메서드를 가진 객체를 반복 가능(이터러블, iterable)한 객체라고 합니다. 다음 생성자로 생성한 내장 객체는 처음부터 Symbol.iterator 메서드를 내장하고 있습니다. 즉, 반복가능(이터러블)합니다.
 - Array, String, TypedArray, Map, Set

39. 제너레이터
제너레이터는 다음과 같은 성질을 지닌 함수입니다.
-	반복 가능한 이터레이터를 값으로 반환한다.
-	작업의 일시 정지와 재시작이 가능하며 자신의 상태를 관리한다.

40. 제너레이터는 function* 문으로 정의한 함수이며, 하나 이상의 yield 표현식을 포함합니다. 간단한 예로 제너레이터의 메커니즘을 설명하겠습니다.

41. 즉, 제너레이터 함수의 yield는 프로그램이 일시적으로 정지하는 위치입니다. 그리고 제너레이터로 생성한 이터레이터의 next 메서드는 제너레이터 함수의 상태를 일시 정지 상태에서 실행 상태로 바꾸는 역할을 합니다. 이때 이터레이터 객체는 처리를 재개할 수 있도록 제너레이터 함수의 내부 상태를 모두 저장합니다.

42. 템플릿 리터럴 앞에 함수 이름을 적으면 템플릿 리터럴의 내용을 인수로 받는 함수를 호출할 수 있습니다.
func`${a} + ${b} = ${a+b}`

### Chapter 9. 객체

43. 이처럼 자신이 갖고 있지 않은 프로퍼티를 __proto__ 프로퍼티가 가리키는 객체를 차례대로 거슬러 올라가며 검색합니다. 이와 같은 객체의 연결 고리를 프로토타입 체인이라고 합니다.
여기에서 객체 __proto__ 프로퍼티가 가리키는 객체가 바로 상속을 해 준 객체이며, 이 객체를 그 객체의 프로토타입이라고 합니다. 객체는 자신이 가지고 있지 않은 특성(프로퍼티와 메서드)을 프로토타입 객체에 위임(delegate)한다고 할 수 있습니다.

44. 이처럼 자바스크립트는 프로토타입 체인을 사용하여 객체의 프로퍼티를 다른 객체로 전파합니다. 이를 프로토타입 상속이라고 합니다. 프로토타입 상속을 하는 객체 지향 언어를 가리켜 프로토타입 기반 객체 지향 언어라고 합니다.

45. in 연산자는 객체 안에 지명한 프로퍼티가 있는지 검색하며, 그 검색 대상은 그 객체가 소유한 프로퍼티와 상속받은 프로퍼티 모두입니다.

46. hasOwnProperty 메서드는 지명한 프로퍼티가 그 객체가 소유한 프로퍼티면 true를 반환하고 상속 받은 프로퍼티면  false를 반환합니다.

47. Object.keys 메서드는 열거할 수 없는 프로퍼티인 sayHello는 열거하지 않지만 getOwnPropertyNames 메서드는 열거할 수 없는 프로퍼티까지 모두 열거합니다.

48. 얕은 복사와 깊은 복사
얕은 복사(shallow copy)란 객체의 복사본을 만드는 대신 그 객체의 참조만 복사하는 행위를 말합니다. 그렇게 되면 원본과 사본이 같은 객체를 참조하게 됩니다. 반대로 깊은(deep copy)란 객체의 사본을 만들어 다른 메모리 영역에 복사하는 행위를 말합니다.

49. JSON을 사용하면 다른 프로그래밍 언어와 데이터 송수신이 간단해집니다.

50. JSON(JavaScript Object Notation)은 자바스크립트 객체를 문자열로 표현하는 데이터 포맷입니다. JSON을 사용하면 객체를 직렬화할 수 있습니다. 직렬화란 컴퓨터의 메모리 속에 있는 객체를 똑 같은 객체로 환원할 수 있는 문자열로 변환하는 과정을 말합니다.

51. ‘{“name”:”Tom”, “age”:17, “marriage”:false, “data”:[2, 5, null]}’
이처럼 JSON 데이터는 그 전체를 작은따옴표로 묶은 문자열입니다. 이때 객체의 프로퍼티 이름은 큰따옴표로 묶은 문자열로 표기합니다. 숫자, 논리값, 배열은 자바스크립트와 같은 표기법을 사용하지만 문자열은 반드시 큰따옴표로 묶어야 합니다.

52. JSON.stringify 메서드는 인수로 받은 객체를 JSON 문자열로 바꾸어 반환합니다. JSON.stringify 메서드의 사용법은 다음과 같습니다.
JSON.stringify(value[, replacer[, space]])
첫 번째 인수인 value에는 JSON으로 변환할 객체를 지정합니다. 두 번째 인수인 replacer에는 함수 또는 배열을 지정합니다. 두 번째 인수로 함수를 지정하면 문자열로 만든느 프로퍼티의 키와 값을 함수의 인수로 받아서 프로퍼티 값을 표현하는 문자열을 반환합니다. 배열을 지정하면 배열의 요소로 객체의 프로퍼티 이름을 필터링합니다. 세 번째 인수인 space에는 출력하는 문자열을 구분할 때 사용할 공백 문자를 지정합니다.

53. JSON.parse 메서드는 인수로 받은 문자열을 자바스크립트 객체로 환원해서 반환합니다. JSON.parse 메서드의 문법은 다음과 같습니다.
JSON.parse(text[, reviver)

54. 어떠한 상황에서나 깊은 복사를 올바르게 수행하려면 Object.assign 메서드를 사용하세요.

### Chapter 10. 배열의 다양한 기능

55. 형식화 배열
자바스크립트의 배열은 Array 객체입니다. Array 객체는 배열 요소의 추가와 삭제를 동적으로 할 수 있고 다양한 메서드를 이용할 수 있어 편리하지만 배열 요소를 읽고 쓰는 속도가 느리다는 단점이 있습니다. 형식화 배열(TypedArray 객체)은 ArrayBuffer가 확보한 버퍼를 데이터의 저장 장소로 이용하여 데이터의 빠른 읽기와 쓰기를 구현한 객체입니다.

56. Map 객체는 데이터를 수집하여 활용하기 위한 객체입니다. 값의 고유한 식별 정보인 ‘키’와 값의 쌍을 Map 객체 안에 저장해서 사용합니다. Map 객체는 외부에서 키를 사용하여 원하는 값을 추가/삭제/검색할 수 있습니다. 키와 값의 데이터 타입에는 제한이 없습니다. 객체 타입도 사용할 수 있고 원시 타입도 사용할 수 있습니다.

57. 하지만 Map 객체는 Object 객체와 비교했을 때 다음과 같은 차이점이 있습니다.
- Map 객체에는 데이터를 수집하기 위한 다양한 메서드가 마련되어 있다.
- Object 객체는 키로 문자열만 사용할 수 있지만 Map 객체는 키 타입에 제한이 없다.
- Map 객체는 내부적으로 해시 테이블을 활용하기 때문에 데이터 검색 속도가 빠르다.
- Map 객체는 반복 가능(이터러블)하며 for/of 문으로 순회하면 키와 값으로 구성된 배열을 반환한다.
- Map 객체는 데이터 개수를 size 프로퍼티로 구할 수 있다. 하지만 Object 객체는 프로퍼티 개수를 수동으로 계산해야 한다.

58. WeakMap과 WeakSet
Map이나 Set과 유사한 객체로 WeakMap과 WeakSet을 들 수 있습니다. 이들 객체는 데이터의 키 값을 약한 참조로 관리합니다. 키 값이 약한 참조라는 말은 다른 객체가 참조하고 있는 객체라도 가비지 컬렉션의 대상이 될 수 있다는 뜻입니다. 즉, WeakMap과 WeakSet에 저장된 데이터라 하더라도 키 값으로 사용한 원본 객체를 참조하는 객체가 없어지면 가비지 컬렉션의 대상이 됩니다. WeakMap과 WeakSet에서는 키 값을 약한 참조로 관리하기 때문에 다음과 같은 제약 사항이 있습니다.
-	키 값으로 객체만 사용할 수 있다.
-	키 값 목록은 가져올 수 없다.
-	반복 가능한 객체가 아니므로 for/of문으로는 열거할 수 없다.

### Chapter 11. 버그와 오류에 대처하는 방법

59. Strict 모드 사용
프로그램을 개발할 때 버그를 만들지 않는 가장 좋은 방법은 버그 자체가 발생하기 어려운 환경을 조성하는 것입니다. 버그가 발생하기 어려운 환경이 만들어지면 그만큼 프로그램의 필수적인 부분을 만드는 데 시간을 할애할 수 있고 결과적으로 더 품질 높은 프로그램을 만들 수 있습니다.

60. 자바스크립트의 대표적인 스타일 가이드는 다음과 같습니다.
1) Google JavaScript Style Guide
2) JavaScript style guide –MDN Docs
3) Airbnb Javasciprt Style Guide

61. console.trace()
Console.dir로 객체의 프로퍼티 목록을 표시하기

62. try {
// 이곳에 실행할 코드를 적는다(예외가 발생할 수 있는 코드)
} catch(exception) {
// 이 블록은 try 블록에서 예외가 발생했을 때 실행된다
// exception에는 던져진 예외 값이 들어옴. 이 값을 바탕으로 예외를 처리한다
} finally {
// 이 블록 안의 코드는
// try 블록 코드와 catch 블록 코드가 실행된 이후에 반드시 실행된다
}

### Chapter 12. 정규표현식
63. var reg = new RegExp(“abc”); // RegExp 생성자로 생성
var reg = /abc/; // 정규 표현식 리터럴로 생성

64. test 메서드는 정규 표현식 문자열이 일치하는지 뜻하는 논리값을 반환합니다.

65. exec 메서드는 정규 표현식과 일치하는 문자열을 검색하여 일치한 문자열을 배열로 반환합니다. 일치하는 문자열을 찾지 못했을 때는 null을 반환합니다.

66. 반환된 배열에는 index와 input 프로퍼티가 있습니다. Index 프로퍼티에는 가장 처음 일치한 위치가 들어가고 input 프로퍼티에는 일치한 문자열이 들어갑니다.

67. 다음 문자는 정규 표현식에서 특별한 뜻을 갖는 메타 문자(정규 표현식의 구문 문자)입니다.
 ^ $ \ . * + ? ( ) [ ] { } |
이에 관한 자세한 내용은 이다음에 하나씩 설명합니다. 이 메타 문자를 문자로 표기할 때는 메타 문자 앞에 \문자를 붙여서 이스케이프합니다.

68. 문자 클래스 : […]
문자 클래스는 특정 문자 집합 안의 모든 단일 문자와 일치합니다. 문자 클래스를 정의하려면 문자 집합의 요소가 되는 문자 리터럴을 나열하여 대괄호로 묶어 줍니다.

69. 문자 클래스인 대괄호 안에서 하이픈(-)을 사용하면 문자의 범위를 지정할 수 있습니다.
[a-z]
[abcx-z]
[a-zA-Z0-9]

70. 유니코드의 범위를 지정해서 문자 클래스를 정의할 수도 있습니다.
[\u3131-\u314E] //한글 자음 한 개
[\u314F-\u3163] // 한글 모음 한 개
[\uAC00-\uD7A3] // 한글 음계 한 개
[\uF900-\uFAFF] // CJK 호환 한자 한 개

71. 부정 문자 클래스 : [^..]
[^…]는 문자 클래스인 대괄호 안에 들어 있지 않은 단일 문자와 일치합니다. 즉, [^…]는 […]의 여집합의 문자 한 개와 일치합니다.

72. /c.t/ // “cat”, “cute” 등과 일치함. “action”, “condition”과는 일치하지 않음
/c..l/ // “hot and cool” 등과 일치함. “cols”, “console”과는 일치하지 않음

73. 숫자와 숫자 외의 문자: \d, \D
\d는 숫자로 해석할 수 있는 문자 한 개와 일치합니다. \d는 [0123456789]의 단축 표기입니다.

74. d를 대문자로 바꾼 \D는 숫자 외의 문자와 일치합니다. \D는 [^0123456789]의 단축 표기입니다.

75. 단어 문자와 단어 문자 외의 문자 : \w, \W
\w는 모든 영어 단어 문자(알파벳, 숫자, 언더스코어)라는 뜻입니다. 즉 \w는 [a-zA-Z0-0_]의 단축 표기입니다. W는 word character라는 뜻입니다.

76. w만 대문자로 바꾼 \W는 영어 단어 문자(알파벳, 숫자, 언더스코어)가 아닌 문자와 일치합니다.

77. 공백 문자와 공백 문자 외의 문자: \s, \S
\s는 모든 공백 문자(공백 문자, 탭 문자, 개행 문자 등)와 일치합니다.

78. s를 대문자로 바꾼 \S는 공백 문자가 아닌 문자와 일치합니다.

79. 최소 m번, 최대 n번 반복 : {m, n}
{m, n}는 바로 앞의 요소를 최소 m번, 최대 n번 반복합니다.
/[a-z]{6,12} // 알파벳 소문자가 여섯 자 이상이며 열두 자 이하인 문자열과 일치

80. 바로 앞의 요소를 최소 n번 반복 : {n,}

81. 바로 앞의 요소를 n번 반복 : {n}

82. 최대 한 번 반복 : ?
?는 바로 앞의 요소를 최소 0번, 최대 한 번 반복합니다. 이는 {0, 1}와 같습니다.

83. 최소 한 번 반복 : +
+는 바로 앞의 요소를 최소 한 번 이상 반복합니다. 이는 {1,}와 같습니다.

84. 최소 0번 반복 : *
*는 바로 앞의 요소를 최소 0번 이상 반복합니다. 이는 {0,}와 같습니다.

85. 그룹화 : (…)
정규 표현식의 패턴 요소를 소괄호로 묶으면 부분적으로 그룹화할 수 있습니다. 그룹화한 부분은 ?, +, * 등을 사용해서 반복할 수도 있고, 나중에 언급할 |를 사용해서 선택의 범위를 좁힐 수도 있습니다.

86. 문자열의 시작 위치 : ^
^은 문자열의 시작 위치에 패턴을 고정합니다.

87. 문자열의 마지막 위치 : $
$는 문자열의 마지막 위치에 패턴을 고정합니다.

88. 영어 단어의 경계 : \b
/\scat\s/라는 정규 표현식으로 영어 문장 안에서 ‘cat’이라는 단어를 검색하는 상황을 예로 들어 보겠습니다. ‘cat’이 문장 중간에 있다면 /\scat\s/패턴으로 찾아낼 수 있습니다. 하지만 이 문장의 앞이나 뒤에 있는 cat은 찾아낼 수 없습니다. 공백 문자가 그 문장의 앞부분과 뒷부분에 없기 때문입니다. 이때는 \b를 사용합니다. \b는 영어 단어의 경계 위치와 일치합니다. \b는 영어 문자의 시작 부분 또는 끝부분의 다른 문자가 없는 위치에 매칭하며 구체적으로는 다음과 같이 표기합니다.

89. 영어 단어 경계 외의 위치 : \B
\B는 영어 단어 경계 외의 위치에 일치합니다.

90. 전방 탐색 : (?=pattern)
x(?=y)라고 표기하면 x 다음에 y가 나오는 패턴이 됩니다.

90. 전방 탐색 : (?!pattern)
x(?!y)라고 표기하면 x 다음에 y가 나오지 않는 패턴이 됩니다	

91. 선택 패턴
선택 패턴은 문자열 여러 개 중에서 문자열 하나와 일치합니다. 선택 패턴을 정의할 때는 후보가 되는 패턴 문자열을 |로 연결해서 표기합니다.

92. 앞 코드에서 정규 표현식 /apple|peach|orange/는 apple, peach, orange 중 하나라는 뜻입니다. 선택 패턴을 다른 정규 표현식 요소와 함께 사용할 때는 선택 패턴 전체를 소괄호로 묶어 그룹화해서 다른 정규 표현식 요소와 구별합니다.

93. 플래그
정규 표현식에는 고급 검색을 설정하기 위한 플래그가 다섯 개 있습니다. 이들 플래그는 한 개만 설정할 수도 있고 여러 개를 조합해서 설정할 수도 있습니다. 

94. 
i : 대문자와 소문자를 구별하지 않는다.
g : 전역 검색한다. 처음뿐만 아니라 일치하는 모든 것을 검색한다.
m : 여러 줄 모드로 검색한다. 앵커 문자 ^과 $는 각각 행의 시작과 끝이라는 뜻이다.
y : 시작 위치 고정 검색을 한다.
u : 정규 표현식 패턴을 내부적으로 유니코드 코드 포인트 열로 처리한다.

95. var reg = new RegExp(“abc”,”g”);
var reg = /abc/g;
var reg = /abc/gi;

96. replace 메서드의 기본적인 사용법
Replace 메서드는 첫 번째 인수로 받은 정규 표현식과 일치하는 문자열을 검색하고, 두 번째 인수로 받은 문자열로 치환한 새로운 문자열을 반환합니다. Replace 메서드는 원본 문자열을 고치지 않습니다. 정규 표현식에 g 플래그를 설정하면 일치한 문자열을 모두 치환합니다. g 플래그를 설정하지 않으면 가장 처음 일치한 문자열만 치환합니다.

97. match 메서드는 첫 번째 인수로 받은 정규 표현식과 일치하는 문자열을 순서대로 저장해서 배열로 반환합니다. Match 메서드는 원본 문자열을 수정하지 않습니다.

### Chapter 13. 웹 브라우저의 객체

### Chapter 14. 문서 제어

98. 속성 값 가져오기
요소 객체.getAttribute(속성의 이름)

99. 속성 값 설정하기
요소 객체.setAttribute(속성 이름, 속성 값)

100. 속성이 있는지 확인하기
요소 객체.hasAttribute(속성 이름)

101. 속성 삭제하기
요소 객체.removeAttribute(속성 이름)

102. innerHTML 프로퍼티로 HTML 코드를 편집할 수 있습니다. 그러나 이 방법은 코드를 문자열로 다루어야 하므로 복잡한 구조를 가진 코드를 편집할 때는 적합하지 않습니다. innerHTML 프로퍼티는 간단한 내용을 편집하기에 좋습니다.

103. 노드 생성하기
Var element = document.createElement(요소의 이름);
Var textnode = document.createTextNode(텍스트);

104. 노드 삽입하기
요소 노드.appendChilde(삽입할 노드)

105. 지정한 자식 노드의 바로 앞에 삽입하기
요소 노드.insertBefore(삽입할 노드, 자식 노드)

106. 노드 삭제하기
노드.removeChild(자식 노드)

107. 노드 replaceChild(새로운 노드, 자식 노드)

108. HTML 요소의 위치와 크기 구하기
요소 객체의 getBoundingClientRect 메서드는 뷰 포트 좌표계로 측정한 해당 요소의 보더 박스 위치와 크기 정보를 담은 객체를 반환합니다.
Var rect = 요소 객체.getBoundingClientRect();

109. 뷰 포트 크기 가져오기
Document.documentelement.clientWidth : 뷰 포트의 너비(스크롤 막대의 너비를 포함하지 않음)
Document.documentElement.clientHeight : 뷰 포트의 높이(스크롤 막대의 높이를 포함하지 않음)
Window.innerWidth : 뷰 포트의 너비(스크롤 막대의 너비를 포함)
Window.innerHeight : 뷰 포트의 높이(스크롤 막대의 높이를 포함)

110. 특정 위치로 스크롤하기
Window.scrollTo(X,Y);

111. 특정 거리만큼 스크롤하기
Window.scrollBy(dx, dy)
예를 들어 한 페이지 분량만큼(표시 영역의 높이만큼) 스크롤하려면 다음과 같이 작성합니다.
scrollBy(0, window.innerHeight);

112. 요소 객체의 scrollIntoView 메서드는 그 요소가 웹 브라우저의 표시 영역에 들어올 때까지 스크롤합니다.
요소 객체.scrollIntoView(alignWithTop);

113. HTML 폼
폼은 사용자로부터 입력을 받는 HTML의 메커니즘입니다. 폼 요소는 웹 브라우저에 입력 인터페이스를 제공합니다.

114. 웹에서는 폼을 다양한 용도로 사용합니다. 온라인 쇼핑몰에서 사용자 정보를 입력할 때, 검색 엔진에 키워드를 입력할 때, 데이터베이스를 검색하는 등의 다양한 상황에서 폼을 사용합니다. 데이터 처리라는 관점에서 볼 때 폼을 이용하는 형태는 크게 두 가지로 나눌 수 있습니다.
1) 폼에 입력한 데이터를 웹 서버로 보내고 웹 서버는 그 데이터를 처리한다.
그 결과를 사용자에게 반환하거나 데이터베이스에 저장한다.
2) 클라이언트 측 자바스크립트로 웹 애플리케이션을 만들 때 사용자 입력을 받는 사용자 인터페이스로 사용한다. 이때 데이터 처리는 클라이언트 측 자바스크립트 프로그램이 담당한다.

115. 폼 요소와 폼 컨트롤 요소
method 속성 : 데이터 전송 방법(“POST” 또는 “GET”)
action 속성 : 데이터를 처리하는 CGI 프로그램의 URL

### Chapter 15. 이벤트 처리

116. addEventListener를 사용해서 얻을 수 있는 장점
- 같은 요소의 같은 이벤트에 이벤트 리스터를 여러 개 등록할 수 있다.
- 버블링 단계는 물론 캡처링 단계에서도 활용할 수 있다. 반면에 DOM 요소 객체에 직접 등록한 이벤트 처리기는 버블링 단계의 이벤트만 캡처할 수 있다.
- removeEventListener, stopPropagation, preventDefault를 활용하여 이벤트 전파를 정밀하게 제어할 수 있다.
- HTML 요소를 포함한 모든 DOM 노드에 이벤트 리스너를 등록할 수 있다.

117. 이벤트 전파 취소하기 : stopPropagation 메서드
이벤트 리스너 안에서 이벤트 객체의 stopPropagation 메서드를 호출하면 이벤트가 그다음 요소로 전파되는 것을 막습니다. 그러나 그 요소 객체의 그 이벤트에 등록한 다른 이벤트 리스너는 변함없이 실행됩니다. stopPropagation 메서드의 사용법은 다음과 같습니다.
Event.stopPropagation();

118. 기본 동작 취소하기 : preventDefault 메서드
Event.preventDefault();

### Chapter 16. HTTP 제어(Ajax)

119. HTTP(Hyper Text Transfer Protocol)는 웹 브라우저와 웹 서버가 HTML로 작성된 웹페이지나 동영상, 음성 파일 등을 주고받기 위한 프로토콜(통신 규약)입니다. RFC2616이라는 이름으로 규정되어 있으며, 하이퍼텍스트 프로토콜이라는 이름으로도 부릅니다. 이 프로토콜을 SSL로 암호화하여 보안성을 확보한 것을 가리켜 HTTPS라고 합니다.

120. HTTP에서는 전송 계층 프로토콜로 TCP를 사용하고 네트워크 계층 프로토콜로 IP를 사용하는 것이 일반적입니다. 이 두 계층을 합쳐서 TCP/IP라는 이름으로 부릅니다. TCP/IP에서는 IP주소를 사용해서 통신할 컴퓨터를 결정합니다. 그리고 포트 번호를 사용해서 그 컴퓨터의 어떤 프로그램과 통신할지를 결정합니다. HTTP에서는 기본적으로 80번 포트를 사용합니다.

121. GET : 웹 서버에 페이지를 요청한다. 요청할 때 필요한 데이터는 URL에 덧붙여 보내며 텍스트 데이터만 전송할 수 있다.
POST : 서버의 데이터를 갱신하거나 보내는 데이터의 양이 많을 때, 비밀번호 등의 개인 정보를 보낼 때 사용한다. 요철할 때 필요한 데이터는 메시지 본문에 담아서 보내며 텍스트 데이터와 바이너리 데이터를 모두 보낼 수 있다.

122. Ajax
Ajax(Asynchronous JavaScript + XML)란 XMLHttpRequest라는 자바스크립트 객체를 이용하여 웹서버와 비동기로 통신하고 DOM을 이용하여 웹 페이지를 동적으로 갱신하는 프로그래밍 기법을 말합니다. Ajax 기술은 2005년에 등장한 이후 급속히 보급되었으며 클라이언트 측 자바스크립트에 필수적인 기술이 되었습니다. 참고로 ‘Asynchronous’란 ‘비동기’라는 뜻입니다. 또한 XML은 Extensible Markup Language의 약자로 W3C에서 정의한 마크업 언어입니다. 이는 원래 Ajax에서 사용하는 데이터 형식을 뜻하는 단어였습니다. 하지만 현재 XML을 사용하는 경우는 매우 드물고 주로 JSON과 텍스트 데이터를 사용합니다.

123. Ajax를 활용한 지도 서비스
사용자가 찾아보려는 장소가 바뀌면 클라이언트 측 자바스크립트가 현재 가지고 있는 지도 데이터에서 부족한 부분을 파악합니다. 그리고 서버에 그 부분만 보내 달라는 요청을 보냅니다. 이 요청을 받은 서버는 클라이언트가 필요로 하는 데이터만 전송합니다. 클라이언트는 이 데이터를 받아서 필요한 부분만 DOM으로 변경합니다. 이때 일련의 통신은 비동기적으로 이루어집니다. 따라서 서버가 데이터를 다 보내지 않은 상태라 하더라도 클라이언트를 자유롭게 사용할 수 있습니다.

124. Ajax의 장점
1) 최소한의 데이터 통신만 하므로 처리 속도가 빠르고 서버 부하와 통신 트래픽 부하가 적다.
2) 비동기로 통신하므로 클라이언트 측에서 다른 작업을 할 수 있다.
3) 웹 페이지 갱신을 클라이언트 측이 담당한다. 페이지를 전환하는 대신에 페이지 일부분만 변경하므로 고속 렌더링이 가능하다.
Ajax를 활용하면 화면을 전환하는 빈도가 줄어들기 때문에 사용자에게 데스크톱 애플리케이션을 사용하는 듯한 편의성을 제공할 수 있습니다.

125. XMLHttpRequest
Ajax 기법을 사용할 때는 데이터의 송수신에 XMLHttpRequest 객체를 사용합니다.

126. 기본적인 처리의 흐름
Ajax를 활용한 비동기 통신은 다음과 같은 단계를 거칩니다.
1)	XMLHttprequest 객체를 생성한다.
2)	서버와 통신할 때 사용할 처리 방법을 등록한다.
3)	요청을 전송하고 통신을 시작한다.

127. 서버와 통신할 때 사용할 처리 방법의 등록
XMLHttpRequest 객체를 생성했다면 이제 서버와 통신할 때의 처리를 정의합니다.
비동기 통신을 할 때는 서버와의 통신 상태를 감시할 수 있습니다. 따라서 통신 상태가 바뀌었을 때 특정 처리를 추가할 수 있습니다. 통신 상태가 바뀌면 readyState 프로퍼티 값이 바뀝니다. 그러면 웹 브라우저가 값의 변화를 감지해서 readystatechange 이벤트를 발생시킵니다. 이 이벤트가 발생했을 때 처리할 작업을 onreadystatechange 이벤트 처리기에 등록해 두면 통신할 때 추가적인 작업을 할 수 있습니다.ㅈ
Req.onreadystatechange = function(){…};
Or
Req.addEventListener(“readystatechange”, function(){…});

128. 요청을 초기화하기
open 메서드는 요청을 초기화합니다. open 메서드의 사용법은 다음과 같습니다.
req.open(method, url, [,async [,user [,password]]]);
인수의 의미는 다음과 같습니다.
Method : HTTP 메서드
url : 접근할 URL
async : 비동기 통신 여부(선택 사항, 기본값은 true(비동기 통신))
user : 인증할 때의 사용자 이름(선택 사항, 인증이 필요한 경우에만 사용)
password : 인증할 때의 암호(선택 사항, 인증이 필요한 경우에만 사용)

129. XMLHttpRequest는 동일 출처 정책을 준수하기 때문에 크로스 오리진 통신을 할 수 없습니다. 단, 다음 기법을 사용하면 크로스 오리진 통신을 할 수 있습니다.
- JSONP
- CORS
- postMessage

130. JSONP
JSONP(JSON with Padding)란 ‘script 요소의 src 속성이 가리키는 자바스크립트 파일은 다른 도메인에 위치해도 읽어 들일 수 있다’라는 성질을 활용한 기법입니다. JSONP의 마지막 P인 Padding이라는 단어에는 JSON 데이터에 함수 이름을 추가했다는 뜻이 담겨 있습니다. 

131. CORS
XMLHttpRequest Level 1에서는 크로스 오리진 통신이 금지되어 있지만 XMLHttpRequest Level 2부터는 크로스 오리진 통신을 제한적으로 허용합니다. 이 사양을 가리켜 CORS(Cross Origin Resource Sharing)라고 합니다. 이는 ‘데이터를 가져오는 대상이 악의적인 웹 사이트라면 읽기와 쓰기를 금지해야 하지만 그 상대를 신뢰할 수 있다면 데이터의 읽기와 쓰기를 허용하자’는 생각에서 출발한 것입니다. 인터넷 익스플로러는 버전 10부터 CORS를 지원하고 있습니다.

### Chapter 17. MVC모델에 기반을 둔 프로그램 설계

132. 디자인 패턴
디자인 패턴이란 지금까지 수많은 소프트웨어 개발자들이 오랜 세월에 걸쳐 쌓아 온 프로그램 설계 노하우를 집대성한 것입니다. 디자인 패턴의 개념은 Gof(Gang of Four)라고 불리는 저자 네 명이 쓴 ‘Gof의 디자인 패턴’에서 처음 소개된 이후 많은 프로그래머들의 연구 대상이 되었습니다.

133. MVC 모델에서는 애플리케이션의 내부 데이터를 사용자에게 표시하는 정보와 분리합니다. 그리고 프로그램을 다음의 세 부분으로 나누어 만들어 나갑니다.
- 모델 : 응용 프로그램의 데이터와 그것을 처리하는 로직을 담당하는 부분
- 뷰 : 모델의 데이터나 데이터의 처리 결과를 사용자가 볼 수 있는 형태로 표현하는 부분
- 컨트롤러 : 사용자로부터 입력받은 데이터를 모델에 메시지로 전달해서 프로그램을 제어하는 부분

134. MVC 모델을 구현하는 방법은 매우 다양하지만 제어 흐름에는 전형적인 패턴이 있습니다.
1) 사용자 입력을 컨트롤러가 받는다.
2) 컨트롤러는 모델의 메서드를 사용한다.
3) 모델의 메서드는 모델이 가진 상태를 바꾼다.
4) 모델은 상태의 변화를 뷰에 보고하고 뷰는 모델의 상태에 따라 표시 내용을 갱신한다.

135. MVC 프레임워크
MVC 프레임워크란 MVC 모델을 적용한 대규모 웹 애플리케이션의 구축을 지원하는 라이브러리를 말합니다. MVC 프레임워크는 MVC 패턴 설계를 지원하는 역할을 담당하는 것이 일반적입니다. 하지만 자바스크립트를 활용해서 개발할 때는 다음과 같은 문제 해결책도 함께 제공합니다.
-	전역 변수의 사용에 따른 이름 공간의 오염 문제
-	재사용이 가능한 코드의 작성
-	유지 보수성을 향상하기 위한 폴더 구조와 파일 이름의 명명 규칙
-	테스트를 고려한 프로그램 품질 관리
-	단일 페이지 애플리케이션(Single Page Application)의 브라우저 해킹 문제(URL을 바꾸지 않고 화면을 전환하기 위해 발생하는 오류)

### Chapter 18. 생성자와 클래스 구문

136. 다음은 클래스 선언문을 작성하는 방법을 정리한 것입니다.
-	Class 키워드 뒤에 생성자 함수의 이름을 표기합니다. 이 함수의 이름은 클래스 이름입니다.
-	{…} 안은 클래스 몸통(class body)이라고 합니다. 클래스 몸통에는 클래스 멤버를 정의합니다. 클래스 멤버는 함수 선언문에서 function 키워드를 생략한 표현식입니다.
-	클래스의 멤버인 constructor () {…}에는 특별한 의미가 있습니다. Constructor는 생성자로 객체를 생성할 때 초기화 처리를 담당하는 메서드입니다. 지금까지 생성자 함수에 작성했던 작업들을 이곳에 작성해서 객체에 프로퍼티를 추가합니다.
-	Constructor 다음에 작성된 클래스 멤버는 생성자 함수의 prototype에 메서드로 추가됩니다.

137. 클래스 선언문으로 정의한 생성자는 함수 선언문으로 정의한 생성자와 같습니다. 그러나 클래스 선언문과 함수 선언문은 다음 차이점이 있습니다.
- 클래스 선언문은 자바스크립트 엔진이 끌어올리지 않습니다. 따라서 생성자를 사용하기 전에 클래스 선언문을 작성해야 합니다.
- 클래스 선언문은 한 번만 작성할 수 있습니다. 같은 이름을 가진 클래스 선언문을 두 번 이상 작성하면 타입 오류가 발생합니다.
- 클래스 선언문에 정의한 생성자만 따로 호출할 수 없습니다.

138. class 구문을 사용하면 생성자 함수에 메서드를 추가할 수도 있습니다. Class 구문에서는 생성자의 메서드를 정적 메서드라는 이름으로 부릅니다. 정적 메서드를 정의하려면 클래스 멤버 앞에 static 키워드를 붙여 줍니다.

139. 클래스 구문은 함수를 정의한다 클래스를 정의하지 않는다.
ECMAScript 6부터 추가된 클래스 구문은 생성자 함수를 간결하게 작성하기 위한 문법 요소라는 점에서 C++나 Java 등의 클래스와는 차이가 있습니다. 클래스 구문이 추가되었음에도 자바스크립트의 객체 지향 메커니즘은 바뀐 것이 없습니다. 클래스 구문을 사용할 때는 늘 이 점에 유의하세요. 클래스 구문은 그 배경지식인 자바스크립트 객체의 메커니즘과 프로토타입 상속을 제대로 이해한 후에 사용해야합니다.

### Chapter 19. API 활용

140. Web Workers를 사용하면 특정 작업을 멀티 스레드로 실행할 수 있습니다. 따라서 부하가 많이 걸리는 작업이 다른 작업을 막는 문제를 해결할 수 있습니다. 클라이언트 측 자바스크립트에서 정의한 스레드를 가리켜 메인 스레드라고 합니다. Web Workers에서 병렬로 실행되는 스레드는 워커(worker)라고 합니다. 워커와 메인 스레드는 다른 전역 객체를 가지며, 상대방의 전역 객체를 참조할 수 없습니다. 워커와 메인 스레드는 postMessage를 사용한 비동기 통신만 가능합니다.

#모던자바스크립트입문#이소히로시

