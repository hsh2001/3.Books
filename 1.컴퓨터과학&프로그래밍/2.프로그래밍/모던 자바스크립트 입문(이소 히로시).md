# 모던 자바스크립트 입문
### 지은이 : 이소 히로시
### 출판사 : 길벗
### 읽은 날 : 2020.02.05 ~

### Chapter.1 ~ Chapter.7

1. 반면에 프로그램을 한 줄마다 기계어로 번역해서 실행하는 프로그래밍 언어를 인터프리터 언어라고 하며, 프로그램을 번역해서 실행시키는 소프트웨어를 인터프리터라고 합니다. 자바스크립트는 인터프리터 언어입니다.

2. 프로그램에 직접 작성할 수 있는 상수 값은 리터럴이라고 합니다.

3. 이스케이프 시퀀스

4. const 문으로 선언한 상수 값은 수정할 수 없지만, 상수 값이 객체이거나 배열일 경우에는 프로퍼티 또는 프로퍼티 값을 수정할 수 있습니다.

5. 실제로 msgObj는 실행하는 순간에 일시적으로 생성되는 String 객체이므로 사용자에게는 보이지 않습니다. 처리가 끝나면 곧바로 메모리에서 삭제됩니다. 이러한 객체를 가리켜 래퍼 객체(wrapper object)라고 합니다. 자바스크립트에서는 원시 값을 처리할 때 원시 값을 래퍼 객체로 자동 변환합니다. 그리고 래퍼 객체의 기능을 활용해서 다양한 작업을 수행합니다. 문자열은 String 객체, 숫자는 Number 객체, 논리값은 Boolean 객체로 변환됩니다. 단, null과 undefined에는 래퍼 객체가 없습니다.

6. 자바스크립트의 문자열은 불변(immutable)이라는 점도 기억하세요. Replace와 toUpperCase 메서드 등은 새로운 문자열을 반환하며 메서드를 호출한 문자열은 수정하지 않습니다.

7. 문자열을 읽을 때는 charAt 메서드 대신 대괄호 연산자를 사용할 수 있습니다. 그러나 배열처럼 값을 대입해서 수정할 수는 없습니다. 대입해도 무시됩니다.

8. a && b
A를 평가한 값이 false면 b의 값에 관계없이 표현식 전체 값이 false가 됩니다. 따라서 b의 값을 평가하지 않습니다. 이때 &&연산자는 false 대신에 a의 값 자체를 반환합니다. 또한 a를 평가한 값이 true면 전체 표현식 값이 b의 값으로 경정됩니다. 이때 && 연산자는 true나 false 대신에 b의 값 자체를 반환합니다. 이렇게 작성하더라도 논리값이 필요한 장소에서는 논리값으로 타입이 변환되기 때문에 논리식 자체는 정상적으로 동작합니다.
&& 연산자는 객체의 프로퍼티를 이용할 때와 객체가 null인지 아닌지를 확인하고자 할 때 유용하게 사용됩니다.

9. || 연산자는 여러 개의 값 후보 중에서 null 또는 undefined가 아닌 값을 선택하고자 할 때 유용하게 사용됩니다. 예를 들어 봅시다.
var time = time_interval || animationSetting.time || 33;
이렇게 작성하면 time_interval이 정의되어 있을 때는 time_interval 값을 사용합니다. 정의되지 않았을 때는 animationSettings 객체의 time 프로퍼티를 사용합니다. 이 프로퍼티도 정의되지 않았을 때는 정수(33)를 사용합니다.

10. 대화상자는 모달(modal) 창입니다. 대화상자가 떠 있는 중에는 부모 창의 작업이 일시적으로 정지 상태가 되어 부모 창을 조작할 수 없게 된다는 뜻입니다.

11. 에라토스테네스의 체는 소수를 구하는 알고르즘으로 고대 그리스의 수학자인 에라토스테네스가 고안했다고 알려져 있습니다. 알고리즘은 다음과 같습니다.
-정수 n을 지정하고, 2 이상 n 이하 정수의 목록을 만든다. 가장 작은 수인 2는 소수다.
-그것만 남겨 두고 2의 배수를 목록에서 모두 지운다. 남은 숫자 중 가장 작은 수인 3은 소수다.
-그것만 남겨 두고 3의 배수를 목록에서 모두 지운다.
-이처럼 아직 지우지 않은 가장 작은 수만 남기고 그 배수를 목록에서 지우는 작업을 반복하면 목록에는 소수만 남는다.

12. 라벨을 지정한 break 문은 주로 중첩된 반복문의 안쪽 반복문 안에서 전체 반복문을 빠져나올 때 사용합니다.

### Chapter 8. 함수

13. 재귀 함수는 재귀 호출이 멈출 때까지 몇 번이고 자기 자신을 호출하는 함수입니다. 호출된 각각의 재귀 함수는 메모리의 다른 영역을 사용합니다. 따라서 호출된 횟수만큼 메모리 소비량이 늘어납니다. 반복문을 재귀 함수로 바꾸어 표현할 수는 있지만 대부분은 while 문이나 for 문으로 작성하는 편이 이해하기 쉽고 메모리 공간도 적게 차지합니다. 따라서 재귀 함수는 재귀 호출로 문제를 더 간단하게 해결할 수 있을 때만 사용하는 것이 바람직합니다.

14. 자바스크립트에서는 작업을 싱글 스레드로 처리합니다. 호출 스택에 쌓인 실행 문맥(함수 또는 코드)을 위에서부터 아래로 차례차례 실행해 나갑니다. 그리고 실행 문맥 하나의 작업이 끝나면 pop을 하고 바로 아래에 있는 실행 문맥을 실행합니다. 즉, 실행 문맥 단위의 작업을 차례대로 실행하므로 실행 문맥(함수나 코드) 하나의 작업이 끝날 때까지 또 다른 실행 문맥의 작업을 실행하지 않습니다.

15. 이벤트 처리와 같은 비동기 처리도 똑 같은 방식으로 실행합니다. 실행할 준비를 마친 이벤트 처리기 함수와 비동기 처리는 실행하기에 앞서 이벤트 큐에 대기 행렬을 만듭니다. 그리고 현재 실행 중인 함수의 작업이 끝나면 대기 행렬에서 실행을 기다리는 첫 번째 실행 문맥(함수 또는 코드)부터 차례대로 호출 스택에 push해서 실행해 나갑니다.

16. 함수는 객체에 묶여 있지 않다(객체가 함수를 참조할 뿐)

17. 최상위 레벨 코드의 this는 전역 객체를 가리킵니다.
Console.log(this); //Window

18. 함수 객체의 apply와 call 메서드를 사용하면 함수를 호출할 때 this가 가리키는 객체를 바꿀 수 있습니다. 즉 그 함수가 실행되는 실행 문맥의 디스 바인딩 컴포넌트가 가리키는 객체를 명시적으로 설정할 수 있습니다.

19. 가비지 컬렉션
프로그램에서 객체를 생성하면 메모리 공간이 동적으로 확보됩니다. 사용하지 않는 객체의 메모리 영역은 가비지 컬렉터가 자동으로 해제합니다. 이 메커니즘을 가리켜 ‘가비지 컬렉션(garbage collection)’이라고 합니다. 이때 사용하지 않는 객체란 다른 객체의 프로퍼티와 변수가 참조하지 않는 객체를 말합니다.

20. 최근의 주요 웹 브라우저는 마크 앤 스윕(Mark-and-Sweep) 알고리즘을 사용합니다. 전역 객체가 참조할 수 없는 객체를 검색하고 해당하는 객체가 있다면 필요 없는 객체라고 판단하여 메모리에서 해제하는 방식입니다. 순환 참조 상태인 객체는 고립되어 있습니다. 따라서 전역 객체가 참조할 수 없으므로 메모리에서 해제합니다. 그래서 이 방식을 사용하면 순환 참조에 의한 메모리 누수가 발생하지 않습니다.

21. 자바스크립트의 모든 함수는 클로저를 정의합니다. 클로저는 자바스크립트가 가진 강력한 기능으로, 이를 활용하면 변수를 은닉하여 지속성을 보장하는 등의 다양한 기능을 구현할 수 있습니다. 자바스크립트는 스킴(Scheme)이라는 언어에서 큰 영향을 받았습니다. 클로저 또한 스킴에서 받아들인 기능입니다.

22. 클로저
클로저(closure, 함수 폐포)를 프로그래밍 언어적인 관점에서 설명하면 다음과 같은 동작을 하는 함수와 그 기능을 구현한 자료 구조의 모음이라고 할 수 있습니다.
-	자기 자신이 정의된 환경에서 함수 안에 있는 자유 변수의 식별자 결정을 실행한다.

23. 클로저 = 함수 객체 + 렉시컬 환경 컴포넌트

24. 클로저의 어원
위의 예에 등장한 중첩 함수 g는 열린 함수입니다. 그러나 유효 범위 체인으로 주변 환경의 변수 b와 a를 들여와서 실질적으로는 폐쇄 함수가 되었습니다. 이러한 ‘열려 있던 것을 닫는다’는 개념이 클로저(closure)의 어원입니다.

25. 객체의 프로퍼티를 외부에서 읽고 쓸 수 있지만 클로저 내부 상태는 외부로부터 숨겨진 상태입니다. 객체 지향 프로그래밍에서는 객체의 프로퍼티를 외부로부터 은폐하는 행위를 가리켜 캡슐화라고 합니다. 즉, ‘클로저는 캡슐화된 객체’라고 할 수 있습니다.

26. 클로저를 이해하기 위한 핵심 사항
- 외부 함수를 호출하면 그 함수의 렉시컬 환경 컴포넌트가 생성됩니다. 그리고 그 안에 중첩된 중첩 함수의 함수 객체를 생성해서 반환합니다. 그 결과 외부 함수의 렉시컬 환경 컴포넌트를 참조하는 중첩 함수가 정의한 클로저가 생성됩니다. 즉, 외부 함수는 클로저를 생성하는 팩토리 함수라고 할 수 있습니다.
- 외부 함수가 속한 렉시컬 환경 컴포넌트는 클로저 내부 상태 자체입니다. 외부 함수가 호출될 때마다 새로 생성됩니다.
- 중첩 함수의 함수 객체가 있는 한 외부 함수가 속한 렉시컬 환경 컴포넌트는 지워지지 않습니다. 외부 함수의 함수 객체가 사라져도 지워지지 않습니다.
- 클로저 내부 상태(외부 함수의 지역 변수, 선언적 환경 레코드)는 외부로부터 은폐되어 있으며 중첩 함수안에서만 읽거나 쓸 수 있습니다.

27. Function.prototype의 프로퍼티
- apply() : 선택한 this와 인수를 사용하여 함수를 호출한다. 인수는 배열 객체다.
- bind() : 선택한 this와 인수를 적용한 새로운 함수를 반환한다.
- call() : 선택한 this와 인수를 사용하여 함수를 호출한다. 인수는 쉼표로 구분한 값이다.
- constructor : Function 생성자의 참조
- toString() : 함수의 소스 코드를 문자열로 만들어 변환한다.

28. Function 객체의 메서드에는 apply와 call이 있습니다. This 값과 함수의 인수를 사용하여 함수를 실행하는 메서드입니다. Apply와 call 의 동작은 본질적으로 같습니다. 차이점은 함수에 인수를 넘기는 방법뿐입니다. Apply는 배열이고 call의 인수는 쉼표로 구분한 값의 목록입니다.

29. 이처럼 apply와 call 메서드의 첫 번째 인수는 함수의 this 값입니다. Apply 메서드의 두 번째 인수는 함수의 인수를 순서대로 담은 배열입니다. 이때 실제 배열 객체 대신 유사 배열 객체를 넘겨도 동작합니다. 예를 들어 현재 실행 중인 함수의 arguments를 apply 메서드에 넘겨도 실행할 수 있습니다. Call 메서드의 두 번째 이후 인수는 함수의 인수 목록입니다.

30. 이처럼 say.bind(tom)은 tom객체를 함수 say의 this로 설정한 새로운 함수를 만들어서 반환합니다.

31. 고차 함수
고차 함수란 함수를 인수로 받는 함수 또는 함수를 반환하는 함수를 말합니다. 자바스크립트의 함수는 일급 객체고 함수의 인수로 함수를 넘길 수 있으며 함수를 반환할 수 있으므로 고차 함수를 쉽게 정의할 수 있습니다. 고차 함수를 사용하면 처리 패턴이 같은 작업을 추상화하여 하나로 합칠 수 있습니다. 고차 함수는 함수형 프로그래밍을 할 때 자주 사용합니다.

32. 함수 f(x)와 g(x)가 있을 때 함수 f(g(x))를 f와 g의 합성 함수라고 합니다.

33. 인수를 여러 개 받는 함수의 몇몇 인수를 상수로 지정해서 새로운 함수를 생성하는 기법을 가리켜 부분 적용이라고 합니다.

34. 커링이란 인수를 두 개 이상 받는 함수를 분해하여 인수가 하나인 함수의 중첩 함수로 변환하는 작업을 말합니다. 커링이라는 이름은 크리스토퍼 스트래치(Christopher Strachey)라는 컴퓨터 과학자가 논리학자인 해스켈 커리(Haskell Curry)의 이름을 따서 지었다고 알려져 있습니다.

35. 화살표 함수의 함수 리터럴은 다음과 같은 차이점이 있습니다.
1) this의 값이 함수를 정의할 때 결정된다.
화살표 함수는 call이나 apply 메서드를 사용하여 this를 바꾸어 호출해도 this 값이 바뀌지 않습니다.
2) arguments 변수가 없다
화살표 함수 안에는 arguments 변수가 정의되어 있지 않으므로 사용할 수 없습니다.
3) 생성자로 사용할 수 없다.
화살표 함수 앞에 new 연산자를 붙여서 호출할 수 없습니다.
4) yield 키워드를 사용할 수 없다.
화살표 함수 안에서는 yield 키워드를 사용할 수 없습니다. 따라서 화살표 함수는 제너레이터로 사용할 수 없습니다.

36. 인수의 기본값
ECMAScript 6부터는 함수의 인자에 대입(=) 연산자를 사용해서 기본값을 설정할 수 있습니다. 기본값을 설정한 인자에 호응하는 인수를 생략하거나 undefined를 넘기면 대입 연산자 우변의 값이 기본값이 됩니다.
function multiply(a, b=1) {
return a*b;
}

37. ECMAScript 6의 이터레이터는 일반적으로 다음 두 가지 항목을 만족하는 객체입니다.
 - next 메서드를 가진다.
 - next 메서드의 반환값은 value 프로퍼티와 done 프로퍼티를 가진 객체이다. 이때 value에는 꺼낸 값이 저장되고 done에는 반복이 끝났는지를 뜻하는 논리값이 저장된다.

38. 일반적으로 for/of 문은 다음 두 가지 조건을 만족하는 객체를 반복 처리합니다.
 - Symbol.iterator 메서드를 가지고 있다.
 - Symbol.iterator 메서드는 반환값으로 이터레이터를 반환한다.
Symbol.iterator 메서드를 가진 객체를 반복 가능(이터러블, iterable)한 객체라고 합니다. 다음 생성자로 생성한 내장 객체는 처음부터 Symbol.iterator 메서드를 내장하고 있습니다. 즉, 반복가능(이터러블)합니다.
 - Array, String, TypedArray, Map, Set

39. 제너레이터
제너레이터는 다음과 같은 성질을 지닌 함수입니다.
-	반복 가능한 이터레이터를 값으로 반환한다.
-	작업의 일시 정지와 재시작이 가능하며 자신의 상태를 관리한다.

40. 제너레이터는 function* 문으로 정의한 함수이며, 하나 이상의 yield 표현식을 포함합니다. 간단한 예로 제너레이터의 메커니즘을 설명하겠습니다.

41. 즉, 제너레이터 함수의 yield는 프로그램이 일시적으로 정지하는 위치입니다. 그리고 제너레이터로 생성한 이터레이터의 next 메서드는 제너레이터 함수의 상태를 일시 정지 상태에서 실행 상태로 바꾸는 역할을 합니다. 이때 이터레이터 객체는 처리를 재개할 수 있도록 제너레이터 함수의 내부 상태를 모두 저장합니다.

42. 템플릿 리터럴 앞에 함수 이름을 적으면 템플릿 리터럴의 내용을 인수로 받는 함수를 호출할 수 있습니다.
func`${a} + ${b} = ${a+b}`

### Chapter 9. 객체

43. 이처럼 자신이 갖고 있지 않은 프로퍼티를 __proto__ 프로퍼티가 가리키는 객체를 차례대로 거슬러 올라가며 검색합니다. 이와 같은 객체의 연결 고리를 프로토타입 체인이라고 합니다.
여기에서 객체 __proto__ 프로퍼티가 가리키는 객체가 바로 상속을 해 준 객체이며, 이 객체를 그 객체의 프로토타입이라고 합니다. 객체는 자신이 가지고 있지 않은 특성(프로퍼티와 메서드)을 프로토타입 객체에 위임(delegate)한다고 할 수 있습니다.

44. 이처럼 자바스크립트는 프로토타입 체인을 사용하여 객체의 프로퍼티를 다른 객체로 전파합니다. 이를 프로토타입 상속이라고 합니다. 프로토타입 상속을 하는 객체 지향 언어를 가리켜 프로토타입 기반 객체 지향 언어라고 합니다.

45. in 연산자는 객체 안에 지명한 프로퍼티가 있는지 검색하며, 그 검색 대상은 그 객체가 소유한 프로퍼티와 상속받은 프로퍼티 모두입니다.

46. hasOwnProperty 메서드는 지명한 프로퍼티가 그 객체가 소유한 프로퍼티면 true를 반환하고 상속 받은 프로퍼티면  false를 반환합니다.

47. Object.keys 메서드는 열거할 수 없는 프로퍼티인 sayHello는 열거하지 않지만 getOwnPropertyNames 메서드는 열거할 수 없는 프로퍼티까지 모두 열거합니다.

48. 얕은 복사와 깊은 복사
얕은 복사(shallow copy)란 객체의 복사본을 만드는 대신 그 객체의 참조만 복사하는 행위를 말합니다. 그렇게 되면 원본과 사본이 같은 객체를 참조하게 됩니다. 반대로 깊은(deep copy)란 객체의 사본을 만들어 다른 메모리 영역에 복사하는 행위를 말합니다.

49. JSON을 사용하면 다른 프로그래밍 언어와 데이터 송수신이 간단해집니다.

50. JSON(JavaScript Object Notation)은 자바스크립트 객체를 문자열로 표현하는 데이터 포맷입니다. JSON을 사용하면 객체를 직렬화할 수 있습니다. 직렬화란 컴퓨터의 메모리 속에 있는 객체를 똑 같은 객체로 환원할 수 있는 문자열로 변환하는 과정을 말합니다.

51. ‘{“name”:”Tom”, “age”:17, “marriage”:false, “data”:[2, 5, null]}’
이처럼 JSON 데이터는 그 전체를 작은따옴표로 묶은 문자열입니다. 이때 객체의 프로퍼티 이름은 큰따옴표로 묶은 문자열로 표기합니다. 숫자, 논리값, 배열은 자바스크립트와 같은 표기법을 사용하지만 문자열은 반드시 큰따옴표로 묶어야 합니다.

52. JSON.stringify 메서드는 인수로 받은 객체를 JSON 문자열로 바꾸어 반환합니다. JSON.stringify 메서드의 사용법은 다음과 같습니다.
JSON.stringify(value[, replacer[, space]])
첫 번째 인수인 value에는 JSON으로 변환할 객체를 지정합니다. 두 번째 인수인 replacer에는 함수 또는 배열을 지정합니다. 두 번째 인수로 함수를 지정하면 문자열로 만든느 프로퍼티의 키와 값을 함수의 인수로 받아서 프로퍼티 값을 표현하는 문자열을 반환합니다. 배열을 지정하면 배열의 요소로 객체의 프로퍼티 이름을 필터링합니다. 세 번째 인수인 space에는 출력하는 문자열을 구분할 때 사용할 공백 문자를 지정합니다.

53. JSON.parse 메서드는 인수로 받은 문자열을 자바스크립트 객체로 환원해서 반환합니다. JSON.parse 메서드의 문법은 다음과 같습니다.
JSON.parse(text[, reviver)

54. 어떠한 상황에서나 깊은 복사를 올바르게 수행하려면 Object.assign 메서드를 사용하세요.

### Chapter 10. 배열의 다양한 기능

55. 형식화 배열
자바스크립트의 배열은 Array 객체입니다. Array 객체는 배열 요소의 추가와 삭제를 동적으로 할 수 있고 다양한 메서드를 이용할 수 있어 편리하지만 배열 요소를 읽고 쓰는 속도가 느리다는 단점이 있습니다. 형식화 배열(TypedArray 객체)은 ArrayBuffer가 확보한 버퍼를 데이터의 저장 장소로 이용하여 데이터의 빠른 읽기와 쓰기를 구현한 객체입니다.

56. Map 객체는 데이터를 수집하여 활용하기 위한 객체입니다. 값의 고유한 식별 정보인 ‘키’와 값의 쌍을 Map 객체 안에 저장해서 사용합니다. Map 객체는 외부에서 키를 사용하여 원하는 값을 추가/삭제/검색할 수 있습니다. 키와 값의 데이터 타입에는 제한이 없습니다. 객체 타입도 사용할 수 있고 원시 타입도 사용할 수 있습니다.

57. 하지만 Map 객체는 Object 객체와 비교했을 때 다음과 같은 차이점이 있습니다.
- Map 객체에는 데이터를 수집하기 위한 다양한 메서드가 마련되어 있다.
- Object 객체는 키로 문자열만 사용할 수 있지만 Map 객체는 키 타입에 제한이 없다.
- Map 객체는 내부적으로 해시 테이블을 활용하기 때문에 데이터 검색 속도가 빠르다.
- Map 객체는 반복 가능(이터러블)하며 for/of 문으로 순회하면 키와 값으로 구성된 배열을 반환한다.
- Map 객체는 데이터 개수를 size 프로퍼티로 구할 수 있다. 하지만 Object 객체는 프로퍼티 개수를 수동으로 계산해야 한다.

WeakMap과 WeakSet
Map이나 Set과 유사한 객체로 WeakMap과 WeakSet을 들 수 있습니다. 이들 객체는 데이터의 키 값을 약한 참조로 관리합니다. 키 값이 약한 참조라는 말은 다른 객체가 참조하고 있는 객체라도 가비지 컬렉션의 대상이 될 수 있다는 뜻입니다. 즉, WeakMap과 WeakSet에 저장된 데이터라 하더라도 키 값으로 사용한 원본 객체를 참조하는 객체가 없어지면 가비지 컬렉션의 대상이 됩니다. WeakMap과 WeakSet에서는 키 값을 약한 참조로 관리하기 때문에 다음과 같은 제약 사항이 있습니다.
-	키 값으로 객체만 사용할 수 있다.
-	키 값 목록은 가져올 수 없다.
-	반복 가능한 객체가 아니므로 for/of문으로는 열거할 수 없다.

