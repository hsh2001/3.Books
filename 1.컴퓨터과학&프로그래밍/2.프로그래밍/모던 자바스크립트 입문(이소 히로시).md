# 모던 자바스크립트 입문
### 지은이 : 이소 히로시
### 출판사 : 길벗
### 읽은 날 : 2020.02.05 ~

### Chapter.1 ~ Chapter.7

1. 반면에 프로그램을 한 줄마다 기계어로 번역해서 실행하는 프로그래밍 언어를 인터프리터 언어라고 하며, 프로그램을 번역해서 실행시키는 소프트웨어를 인터프리터라고 합니다. 자바스크립트는 인터프리터 언어입니다.

2. 프로그램에 직접 작성할 수 있는 상수 값은 리터럴이라고 합니다.

3. 이스케이프 시퀀스

4. const 문으로 선언한 상수 값은 수정할 수 없지만, 상수 값이 객체이거나 배열일 경우에는 프로퍼티 또는 프로퍼티 값을 수정할 수 있습니다.

5. 실제로 msgObj는 실행하는 순간에 일시적으로 생성되는 String 객체이므로 사용자에게는 보이지 않습니다. 처리가 끝나면 곧바로 메모리에서 삭제됩니다. 이러한 객체를 가리켜 래퍼 객체(wrapper object)라고 합니다. 자바스크립트에서는 원시 값을 처리할 때 원시 값을 래퍼 객체로 자동 변환합니다. 그리고 래퍼 객체의 기능을 활용해서 다양한 작업을 수행합니다. 문자열은 String 객체, 숫자는 Number 객체, 논리값은 Boolean 객체로 변환됩니다. 단, null과 undefined에는 래퍼 객체가 없습니다.

6. 자바스크립트의 문자열은 불변(immutable)이라는 점도 기억하세요. Replace와 toUpperCase 메서드 등은 새로운 문자열을 반환하며 메서드를 호출한 문자열은 수정하지 않습니다.

7. 문자열을 읽을 때는 charAt 메서드 대신 대괄호 연산자를 사용할 수 있습니다. 그러나 배열처럼 값을 대입해서 수정할 수는 없습니다. 대입해도 무시됩니다.

8. a && b
A를 평가한 값이 false면 b의 값에 관계없이 표현식 전체 값이 false가 됩니다. 따라서 b의 값을 평가하지 않습니다. 이때 &&연산자는 false 대신에 a의 값 자체를 반환합니다. 또한 a를 평가한 값이 true면 전체 표현식 값이 b의 값으로 경정됩니다. 이때 && 연산자는 true나 false 대신에 b의 값 자체를 반환합니다. 이렇게 작성하더라도 논리값이 필요한 장소에서는 논리값으로 타입이 변환되기 때문에 논리식 자체는 정상적으로 동작합니다.
&& 연산자는 객체의 프로퍼티를 이용할 때와 객체가 null인지 아닌지를 확인하고자 할 때 유용하게 사용됩니다.

9. || 연산자는 여러 개의 값 후보 중에서 null 또는 undefined가 아닌 값을 선택하고자 할 때 유용하게 사용됩니다. 예를 들어 봅시다.
var time = time_interval || animationSetting.time || 33;
이렇게 작성하면 time_interval이 정의되어 있을 때는 time_interval 값을 사용합니다. 정의되지 않았을 때는 animationSettings 객체의 time 프로퍼티를 사용합니다. 이 프로퍼티도 정의되지 않았을 때는 정수(33)를 사용합니다.

10. 대화상자는 모달(modal) 창입니다. 대화상자가 떠 있는 중에는 부모 창의 작업이 일시적으로 정지 상태가 되어 부모 창을 조작할 수 없게 된다는 뜻입니다.

11. 에라토스테네스의 체는 소수를 구하는 알고르즘으로 고대 그리스의 수학자인 에라토스테네스가 고안했다고 알려져 있습니다. 알고리즘은 다음과 같습니다.
-정수 n을 지정하고, 2 이상 n 이하 정수의 목록을 만든다. 가장 작은 수인 2는 소수다.
-그것만 남겨 두고 2의 배수를 목록에서 모두 지운다. 남은 숫자 중 가장 작은 수인 3은 소수다.
-그것만 남겨 두고 3의 배수를 목록에서 모두 지운다.
-이처럼 아직 지우지 않은 가장 작은 수만 남기고 그 배수를 목록에서 지우는 작업을 반복하면 목록에는 소수만 남는다.

12. 라벨을 지정한 break 문은 주로 중첩된 반복문의 안쪽 반복문 안에서 전체 반복문을 빠져나올 때 사용합니다.

### Chapter 9. 객체

13. 이처럼 자신이 갖고 있지 않은 프로퍼티를 __proto__ 프로퍼티가 가리키는 객체를 차례대로 거슬러 올라가며 검색합니다. 이와 같은 객체의 연결 고리를 프로토타입 체인이라고 합니다.
여기에서 객체 __proto__ 프로퍼티가 가리키는 객체가 바로 상속을 해 준 객체이며, 이 객체를 그 객체의 프로토타입이라고 합니다. 객체는 자신이 가지고 있지 않은 특성(프로퍼티와 메서드)을 프로토타입 객체에 위임(delegate)한다고 할 수 있습니다.

14. 이처럼 자바스크립트는 프로토타입 체인을 사용하여 객체의 프로퍼티를 다른 객체로 전파합니다. 이를 프로토타입 상속이라고 합니다. 프로토타입 상속을 하는 객체 지향 언어를 가리켜 프로토타입 기반 객체 지향 언어라고 합니다.

15. in 연산자는 객체 안에 지명한 프로퍼티가 있는지 검색하며, 그 검색 대상은 그 객체가 소유한 프로퍼티와 상속받은 프로퍼티 모두입니다.

16. hasOwnProperty 메서드는 지명한 프로퍼티가 그 객체가 소유한 프로퍼티면 true를 반환하고 상속 받은 프로퍼티면  false를 반환합니다.

17. Object.keys 메서드는 열거할 수 없는 프로퍼티인 sayHello는 열거하지 않지만 getOwnPropertyNames 메서드는 열거할 수 없는 프로퍼티까지 모두 열거합니다.

18. 얕은 복사와 깊은 복사
얕은 복사(shallow copy)란 객체의 복사본을 만드는 대신 그 객체의 참조만 복사하는 행위를 말합니다. 그렇게 되면 원본과 사본이 같은 객체를 참조하게 됩니다. 반대로 깊은(deep copy)란 객체의 사본을 만들어 다른 메모리 영역에 복사하는 행위를 말합니다.

19. JSON을 사용하면 다른 프로그래밍 언어와 데이터 송수신이 간단해집니다.

20. JSON(JavaScript Object Notation)은 자바스크립트 객체를 문자열로 표현하는 데이터 포맷입니다. JSON을 사용하면 객체를 직렬화할 수 있습니다. 직렬화란 컴퓨터의 메모리 속에 있는 객체를 똑 같은 객체로 환원할 수 있는 문자열로 변환하는 과정을 말합니다.

21. ‘{“name”:”Tom”, “age”:17, “marriage”:false, “data”:[2, 5, null]}’
이처럼 JSON 데이터는 그 전체를 작은따옴표로 묶은 문자열입니다. 이때 객체의 프로퍼티 이름은 큰따옴표로 묶은 문자열로 표기합니다. 숫자, 논리값, 배열은 자바스크립트와 같은 표기법을 사용하지만 문자열은 반드시 큰따옴표로 묶어야 합니다.

22. JSON.stringify 메서드는 인수로 받은 객체를 JSON 문자열로 바꾸어 반환합니다. JSON.stringify 메서드의 사용법은 다음과 같습니다.
JSON.stringify(value[, replacer[, space]])
첫 번째 인수인 value에는 JSON으로 변환할 객체를 지정합니다. 두 번째 인수인 replacer에는 함수 또는 배열을 지정합니다. 두 번째 인수로 함수를 지정하면 문자열로 만든느 프로퍼티의 키와 값을 함수의 인수로 받아서 프로퍼티 값을 표현하는 문자열을 반환합니다. 배열을 지정하면 배열의 요소로 객체의 프로퍼티 이름을 필터링합니다. 세 번째 인수인 space에는 출력하는 문자열을 구분할 때 사용할 공백 문자를 지정합니다.

23. JSON.parse 메서드는 인수로 받은 문자열을 자바스크립트 객체로 환원해서 반환합니다. JSON.parse 메서드의 문법은 다음과 같습니다.
JSON.parse(text[, reviver)

24. 어떠한 상황에서나 깊은 복사를 올바르게 수행하려면 Object.assign 메서드를 사용하세요.

### Chapter 10. 배열의 다양한 기능

25. 형식화 배열
자바스크립트의 배열은 Array 객체입니다. Array 객체는 배열 요소의 추가와 삭제를 동적으로 할 수 있고 다양한 메서드를 이용할 수 있어 편리하지만 배열 요소를 읽고 쓰는 속도가 느리다는 단점이 있습니다. 형식화 배열(TypedArray 객체)은 ArrayBuffer가 확보한 버퍼를 데이터의 저장 장소로 이용하여 데이터의 빠른 읽기와 쓰기를 구현한 객체입니다.

26. Map 객체는 데이터를 수집하여 활용하기 위한 객체입니다. 값의 고유한 식별 정보인 ‘키’와 값의 쌍을 Map 객체 안에 저장해서 사용합니다. Map 객체는 외부에서 키를 사용하여 원하는 값을 추가/삭제/검색할 수 있습니다. 키와 값의 데이터 타입에는 제한이 없습니다. 객체 타입도 사용할 수 있고 원시 타입도 사용할 수 있습니다.

27. 하지만 Map 객체는 Object 객체와 비교했을 때 다음과 같은 차이점이 있습니다.
- Map 객체에는 데이터를 수집하기 위한 다양한 메서드가 마련되어 있다.
- Object 객체는 키로 문자열만 사용할 수 있지만 Map 객체는 키 타입에 제한이 없다.
- Map 객체는 내부적으로 해시 테이블을 활용하기 때문에 데이터 검색 속도가 빠르다.
- Map 객체는 반복 가능(이터러블)하며 for/of 문으로 순회하면 키와 값으로 구성된 배열을 반환한다.
- Map 객체는 데이터 개수를 size 프로퍼티로 구할 수 있다. 하지만 Object 객체는 프로퍼티 개수를 수동으로 계산해야 한다.

WeakMap과 WeakSet
Map이나 Set과 유사한 객체로 WeakMap과 WeakSet을 들 수 있습니다. 이들 객체는 데이터의 키 값을 약한 참조로 관리합니다. 키 값이 약한 참조라는 말은 다른 객체가 참조하고 있는 객체라도 가비지 컬렉션의 대상이 될 수 있다는 뜻입니다. 즉, WeakMap과 WeakSet에 저장된 데이터라 하더라도 키 값으로 사용한 원본 객체를 참조하는 객체가 없어지면 가비지 컬렉션의 대상이 됩니다. WeakMap과 WeakSet에서는 키 값을 약한 참조로 관리하기 때문에 다음과 같은 제약 사항이 있습니다.
-	키 값으로 객체만 사용할 수 있다.
-	키 값 목록은 가져올 수 없다.
-	반복 가능한 객체가 아니므로 for/of문으로는 열거할 수 없다.

