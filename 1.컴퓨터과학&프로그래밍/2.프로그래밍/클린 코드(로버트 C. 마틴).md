# 클린 코드(Clean Code) - 애자일 소프트웨어 장인 정신
### 지은이 : 로버트 C. 마틴 (Robert C. Martin)
### 옮긴이 : 박재호, 이해영
### 출판사 : 인사이트
### 읽은 날 : 2020.06.29

## 목차
### 1장. 깨끗한 코드
### 2장. 의미 있는 이름
### 3장. 함수
### 4장. 주석
### 5장. 형식 맞추기
### 6장. 객체와 자료 구조
### 7장. 오류처리
### 8장. 경계
### 9장. 단위 테스트
### 10장. 클래스
### 11장. 시스템
### 12장. 창발성
### 13장. 동시성
### 14장. 점진적인 개선
### 15장. JUnit 들여다보기
### 16장. SerialDate 리팩터링
### 17장. 냄새와 휴리스틱

---
### 1장. 깨끗한 코드
1. 소프트웨어는 80% 이상이 소위 "유지보수다.

2. 기한을 맞추는 유일한 방법은, 그러니까 빨리 가는 유일한 방법은, 언제나 코드를 최대한 깨끗하게 유지하는 습관이다.

3. 코드를 읽는 사람에게 프로그래머가 단호하다는 인상을 줘야 한다.

4. 의도가 분명한 이름이 정말로 중요하다는 사실을 거듭 강조한다.

5. 개인적으로는 간단한 메서드에서 로컬 변수만 한 문자를 사용한다. 이름 길이는 범위 크기에 비례해야 한다. 변수나 상수를 코드 여러 곳에서 사용한다면 검색하기 쉬운 이름이 바람직하다.

6. 똑똑한 프로그래머와 전문가 프로그래머 사이에서 나타나는 차이점 하나만 들자면, 전문가 프로그래머는 명료함이 최고라는 사실을 이해한다. 전문가 프로그래머는 자신의 능력을 좋은 방향으로 사용해 남들이 이해하는 코드를 내놓는다.

### 2장. 의미 있는 이름
7. 클래스 이름  
클래스 이름과 객체 이름은 명사나 명사구가 적합하다. Customer, WikiPage, Account, AddressParser 등이 좋은 예다. Manager, Processor, Data, Info 등과 같은 단어는 피하고, 동사는 사용하지 않는다.

8. 메서드 이름  
메서드 이름은 동사나 동사구가 적합하다. postPayment, deletePage, save 등이 좋은 예다. 접근자(Accessor), 변경자(Mutator), 조건자(Predicate)는 javabean 표준에 따라 값 앞에 get, set, is를 붙인다.

9. 의미를 해독할 책임이 독자에게 있는 논문 모델이 아니라 의도를 밝힐 책임이 저자에게 있는 잡지 모델이 바람직하다.

10. 좋은 이름을 선택하려면 설명 능력이 뛰어나야 하고 문화적인 배경이 같아야 한다. 이것이 제일 어렵다. 좋은 이름을 선택하는 능력은 기술, 비즈니스, 관리 문제가 아니라 교육 문제다. 우리 분야 사람들이 이름 짓는 방법을 제대로 익히지 못하는 이유가 바로 여기에 있다. 

### 3장. 함수
11. 함수를 만드는 첫째 규칙은 '작게!'다. 함수를 만드는 둘째 규칙은 '더 작게!'다.

12. 함수는 한 가지를 해야 한다. 그 한 가지를 잘 해야 한다. 그 한 가지만을 해야 한다.

13. 이름이 길어도 괜찮다. 겁먹을 필요없다. 길고 서술적인 이름이 짧고 어려운 이름보다 좋다. 길고 서술적인 이름이 길고 서술적인 주석보다 좋다.

14. 함수 인수  
함수에서 이상적인 인수 개수는 0개(무항)다. 다음은 1개(단항)고, 다음은 2개(이항)다. 3개(삼항)는 가능한 피하는 편이 좋다. 4개 이상(다항)은 특별한 이유가 필요하다. 특별한 이유가 있어도 사용하면 안 된다.

15. 부수 효과는 거짓말이다. 함수에서 한 가지를 하겠다고 약속하고선 남몰래 다른 짓도 하니까.

16. try/catch 블록은 원래 추하다. 코드 구조에 혼란을 일으키며, 정상 동작과 오류처리 동작을 뒤섞는다. 그러므로 try/catch 블록을 별도 함수로 뽑아내는 편이 좋다.

17. 함수는 '한 가지' 작업만 해야 한다. 오류 처리도 '한 가지' 작업에 속한다. 그러므로 오류를 처리하는 함수는 오류만 처리해야 마땅하다. 함수에 키워드 try가 있다면 함수는 try 문으로 시작해 catch/finally 문으로 끝나야 한다는 말이다.

18. 대가 프로그래머는 시스템을 (구현할) 프로그램이 아니라 (풀어갈) 이야기로 여긴다. 프로그래밍 언어라는 수단을 사용해 좀 더 풍부하고 좀 더 표현력이 강한 언어를 만들어 이야기를 풀어간다. 시스템에서 발생하는 모든 동작을 설명하는 함수 계층이 바로 그 언어에 속한다. 재귀라는 기교로 각 동작은 바로 그 도메인에 특화된 언어를 사용해 자신만의 이야기를 풀어간다.

### 4장. 주석
19. 나쁜 코드에 주석을 달지 마라. 새로 짜라. - 브라이언 W. 커니핸, P.J. 플라우거

20. 잘 달린 주석은 그 어떤 정보보다 유용하다. 경솔하고 근거 없는 주석은 코드를 이해하기 어렵게 만든다. 오래되고 조잡한 주석은 거짓과 잘못된 정보를 퍼뜨려 해악을 미친다.

21. 우리는 코드로 의도를 표현하지 못해, 그러니까 실패를 만회하기 위해 주석을 사용한다.

22. 진심이다. 주석은 언제나 실패를 의미한다.

23. 일반적으로 대다수 주석은 허술한 코드를 지탱하거나, 엉성한 코드를 변명하거나, 미숙한 결정을 합리화하는 등 프로그래머가 주절거리는 독백에서 크게 벗어나지 못한다.

24. 주석으로 처리한 코드만큼 밉살스러운 관행도 드물다.

25. 소스 코드 관리 시스템이 우리를 대신해 코드를 기억해준다. 이제는 주석으로 처리할 필요가 없다. 그냥 코드를 삭제하라. 잃어버릴 염려는 없다. 약속한다.

26. 소스 코드에서 HTML 주석은 혐오 그 자체다.

### 5장. 형식 맞추기
27. 개념은 빈 행으로 분리하라.

28. 연광성이 깊은 두 개념이 멀리 떨어져 있으면 코드를 읽는 사람이 소스 파일과 클래스를 여기저기 뒤지게 된다.

29. 종속함수  
한 함수가 다른 함수를 호출한다면 두 함수는 세로로 가까이 배치한다. 또한 가능하다면 호출하는 함수를 호출되는 함수보다 먼저 배치한다.

30. 첫째 함수에서 가장 먼저 호출하는 함수가 바로 아래 정의된 함수다. 다음으로 호출하는 함수는 그 아래에 정의된다. 그러므로 호출되는 함수를 찾기가 쉬워지며, 그만큼 모듈 전체의 가독성도 높아진다.

31. 팀 규칙  
팀 규칙이라는 제목은 말 장난이다. 프로그래머라면 각자 선호하는 규칙이 있다. 하지만 팀에 속한다면 자신이 선호해야 할 규칙은 바로 팀 규칙이다.

32. 팀은 한 가지 규칙에 합의해야 한다. 그리고 모든 팀원은 그 규칙을 따라야 한다. 그래야 소프트웨어가 일관적인 스타일을 보인다. 개개인이 따로국밥처럼 맘대로 짜대는 코드는 피해야 한다.

### 6장. 객체와 자료 구조
33. (자료 구조를 사용하는) 절차적인 코드는 기존 자료 구조를 변경하지 않으면서 새 함수를 추가하기 쉽다. 반면, 객체 지향 코드는 기존 함수를 변경하지 않으면서 새 클래스를 추가하기 쉽다.

34. 절차적인 코드는 새로운 자료 구조를 추가하기 어렵다. 그러려면 모든 함수를 고쳐야 한다. 객체지향 코드는 새로운 함수를 추가하기 어렵다. 그러려면 모든 클래스를 고쳐야 한다.

35. 분별 있는 프로그래머는 모든 것이 객체라는 생각이 미신임을 잘 안다. 때로는 단순한 자료 구조와 절차적인 코드가 가장 적합한 상황도 있다.

36. 디미터 법칙  
디미터 법칙은 잘 알려진 휴리스틱(heuristic)으로, 모듈은 자신이 조작하는 객체의 속사정을 몰라야 한다는 법칙이다. 앞 절에서 봤듯이, 객체는 자료를 숨기고 함수를 공개한다. 즉, 객체는 조회 함수로 내부 구조를 공개하면 안 된다는 의미다. 그러면 내부 구조를 (숨기지 않고) 노출하는 셈이니까.  
좀 더 정확히 표현하자면, 디미터 법칙은 "클래스 C의 메서드 f는 다음과 같은 객체의 메서드만 호출해야 한다"고 주장한다.

- 클래스 C
- f가 생성한 객체
- f 인수로 넘어온 객체
- C 인스턴스 변수에 저장된 객체

37. 객체는 동작을 공개하고 자료를 숨긴다. 그래서 기존 동작을 변경하지 않으면서 새 객체 타입을 추가하기는 쉬운 반면, 기존 객체에 새 동작을 추가하기는 어렵다. 자료 구조는 별다른 동작 없이 자료를 노출한다. 그래서 기존 자료 구조에 새 동작을 추가하기는 쉬우나, 기존 함수에 새 자료 구조를 추가하기는 어렵다.

38. (어떤) 시스템을 구현할 때, 새로운 자료 타입을 추가하는 유연성이 필요하면 객체가 더 적합하다. 다른 경우로 새로운 동작을 추가하는 유연성이 필요하면 자료 구조와 절차적인 코드가 더 적합하다. 우수한 소프트웨어 개발자는 편견 없이 이 사실을 이해해 직면한 문제에 최적인 해결책을 선택한다.

### 7장. 오류처리
39. null을 전달하지 마라  
메서드에서 null을 반환하는 방식도 나쁘지만 메서드로 null을 전달하는 방식은 더 나쁘다. 정상적인 인수로 null을 기대하는 API가 아니라면 메서드로 null을 전달하는 코드는 최대한 피한다.

### 8장. 경계
40. 시스템에 들어가는 모든 소프트웨어를 직접 개발하는 경우는 드물다. 때로는 패키지를 사고, 때로는 오픈 소스를 이용한다. 때로는 사내 다른 팀이 제공하는 컴포넌트를 사용한다. 어떤 식으로든 이 외부 코드를 우리 코드에 깔끔하게 통합해야만 한다. 이 장에서는 소프트웨어 경계를 깔끔하게 처리하는 기법과 기교를 살펴본다.

41. 외부 코드 사용하기  
인터페이스 제공자와 인터페이스 사용자 사이에는 특유의 긴장이 존재한다. 패키지 제공자나 프레임워크 제공자는 적용성을 최대한 넓히려 애쓴다. 더 많은 환경에서 돌아가야 더 많은 고객이 구매하니까. 반변, 사용자는 자신의 요구에 집중하는 인터페이스를 바란다. 이런 긴장으로 인해 시스템 경계에서 문제가 생길 소지가 많다.

### 9장. 단위 테스트
42. 코드에 유연성, 유지보수성, 재사용성을 제공하는 버팀목이 바로 단위 테스트다. 이유는 단순하다. 테스트 케이스가 있으면 변경이 두렵지 않으니까! 테스트 케이스가 없다면 모든 변경이 잠정적인 버그다. 아키텍처가 아무리 유연하더라도, 설계를 아무리 잘 나눴더라도, 테스트 케이스가 없으면 개발자는 변경을 주저한다. 버그가 숨어들까 두렵기 때문이다.

43. 테스트 당 개념 하나  
어쩌면 "테스트 함수마다 한 개념만 테스트하라"는 규칙이 더 낫겠다. 이것저것 잡다한 개념을 연속으로 테스트하는 긴 함수는 피한다.

44. F.I.R.S.T  
깨끗한 테스트는 다음 다섯 가지 규칙을 따르는데, 각 규칙에서 첫 글자를 따오면 FIRST가 된다.

- 빠르게(Fast) : 테스트는 빨라야 한다. 테스트는 빨리 돌아야 한다는 말이다. 테스트가 느리면 자주 돌릴 엄두를 못 낸다. 자주 돌리지 않으면 초반에 문제를 찾아내 고치지 못한다. 코드를 마음껏 정리하지도 못한다. 결국 코드 품질이 망가지기 시작한다.

- 독립적으로(Independent) : 각 테스트는 서로 의존하면 안 된다.

- 반복가능하게(Repeatable) : 테스트는 어떤 환경에서도 반복 가능해야 한다.

- 자가검증하는(Self-Validating) : 테스트는 부울값으로 결과를 내야 한다. 성공 아니면 실패다.

- 적시에(Timely) : 테스트는 적시에 작성해야 한다. 단위 테스트는 테스트하려는 실제 코드를 구현하기 직전에 구현한다.

### 10장. 클래스
45. 클래스는 작아야 한다!  
클래스를 만들 때 첫 번째 규칙은 크기다. 클래스는 작아야 한다. 두 번째 규칙도 크기다. 더 작아야 한다.

### 11장. 시스템
46. "복잡성은 죽음이다. 개발자에게서 생기를 앗아가며, 제품을 계획하고 제작하고 테스트하기 어렵게 만든다" - 레이 오지(Ray Ozzie), 마이크로소프트 최고 기술 책임자(CTO)

47. '처음부터 올바르게' 시스템을 만들 수 있다는 믿음은 미신이다. 대신에 우리는 오늘 주어진 사용자 스토리에 맞춰 시스템을 구현해야 한다. 내일은 새로운 스토리에 맞춰 시스템을 조정하고 확장하면 된다. 이것이 반복적이고 점진적인 애자일 방식의 핵심이다. 테스트 주도 개발(Test-driven Development, TDD), 리팩터링, (TDD와 리팩터링으로 얻어지는) 깨끗한 ㅋ토드는 코드 수준에서 시스템을 조정하고 확장하기 쉽게 만든다.

### 12장. 창발성
48. 우리들 대다수는 켄트 벡이 제시한 단순한 설계 규칙 네 가지가 소프트웨어 설계 품질을 크게 높열준다고 믿는다.  
켄트 벡은 다음 규칙을 따르면 설계는 '단순하다'고 말한다.
- 모든 테스트를 실행한다.
- 중복을 없앤다.
- 프로그래머 의도를 표현한다.
- 클래스와 메서드 수를 최소로 줄인다.

49. 테스트를 철저히 거쳐 모든 테스트 케이스를 항상 통과하는 시스템은 '테스트가 가능한 시스템'이다. 당연하지만 중요한 말이다. 테스트가 불가능한 시스템은 검증도 불가능하다. 논란의 여지는 있지만, 검증이 불가능한 시스템은 절대 출시하면 안 된다.

50. 우선, 좋은 이름을 선택한다. 이름과 기능이 완전히 딴판인 클래스나 함수로 유지보수 담당자를 놀라게 해서는 안 된다.  
둘째, 함수와 클래스 크기를 가능한 줄인다. 작은 클래스와 작은 함수는 이름짓기도 쉽고, 구현하기도 쉽고, 이해하기도 쉽다.  
셋째, 표준 명칭을 사용한다. 예를 들어, 디자인 패턴은 의사소통과 표현력 강화가 주요 목적이다. 클래스가 COMMAND나 VISITOR와 같은 표준 패턴을 사용해 구현된다면 클래스 이름에 패턴 이름을 넣어준다. 그러면 다른 개발자가 클래스 설계 의도를 이해하기 쉬워진다.  
넷째, 단위 테스트 케이스를 꼼꼼히 작성한다. 테스트 케이스는 소위 '예제로 보여주는 문서'다. 다시 말해, 잘 만든 테스트 케이스를 일어보면 클래스 기능이 한눈에 들어온다.

### 13장. 동시성
51. 객체는 처리의 추상화다. 스레드는 일정의 추상화다. - 제임스 O. 코플리엔(James O. Coplien)

52. 단일 스레드 시스템과 다중 스레드 시스템은 설계가 판이하게 다르다. 일반적으로 무엇과 언제를 분리하면 시스템 구조가 크게 달라진다.

53. 다음은 동시성과 관련된 타당한 생각 몇 가지다.
- 동시성은 다소 부하를 유발한다. 성능 측면에서 부하가 걸리며, 코드도 더 짜야 한다.
- 동시성은 복잡하다. 간단한 문제라도 동시성은 복잡하다.
- 일반적으로 동시성 버그는 재현하기 어렵다. 그래서 진짜 결함으로 간주되지 않고 일회성 문제로 여겨 무시하기 쉽다.
- 동시성을 구현하려면 흔히 근본적인 설계 전략을 재고해야 한다.

### 14장. 점진적인 개선
### 15장. JUnit 들여다보기
### 16장. SerialDate 리팩터링
### 17장. 냄새와 휴리스틱
54. 
#### 주석 
##### C1 : 부적절한 정보
- 일반적으로 작성자, 최종 수정일, SPR(Software Problem Report) 번호 등과 같은 메타 정보만 주석으로 넣는다. 주석은 코드와 설계에 기술적인 설명을 부연하는 수단이다.
##### C2 : 쓸모없는 주석
- 오래된 주석, 엉뚱한 주석, 잘못된 주석은 더 이상 쓸모가 없다. 주석은 빨리 낡는다. 쓸모 없어질 주석은 아예 달지 않는 편이 가장 좋다.
##### C3 : 중복된 주석
##### C4 : 성의 없는 주석
- 주절대지 않는다. 당연한 소리를 반복하지 않는다. 간결하고 명료하게 작성한다.
##### C5 : 주석 처리된 코드

#### 환경
##### E1 : 여러 단계로 빌드해야 한다
- 빌드는 한 단계로 끝나야 한다.
##### E2 : 여러 단계로 테스트해야 한다

#### 함수
##### F1 : 너무 많은 인수
##### F2 : 출력 인수
##### F3 : 플래그 인수
##### F4 : 죽은 함수

#### 일반
##### G1 : 한 소스 파일에 여러 언어를 사용한다
- 이상적으로 소스 파일 하나에 언어 하나만 사용하는 방식이 가장 좋다. 현실적으로는 여러 언어가 불가피하다. 하지만 각별한 노력을 기울여 소스 파일에서 언어 수와 범위를 최대한 줄이도록 애써야 한다.
##### G2 : 당연한 동작을 구현하지 않는다
##### G3 : 경계를 올바로 처리하지 않는다
- 부지런함을 대신할 지름길은 없다. 모든 경계 조건, 모든 구석진 곳, 모든 기벽, 모든 기벽, 모든 예외는 우아하고 직관적인 알고리즘을 좌초시킬 암초다. 스스로의 직관에 의존하지 마라. 모든 경계 조건을 찾아내고, 모든 경계 조건을 테스트하는 테스트 케이스를 작성하라.
##### G4 : 안전 절차 무시
##### G5 : 중복
- 가장 뻔한 유형은 똑같은 코드가 여러 차례 나오는 중복이다. 프로그래머가 미친듯이 마우스로 긁어다 여기저기로 복사한 듯 보이는 코드다. 이런 중복은 간단한 함수로 교체한다. 
- 좀 더 미묘한 유형은 여러 모듈에서 일련의 switch/case나 if/else문으로 똑같은 조건을 거듭 확인하는 중복이다. 이런 중복은 다형성(polymorphism)으로 대체해야 한다.
- 더더욱 미묘한 유형은 알고리즘이 유사하나 코드가 서로 다른 중복이다. 중복은 중복이므로 TEMPLATE METHOD 패턴이나 STRATEGY 패턴으로 중복을 제거한다.
* TEMPLATE METHOD, STRATEGY 패턴 --> GOF 디자인 패턴 참조
##### G6 : 추상화 수준이 올바르지 못하다
##### G7 : 기초 클래스가 파생 클래스에 의존한다
##### G8 : 과도한 정보
##### G9 : 죽은 코드
##### G10 : 수직 분리
- 변수와 함수는 사용되는 위치에 가깝게 정의한다.
##### G11 : 일관성 부족
##### G12 : 잡동사니
##### G13 : 인위적 결합
##### G14 : 기능 욕심
- 클래스 메서드는 자기 클래스의 변수와 함수에 관심을 가져야지 다른 클래스의 변수와 함수에 관심을 가져서는 안된다.
##### G15 : 선택자 인수
##### G16 : 모호한 의도
##### G17 : 잘못 지운 책임
##### G18 : 부적절한 static 함수
##### G19 : 서술적 변수
- 켄트 벡이 Smalltalk Best Practice Patters라는 훌륭한 책과 Implementation Patters라는 훌륭한 책에서 지적하는 문제다.
##### G20 : 이름과 기능이 일치하는 함수
##### G21 : 알고리즘을 이해하라
##### G22 : 논리적 의존성은 물리적으로 드러내라
##### G23 : If/Else 혹은 Switch/Case 문보다 다형성을 사용하라
- 첫째, 대다수 개발자가 switch 문을 사용하는 이유는 그 상황에서 가장 올바른 선택이기보다는 당장 손쉬운 선택이기 때문이다. 그러므로 switch를 선택하기 전에 다형성을 먼저 고려하라는 의미다.
- 둘째, 유형보다 함수가 더 쉽게 변하는 경우는 극히 드물다. 그러므로 모든 switch 문을 의심해야 한다.
##### G24 : 표준 표기법을 따르라
##### G25 : 매직 숫자는 명명된 상수로 교체하라
- 아마 소프트웨어 개발에서 가장 오래된 규칙 중 하나라 여겨진다.
- 일반적으로 코드에서 숫자를 사용하지 말라는 규칙이다. 숫자는 명명된 상수 뒤로 숨기라는 의미다.
##### G26 : 정확하라
##### G27 : 관례보다 구조를 사용하라
##### G28 : 조건을 캡슐화하라
##### G29 : 부정 조건은 피하라
##### G30 : 함수는 한 가지만 해야 한다
##### G31 : 숨겨진 시각적인 결합
##### G32 : 일관성을 유지하라
##### G33 : 경계 조건을 캡슐화하라
- 코드 여기저기에 +1이나 -1을 흩어놓지 않는다.
- level + 1이 두 번 나온다. 이런 경계 조건은 변수로 캡슐화하는 편이 좋다. 변수 이름은 nextLevel이 적합하겠다.
##### G34 : 함수는 추상화 수준을 한 단계만 내려가야 한다
##### G35 : 설정 정보는 최상위 단계에 둬라
##### G36 : 추이적 탐색을 피하라

#### 이름
##### N1 : 서술적인 이름을 사용하라
- 소프트웨어 가독성의 90%는 이름이 결정한다.
##### N2 : 적절한 추상화 수준에서 이름을 선택하라
##### N3 : 가능하다면 표준 명명법을 사용하라
##### N4 : 명확한 이름
##### N5 : 긴 범위는 긴 이름을 사용하라
##### N6 : 인코딩을 피하라
##### N7 : 이름으로 부수 효과를 설명하라

#### 테스트
##### T1 : 불충분한 테스트
##### T2 : 커버리지 도구를 사용하라!
##### T3 : 사소한 테스트를 건너뛰지 마라
##### T4 : 무시한 테스트는 모호함을 뜻한다
##### T5 : 경계 조건을 테스트하라
##### T6 : 버그 주변은 철저히 테스트하라
##### T7 : 실패 패턴을 살펴라
##### T8 : 테스트 커버리지 패턴을 살펴라
##### T9 : 테스트는 빨라야 한다