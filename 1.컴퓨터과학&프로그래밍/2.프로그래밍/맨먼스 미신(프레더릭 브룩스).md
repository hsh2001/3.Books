# 맨먼스 미신(The Mythical Man-Month) - 소프트웨어 공학에 관한 에세이
### 지은이 : 프레더릭 P. 브룩스 2세 (Frederick P. Brooks Jr.)
### 옮긴이 : 강중빈
### 출판사 : 인사이트
### 읽은 날 : 2020.06.25

1. 프로그래밍의 즐거움  
- 첫 번째는 무언가를 만드는 데서 오는 순전한 기쁨이다.
- 두 번째는 다른 이들에게 쓸모 있는 사물을 만드는 데서 오는 기쁨일 것이다.
- 세 번째는 서로 맞물려 돌아가는 부속품으로 이루어진 복잡한 퍼즐 같은 사물을 만들고, 거기 심어 놓은 여러 가지 법칙이 미묘한 순환 속에서 펼쳐지는 것을 바라보는 매혹적인 경험이다.
- 네 번째는 지속적인 배움에서 오는 기쁨이다.
- 마지막 즐거움은, 너무도 유연하고 다루기 쉬운 표현 수단으로 작업하는 데서 오는 기쁨이다. 프로그래머의 작업은 시인과 마찬가지로 순수한 사고의 산물에 가깝다.

2. 프로그래밍의 고달픔  
- 먼저, 프로그래밍에는 완벽함이 요구된다.
- 다음으로, 나 아닌 다른 이들이 내 목표를 설정하고 자원과 정보를 제공한다는 점을 들 수 있다.
- 다음 문제는, 장대한 개념을 설계하는 것은 재미있지만 사소한 버그를 잡는 것은 그냥 일에 지나지 않는다는 것이다.
- 마지막으로 들 수 있는 고달픔이자 가끔 최후의 결정타가 되기도 하는 것은, 오랜 시간 동안 힘들여 만든 제품이 완성되었을 때 (또는 그러기도 전에) 이미 한물간 것으로 치부되어 버리는 일이다.

3. 맨먼스(man-month)라는 단위다. 물론 프로젝트 비용은 투입된 사람 수와 달수의 곱에 따라 변한다. 하지만 작업 진척도는 그렇지가 않다. 그러므로 맨먼스 단위로 작업량을 잰다는 것은 위험하고도 기만적인 미신과 같다. 거기에는 사람과 일정이 서로 교환 가능하다는 인식이 깔려 있다.

4. 나는 몇 년간 소프트웨어 프로젝트 일정을 관리하면서 다음과 같은 나름의 법칙을 세워 성공리에 적용해 왔다.
- 계획 수립 : 1/3
- 코딩 : 1/6
- 구성 요소 테스트와 초기 시스템 테스트 : 1/4
- 모든 구성 요소가 준비된 후의 시스템 테스트 : 1/4

5. "늦어진 소프트웨어 프로젝트에 인력을 추가로 투입하면 더 늦어지게 된다."

6. 프로젝트에 소요되는 기간은 순서대로 처리해야 하는 내부 요소에 좌우되며, 필요한 최대 인원수는 독립된 하위 작업의 개수에 좌우된다.

7. 뛰어난 프로그래머들과 좀 처지는 이들 간에 상당한 생산성 차이가 있다는 것을 관리자들은 오래전부터 알고 있었다. 하지만 수치로 나타난 구체적인 결과는 모두를 경악시켰다. 색먼(Sackman), 에릭슨(Erikson), 그랜트(Grant)는 어떤 연구에서 경력직 프로그래머들을 대상으로 생산성을 측정했는데, 이 그룹 안에서만도 가장 뛰어난 사람과 가장 못한 사람의 생산성 비율이 평균 10:1인데다, 실행 속도와 사용 공간 면에서는 무려 다섯 배의 차이가 난 것이다. 간단히 말하면 연봉 2만 달러 받는 프로그래머가 1만 달러 받는 이에 비해 열 배의 생산성을 발휘할 수도 있다는 얘기다. 물론 그 반대의 경우도 가능하다. 이 연구의 데이터에서는 경력 연차와 성과 사이에 어떤 상관관계도 없었다(내 생각에 이것이 일반적이지는 않을 것 같다).

8. 밀스 아이디어에 필수불가결한 것은 프로그래밍이라는 작업을 "개인적인 예술에서 공개적인 실행으로" 바꾸는 것이다. 이것은 컴퓨터에서 작업이 실행되는 전 과정을 팀의 멤버 누구나 볼 수 있게 하고, 모든 프로그램과 데이터가 개인이 아닌 팀 소유임을 명확히 함으로써 가능하다.

9. 아키텍처를 구현으로부터 분리하는 것은, 초대형 프로젝트에서 개념적 일관성을 달성할 수 있는 아주 효과적인 방법이다.

10. 시스템의 '아키텍처'라고 하는 것은, 사용자 인터페이스의 완전하고 상세한 명세를 의미한다. 컴퓨터라면 이것은 프로그래밍 매뉴얼에 해당할 것이고, 컴파일러라면 언어 매뉴얼, 제어 프로그램은 대상 기능을 작동시키기 위한 언어들의 매뉴얼일 것이다. 전체 시스템의 경우에는, 사용자가 자기 업무를 수행하기 위해 참고해야 하는 모든 매뉴얼의 집합이 된다.

11. 나는 오직 아키텍트들만이 설계에 대해 좋은 아이디어를 낼 거라고 주장하려는 것이 결코 아니다. 참신한 생각이 구현자나 사용자에게서 비롯되는 경우도 가끔 있다. 그러나 내가 여태껏 경험해 왔고 또 보여주고자 했던 바는, 시스템의 개념적 일관성이 사용의 용이성을 결정한다는 것이다. 아무리 훌륭한 기능이나 아이디어라 해도 시스템의 기본 개념에 들어 맞지 않는다면 배제하는 것이 상책이다. 이처럼 중요하지만 어울리지 않는 개념이 다수 발견된다면, 전체 설계를 폐기하고 기본 개념을 달리해서 새로 시작하는 편이 낫다.

12. 마찬가지로 나는 외부로부터 아키텍처가 주어진다는 사실이 구현 담당 그룹의 창조성을 저해하는 것이 아니라 더 높인다고 생각한다. 구현자들은 그 즉시 문제 안에서 누구도 다루지 않았던 부분에 초점을 맞출 것이며 거기에서 독창성이 솟아나기 시작한다. 제약이 주어지지 않은 구현 그룹에서는 대부분의 고민과 토론이 아키텍처 결정에 관한 방향으로 흘러가며, 본래 의미의 구현 작업은 관심에서 멀어지게 된다.

13. 아키텍트의 첫 작품은 단출하고 깔끔한 경향이 있다. 자신이 무엇을 하는지 스스로도 잘 모른다는 것을 알고 있기에, 일을 함에 있어 조심스러우며 대단히 자제하게 된다.

14. 두 번째 시스템에 대한 일반적인 경향은, 첫 번째를 만들면서 조심스레 한편으로 밀쳐두었던 온갖 아이디어와 장식을 도입하여 설계가 과도해진다는 것이다.

15. 매뉴얼, 또는 문서화된 명세는 충분하지는 않더라도 필요한 도구다. 매뉴얼은 제품에 대한 '외부적인' 명세로, 사용자가 보게 되는 모든 세부 사항을 기술하고 규정한다. 따라서 이것은 아키텍트의 가장 주요한 산출물이다.

16. 매뉴얼은 인터페이스를 비롯해서 사용자가 보는 모든 것을 기술해야 하며, 사용자가 보지 않는 부분은 기술하기를 자제해야 한다. 그 부분은 구현자의 소관이며, 설계의 자유를 그 안에서 마음껏 펼칠 수 있어야 한다. 아키텍트는 자신이 기술하는 모든 기능에 대해 구현 방안 한 가지는 제시할 수 있도록 항상 준비해야 하지만, 실제 구현이 이루어지는 방안을 지시하려고 해서는 안 된다.

17. 조직이란 현재 있는 사람들을 중심에 두고 구성하는 것이지, 이론적인 조직에다가 사람들을 끼워 맞춰서는 안 된다.

18. 생각하는 사람은 드물고, 행동하는 사람은 더 드물며, 생각하면서 행동하는 사람은 가장 희귀하다.

19. 왜 형식을 갖춘 문서를 만드는가?  
- 첫 번째 이유는, 결정된 사항을 글로 적는 것이 필수불가결하기 때문이다.
- 두 번째 이유는, 결정된 내용을 그 문서를 통해 다른 이들에게 알릴 수 있기 때문이다.
- 끝으로, 관리자의 문서들은 데이터베이스와 체크리스트 역할을 하기 때문이다.

20. 그러므로 우리가 해야 할 질문은 파일럿 시스템을 만든 다음에 '버릴 것이냐 말 것이냐'가 아니다. 그 일은 '어차피' 일어날 것이다. 유일하게 할 수 있는 질문은, 버릴 시스템을 만들기 위해 미리 계획을 세울 것인가, 아니면 그것을 고객에게 납품하겠다고 약속할 것인가이다. 이런 관점에서 보면 답은 아주 분명해진다. 버릴 것을 고객에게 납품할 경우 시간은 벌 수 있겠지만 그 대가는 비싸다. 사용자는 힘들어 할 것이고, 개발진은 재설계를 동시에 진행하느라 정신없을 것이며, 제품의 명성은 아무리 최선을 다해 재설계를 해도 만회하기 어려운 상처를 입을 것이다.  
그러므로 버리기 위한 계획을 세우라. 어쨌거나 버리게 될 것이다.

21. 그럼에도 불구하고 코스그로브는 뛰어난 통찰을 보여준다. 그는 설계를 문서화하는 것이 잘되지 않는 이유가 단순히 게으르거나 시간이 모자라서가 아니라고 말한다. 오히려, 현재의 결정 사항이 언제든 변경될 수 있음을 알기에 설계자가 그것을 애써 방어하려 하지 않기 때문이다. "설계를 문서화함으로써 설계자는 모든 이의 비판에 스스로를 노출시키게 되며, 이제 자신이 작성한 모든 것을 방어할 수 있어야 한다. 만약 조직 구조가 어떤 면에서든 위압적인 상황이라면, 완벽한 방어가 가능해질 때까지 그 어떤 내용도 문서화되지 않을 것이다."

22. 널리 쓰이는 프로그램을 유지 보수하는 비용은 통상 개발 비용의 40% 또는 그 이상이다.

23. 프로그램 유지 보수의 근본적인 문제는, 결함을 수정할 때 상당한(20~50%) 확률로 또 다른 결함이 유입된다는 것이다. 그러므로 전체 과정은 두 걸음 전진 후에 한 걸음 후퇴가 된다.

24. 시스템 프로그램을 만드는 일은 엔트로피를 감소시키는 과정이므로 본질적으로 준안정적인 상태다. 프로그램 유지 보수는 엔트로피를 증가시키는 과정이고, 아무리 능숙하게 수행된다 해도 시스템이 수리불가의 구닥다리가 되는 것을 잠시 늦출 수 있을 뿐이다.

25. 나쁜 기초 설계를 버리지 못하고 온갖 장식을 덧대어 가려 보려는 시도에서 수많은 조잡한 시스템이 생겨난다. 하향식 설계는 그런 유혹을 누그러뜨린다.

26. 이해하지 못하는 것을 소유할 수는 없다. -괴테(Goethe)

27. 소프트웨어의 생산성, 신뢰성, 단순성에 대한 가장 강력한 일격은, 물론 프로그래밍에 고급 언어를 점진적으로 사용하게 된 것이다. 많은 이들이 그로 인해 최소 다섯 배의 생산성 향상 및 신뢰성, 단순성, 이해 가능성 측면의 부차적인 이득이 있었다고 본다.

28. 자동 프로그래밍이라는 것은 늘 그 당시의 프로그래머가 사용할 수 있었던 것보다 더 높은 수준의 언어로 이루어지는 프로그래밍에 대한 완곡한 표현이었다.

29. 소프트웨어를 만든다는 문제에 대한 가장 급진적인 해결책은, 아예 만들지 않기로 하는 것이다.

30. 잠시 돌아보면, 위원회에 의해 설계되고 복수의 프로젝트를 통해 구현된 쓸 만한 소프트웨어 시스템이 많기는 하지만, 열성 팬들을 흥분시킨 소프트웨어는 한 명 또는 소수의 탁월한 설계자가 만들어낸 것들이었다. 유닉스, APL, 파스칼, 모듈라, 스몰토크(Smalltalk)의 인터페이스, 심지어는 포트란을 한번 생각해 보라. 그와 비교해서 코볼, PL/I, 알골, MVS/370, MS-DOS는 어떤가?

31. 소프트웨어에 관련된 조직이라면 어느 곳이든 이 시험대를 무시할 수 없다. 좋은 관리자는 찾기 어렵지만 좋은 설계자보다 더 드물지는 않다. 탁월한 설계자와 탁월한 관리자는 모두 대단히 드물다. 대부분의 조직이 유망한 관리자를 발굴하고 양성하는 일에 많은 노력을 기울이고 있다. 그러나 제품의 기술적 탁월함을 좌우할 뛰어난 설계자를 발굴하고 키워나가는 일에 그만한 노력을 쏟는 조직은 본 적이 없다.

32. 해결할 수 없는 문제가 존재한다는 사실을 받아들이는 데에는 많은 노력이 필요하다. 탈출구를 찾고자 하는 바람은, 심지어 그런 것은 존재하지 않음이 증명된 경우라 해도 아주 강렬하다. 우리 대부분은 그처럼 불가능한 것에 도전하는 용감한 사람들에게 큰 연민을 느낀다 - 투르스키(Turski)

33. 그(케이퍼스 존스, Capers Jones)는 비용이 많이 들고 기한에 뒤처진 프로젝트들은, 추가로 투입되는 노력과 시간의 대부분을 명세와 설계와 구현상의 오류들을 찾고 고치는 데 소비한다고 주장한다. 또한 그는 체계적 품질 관리의 부재와 일정 붕괴 사이에 강한 상관관계가 있음을 보여주는 데이터를 제시한다. 나는 그것을 믿는다.

34.  
- 사람들은 문장의 문맥 속에서 언어를 배운다. 따라서 우리는 부품에 해당하는 라이브러리뿐 아니라 그것들이 조합된 제품 사례도 많이 공유할 필요가 있다.
- 사람들은 철자 외에 아무것도 암기하지 않는다. 문법이나 의미는 문맥 속에서 실제로 단어를 사용하며 점진적으로 배운다.
- 사람들은 호환되는 객체들의 하위 집합이 아니라 문법적 클래스에 의해 단어 조합 규칙을 분류한다.

35. 그런 관점은, 코드의 모듈이 잘 정의된 인터페이스로 캡슐화되어야 하며, 모듈 내부 구조는 담당한 프로그래머의 사유물로서 외부에 노출되지 않아야 한다는 파르타스의 주장과 극명한 대조를 이룬다. 프로그래머들은 자기 것이 아닌 모듈의 내부 구조에 노출될 때가 아니라 그로부터 차단될 때 가장 효율적이 된다.

36. 나는 7장에서 파르나스의 개념을 "재앙을 부르는 일"이라고 묵살했었다. 그가 옳았고, 내가 틀렸다. 이제 나는, 오늘날 객체 지향 프로그래밍에 종종 포함되는 정보의 은닉이야말로 소프트웨어 설계 수준을 높일 수 있는 유일한 방법이라 확신한다.

37. '보조적 기능의 원리'가 가르치는 바는, 하부 구조의 자유와 책임이 신중하게 유지될 때 중심부는 권위와 능률면에서 이득을 얻고 결과적으로 조직 전체가 "더 행복해지며 번영"한다는 것이다.

38. 더 이상 업무 환경 탓을 하기는 어려울 정도로 하드웨어가 발전하였으니, 이제 컴퓨터를 가지고 과연 무엇을 하느냐가 중요한 시대가 된 듯하다.

39. 이제 컴퓨터의 메모리에는 한 개가 아닌 여러 개의 프로그램이 올라간다(멀티프로그래밍). 운영 체제는 날므의 규칙에 따라 각 프로그램을 돌아가며 실행하지만(스케줄링), 그 속도가 워낙 빠른 탓에 해당 프로그램을 실행하고 있는 인간 사용자들은 컴퓨터가 자신만을 위해 일한다고 느낀다. 컴퓨터 시간을 여러 명이 나누어서 쓴다고 하여, 이것을 시분할(time-sharing) 방식이라고 부른다. 현대에 와서는 운영 체제 기능이 고도화되면서 사용자가 한 명인 컴퓨터라도 동시에 여러 개의 작업이 실행되는데, 이것은 멀티태스킹이라고 한다.