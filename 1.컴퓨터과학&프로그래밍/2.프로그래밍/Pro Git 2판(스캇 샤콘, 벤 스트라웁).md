# Pro Git 2판
### 지은이 : 스캇 샤콘(Scott Chacon), 벤 스타라웁(Ben Straub)
### 옮긴이 : 박창우
### 출판사 : 옮긴이
### 읽은 날 : 2020.07.07 ~ 
---
### 1장. 시작하기
### 2장. Git의 기초
### 3장. Git 브랜치
### 4장. Git 서버
### 5장. 분산 환경에서의 Git
### 6장. GitHub
### 7장. Git 도구
### 8장. Git 맞춤
### 9장. Git과 여타 버전 관리 시스템
### 10장. Git의 내부
### 부록A. 다양한 환경에서 Git 사용하기
### 부록B. 애플리케이션에 Git 넣기
### 부록C. Git 명령어
---
### 1장. 시작하기
1. Git은 BitKeepper를 사용하면서 배운 교훈을 기초로 아래와 같은 목표를 세웠다.
- 빠른 속도
- 단순한 구조
- 비선형적인 개발(수천 개의 동시다발적인 브랜치)
- 완벽한 분산
- 리눅수 커널 같은 대형 프로젝트에도 유용할 것(속도나 크기 면에서)

2. 대신 Git은 데이터를 파일 시스템 스냅샷으로 취급하고 크기가 아주 작다. Git은 커밋하거나 프로젝트의 상태를 저장할 때마다 파일이 존재하는 그 순간을 중요하게 여긴다.

3. Git은 데이터를 스냅샷의 스트림처럼 취급한다.

4. Git은 프로젝트의 히스토리를 조회할 때 서버 없이 조회한다. 그냥 로컬 데이터베이스에서 히스토리를 읽어서 보여 준다. 그래서 눈 깜짝할 사이에 히스토리를 조회할 수 있다.

5. Git은 SHA-1 해시를 사용하여 체크섬을 만든다.

6. Committed란 데이터가 로컬 데이터베이스에 안전하게 저장됐다는 것을 의미한다. Modified는 수정한 파일을 아직 로컬 데이터베이스에 커밋하지 않은 것을 말한다. Staged란 현재 수정한 파일을 곧 커밋할 것이라고 표시한 상태를 의미한다.

7. Git 디렉터리가 Git의 핵심이다. 다른 컴퓨터에 있는 저장소를 Clone할 때 Git 디렉터리가 만들어진다.

8. Git으로 하는 일은 기본적으로 아래와 같다.
- 1. 워킹 디렉터리에서 파일을 수정한다.
- 2. Staging Area에 파일을 Stage에 커밋할 스냅샷을 만든다.
- 3. Staging Area에 있는 파일들을 커밋해서 Git 디렉터리에 영구적인 스냅샷으로 저장한다.

9. Git의 모든 기능을 지원하는 것은 CLI 뿐이다.

10. `git config`라는 도구로 설정 내용을 확인하고 변경할 수 있다.
- 1. `/etdc/gitcofig` 파일 : 시스템의 모든 사용자와 모든 저장소에 적용되는 설정이다. `git config --system` 옵션으로 이 파일을 읽고 쓸 수 있다.
- 2. `~.gitconfig`, `~/.config/git/config` 파일 : 특정 사용자에게만 적용되는 설정이다. `git config --global` 옵션ㅇ로 이 파일을 ㅇ릭고 쓸 수 있다.
- 3. `.git/config` 파일 : Git 디렉터리에 있고 특정 저장소(혹은 현재 작업 중인 프로젝트)에만 적용된다.

11. Git을 설치하고 나서 가장 먼저 해야 하는 것은 사용자 읾과 이메일 주소를 설정하는 것이다. Git은 커밋할 때마다 이 정보를 사용한다.
- `$ git config [--global] user.name "John Doe"`
- `$ git config [--global] user.email johndoe@example.com`

12. `git config --list` 명령을 실행하면 설정한 모든 것을 보여준다.

13. `git config <key>` 명령으로 Git이 특정 Key에 대해 어떤 값을 사용하는지 확인할 수 있다.

### 2장. Git의 기초
14. Git 저장소를 만드는 방법은 두 가지다. 기존 프로젝트나 디렉터리를 Git 저장소로 만드는 방법이 있고, 다른 서버에 있는 저장소를 Clone하는 방법이 있다.

15. `$ git init`  
이 명령은 .git이라는 하위 디렉터리를 만든다. .git 디렉터리에는 저장소에 필요한 뼈대 파일이 들어 있다. 이 명령만으로는 아직 프로젝트의 어떤 파일도 관리하지 않는다.

16. 파일 상태를 짤막하게 확인하기  
- `git status -s` 또는 `git status --short`

17. .gitignore 파일에 입력하는 패턴은 아래 규칙을 따른다.
- 아무것도 없는 라인이나, #로 시작하는 라인은 무시한다.
- 표준 Glob 패턴을 사용한다.
- 슬래시(/)로 시작하면 하위 디렉터리에 적용되지(recursivity) 않는다.
- 디렉터리는 슬래시(/)를 끝에 사용하는 것으로 표현한다.
- 느낌표(!)로 시작하는 패턴의 파일은 무시하지 않는다.

18. 단순히 파일이 변경됐다는 사실이 아니라 어떤 내용이 변경됐는지 살펴보려면 `git status` 명령이 아니라 `git diff` 명령을 사용해야 한다.

19. `git diff` 명령을 실행하면 수정했지만 아직 staged 상태가 아닌 파일을 비교해 볼 수 있다. 

20. 만약 커밋하려고 Staging Area에 넣은 파일의 변경 부분을 보고 싶으면 `git diff --staged` 옵션을 사용한다.

21. 꼭 잊지 말아야 할 것이 있는데 `git diff` 명령은 마지막으로 커밋한 후에 수정한 것들 전부를 보여주지 않는다. `git diff`는 Unstaged 상태인 것들만 보여준다. 이 부분이 조금 헷갈릴 수 있다. 수정한 파일을 모두 Staging Area에 넣었다면 git diff 명령은 아무것도 출력하지 않는다.

22. Staged 상태인 파일은 `git diff --cached` 옵션으로 확인한다. `--staged`와 `--cached`는 같은 옵션이다.

23. 아주 쉽게 Staging Area를 생략할 수 있다. git commit 명령을 실행할 때 `-a` 옵션을 추가하면 Git은 Tracked 상태의 파일을 자동으로 Staging Area에 넣는다. 그래서 git add 명령을 실행하는 수고를 덜 수 있다.

24. Git에서 파일을 제거하려면 `git rm` 명령으로 Tracked 상태의 파일을 삭제한 후에(정확하게는 Staging Area에서 삭제하는 것) 커밋해야 한다. 이 명령은 워킹 디렉터리에 있는 파일도 삭제하기 때문에 실제로도 파일이 지워진다.

25. 또 Staging Area에서만 제거하고 워킹 디렉터리에 있는 파일은 지우지 않고 남겨둘 수 있다.

26. 이렇게 말하고 Git에 `mv` 명령이 있는 게 좀 이상하겠지만, 아래와 같이 파일이름을 변경할 수 있다.
- `git mv file_from file_to`

27. 사실 `git mv` 명령은 아래 명령어를 수행한 것과 완전 똑같다.
- `mv README.md README`
- `git rm README.md`
- `git add README`

28. Git에는 히스토리를 조회하는 명령어인 `git log`가 있다.

29. `-p`는 각 커밋의 diff 결과를 보여준다. 다른 유용한 옵션으로 -2가 있는데 최근 두 개의 결과만 보여주는 옵션이다.

30. `--stat` 옵션으로 각 커밋의 통계 정보를 조회할 수 있다.

31. 또 다른 유용한 옵션은 `--pretty` 옵션이다. 이 옵션을 통해 히스토리 내용을 보여줄 때 기본 형식 이외에 여러 가지 중 하나를 선택할 수 있다.

32. 저자는 원래 작업을 수행한 원작자이고 커미터는 마지막으로 이 작업을 적용한 (저장소에 포함한) 사람이다.

33. `oneline`과 `format` 옵션은 `--graph` 옵션과 함께 사용할 때 더 빛난다.

34. 반면 `--since`나 `--until` 같은 시간을 기준으로 조회하는 옵션은 매우 유용하다. 지난 2주 동안 만들어진 커밋들만 조회하는 명령으 아래와 같다.
- `$ git log --since=2.weeks`

35. 진짜 유용한 옵션으로 `-S`가 있는데 이 옵션은 코드에서 추가되거나 제거된 내용 중에 특정 텍스트가 포함되어 있는지를 검색한다.
- `$ git log --Sfunction_name`

36. 종종 완료한 커밋을 수정해야 할 때가 있다. ... 다시 커밋하고 싶으면 `--amend 옵션`을 사용한다.
- `$ git commit --amend`

37. `git reset HEAD <file>` 명령으로 Unstaged 상태로 변경할 수 있다.

38. `git reset` 명령을 `--hard` 옵션과 함께 사용하면 워킹 디렉터리 파일까지 수정되기에 조심해야 한다. `--hard` 옵션만 사용하지 않는다면 `git reset` 명령은 Staging Area의 파일만 조작하기 때문에 위험하지 않다.

39. Modified 파일 되돌리기  
`git checkout -- [file]` 명령은 꽤 위험한 명령이라는 것을 알아야 한다. 원래 파일로 덮어썼기 때문에 수정한 내용은 전부 사라진다. 수정한 내용이 진짜 마음에 들지 않을 때만 사용하자.

40. Git으로 커밋한 모든 것은 언제나 복구할 수 있다. 삭제한 브랜치에 있었던 것도, --amend 옵션으로 다시 커밋한 것도 복구할 수 있다 ... 하지만 커밋하지 않고 잃어버린 것을 절대로 되돌릴 수 없다.

41. 리모트 저장소에서 데이터를 가져오렴ㄴ 간단히 아래와 같이 실행한다.
- `$ git fetch [remote-name]`
이 명령은 로컬엔ㄴ 없지만, 리모트 저장소에 있는 데이터를 모두 가져온다. 그러면 리모트 저장소의 모든 브랜치를 로컬에서 접근할 수 있어서 언제든지 Merge를 하거나 내용을 살펴볼 수 있다.  

42. 저장소를 Clone하면 명령은 자동으로 리모트 저장소를 "origin"이라는 이름으로 추가한다. 그래서 나중에 `git fetch origin`을 실행하면 Clone한 이후에(혹은 마지막으로 가져온 이후에) 수정된 것을 모두 가져온다.

43. 그냥 쉽게 `git pull` 명령으로 리모트 저장소 브랜치에서 데이터를 가져올 뿐만 아니라 자동으로 로컬 브랜치와 Merge시킬 수 있다.

44. 먼저 `git clone` 명령은 자동으로 로컬의 master 브랜치가 리모트 저장소이 master 브랜치를 추적하도록 한다(물론 리모트 저장소에 master 브랜치가 있다는 가정에서) 그리고 git pull 명령은 Clone한 서버에서 데이터를 가져오고 그 데이터를 자동으로 현재 작업하는 코드와 Merge시킨다.

45. 프로젝트를 공유하고 싶을 때 Upstream 저장소에 Push할 수 있다. 이 명령은 `git push [리모트 저장소 이름] [브랜치 이름]으로 단순하다.`

46. 태그  
다른 VCS처럼 Git도 태그를 지원한다. 사람들은 보통 릴리스할 때 사용한다.(v1.0, 등등)

47. 태그 조회하기  
우선 `git tag` 명령으로 이미 만들어진 태그가 있는지 확인할 수 있다.

48. 만약 1.8.5 버전의 태그들만 검색하고 싶으면 아래와 같이 실행 한다.
- `$ git tag -l 'v1.8.5*`

49. 태그 붙이기  
Git의 태그는 Lightweight 태그와 Annotated 태그로 두 종류가 있다.  
Lightweight 태그는 브랜치와 비슷한데 브랜치처럼 가리키는 지점을 최신 커밋으로 이동시키지 않는다. 단순히 특정 커밋에 대한 포인터일 뿐이다.  
한편 Annotated 태그는 Git 데이터베이스에 태그를 만든 사람의 이름, 이메일과 태그를 만든 날짜, 그리고 태그 메시지도 저장한다. GPG(GNU Privacy Guard)로 서명할 수도 있다 .이 모든 정보를 저장해둬야 할 때만 Annotated 태그를 추천한다. 그냥 다른 정보를 저장하지 않는 단순한 태그가 필요하다면 Lightweight 태그를 사용하는 것이 좋다.

50. Lightweight 태그  
Lightweight 태그는 기본적으로 파일에 커밋 체크섬을 저장하는 것뿐이다. 다른 정보는 저장하지 않는다. Lightweight 태그를 만들 때는 -a, -s, -m 옵션을 사용하지 않는다.

51. 특정 커밋에 태그하기 위해서 명령의 끝에 커밋 체크섬을 명시한다(긴 체크섬을 전부 사용할 필요는 없다).
- `$ git tag -a v1.2 9fceb02`

52. 태그 공유하기  
`git push` 명령은 자동으로 리모트 서버에 태그를 전송하지 않는다. 태그를 만들었으면 서버에 별도로 Push해야 한다. 브랜치를 공유하는 것과 같은 방법으로 할 수 있다. `git push origin [태그 이름]`을 실행한다.

53. 태그를 Checkout하기  
태그는 브랜치와는 달리 가리키는 커밋을 바꿀 수 없는 이름이기 때문에 Checkout해서 사용할 수 없다. 태그가 가리키는 특정 커밋 기반의 브래니를 만들어 작업하려면 아래와 같이 새로 브랜치를 생성한다.
`$ git checkout -b version2 v2.0.0`

54. 명령을 완벽하게 입력하지 않으면 Git은 알아듣지 못한다. Git이 명령을 전부 입력하는 것이 귀찮다면 `git config`를 사용하여 각 명령의 Alias을 쉽게 만들 수 있다. 아래는 Alias를 만드는 예이다.
- `git config --global alias.co checkout`
- `git config --global alias.br branch`
- `git config --global alias.ci commit`
- `git config --global alias.st status`

55. 그리고 Git의 명령어뿐만 아니라 외부 명령어도 실행할 수 있다. !를 제일 앞에 추가하면 외부 명령을 실행한다.

### 3장. Git 브랜치
56. 커밋하면 Git은 Staging Area에 있는 데이터의 스탭샷에 대한 포인터, 저자나 커밋 메시지 같은 메타데이터, 이전 커밋에 대한 포인터 등을 포함하는 커밋 개체(커밋 Object)를 저장한다.

57. Git 버전 관리 시스템에서 "master" 브랜치는 특별하지 않다. 다른 브랜치와 다른 것이 없다. 다만 모든 저장소에서 "master" 브랜치가 존재하는 이유는 git init 명령으로 초기화할 때 자동으로 만들어진 이 브랜치를 애써 다른 이름으로 변경하지 않기 때문이다.

58. 지금 작업 중인 브랜치가 무엇인지 Git은 어떻게 파악할까. 다른 버전 관리 시스템과는 달리 Git은 'HEAD'라는 특수한 포인터가 있다. 이 포인터는 지금 작업하는 로컬 브랜치를 가리킨다.

59. `git log` 명령에 `--decorate` 옵션을 사용하면 쉽게 브랜치가 어떤 커밋을 가리키는지도 확일할 수 있다.

60. `git log --oneline -decorate --graph --all`이라고 실행하면 히스토리를 출력한다.

61. 실제로 Git의 브랜치는 어떤 한 커밋을 가리키는 40글자의 SHA-1 체크섬 파일에 불과하기 때문에 만들기도 쉽고 지우기도 쉽다. 새로 브랜치를 하나 만드는 것은 41바이트 크기의 파일(40자와 줄 바꿈 문자)을 하나 만드는 것에 불과하다.

62. 브랜치가 필요할 때 프로젝트를 통째로 복사해야 하는 다른 버전 관리 도구와 Git의 차이는 극명하다. 통째로 복사하는 작업은 프로젝트 크기에 따라 다르겠지만 수십 초에서 수십 분까지 걸린다. 그에 비해 Git은 순식간이다. 게다가 커밋을 할 때마다 이전 커밋의 정보를 저장하기 때문에 Merge할 때 어디서부터 (Merge Base) 합쳐야 하는지 안다. 이런 특징은 개발자들이 수시로 브랜치를 만들어 사용하게 한다.

63. Merge 메시지에서 "fast-forward"가 보이는가. Merge할 브랜치가 가리키는 커밋이 현 브랜치 커밋이 Upstream 브랜치이기 때문에 master 브랜치 포인터는 Merge 과정 없이 그저 최신 커밋으로 이동한다. 이런 Merge 방식을 'Fast Forward'라고 부른다.

64. Git은 Merge하는데 필요한 최적의 공통 조상을 자동으로 찾는다. 이런 기능도 Git이 다른 버전 관리 시스템보다 나은 점이다. CVS나 Subversion 같은 버전 관리 시스템은 개발자가 직접 공통 조상을 찾아서 Merge해야 한다. Git은 다른 시스템보다 Merge가 대단히 쉽다.

65. Merge 충돌이 일어났을 때 Git이 어떤 파일을 Merge할 수 없었는지 살펴보려면 git status 명령을 이용한다.

66. 다른 Merge 도구도 충돌을 해결할 수 있다. git mergetool 명령으로 실행한다.

67. Merge 도구를 종료하면 Git은 잘 Merge했는지 물어본다. 잘 마쳤다고 입력하면 자동으로 git add가 수행되고 해당 파일이 Staging Area에 저장된다. git status 명령으로 충돌이 해결된 상태인지 다시 한번 확인해 볼 수 있다.

68. `git branch -v` 명령을 실행하면 브랜치마다 마지막 커밋 메시지도 함께 보여준다.

69. 현재 Checkout한 브랜치를 기준으로 `merged`와 `--no merged` 옵션을 사용하여 Merge된 브랜치인지 그렇지 않은지 필터링해 볼 수 있다. `git branch --merged` 명령으로 이미 Merge한 브랜치 목록을 확인한다.

70. 반대로 현재 Checkout한 브랜치에 Merge하지 안흥ㄴ 브랜치를 살펴보려면 `git branch --no-merged` 명령을 사용한다.

71. Merge하지 않은 브랜치를 강제로 삭제하려면 -D 옵션으로 삭제한다.

72. Long-Running 브랜치  
이런 접근법에 따라서 Git 개발자가 많이 선호하는 워크플로가 하나 있다. 배포했거나 배포할 코드만 master 브랜치에 Merge해서 안정 버전의 코드만 master 브랜치에 둔다. 개발을 진행하고 안정화하는 브랜치는 develop이나 next라는 이름으로 추가로 만들어 사용한다.

73. 개발 브랜치는 공격적으로 히스토리를 만들어 나아가고 안정 브랜치는 이미 만든 히스토리를 뒤따르며 나아간다.

74. 토픽 브랜치  
토픽 브랜치는 프로젝트 크기에 상관없이 유용하다. 토픽 브랜치는 어떤 한 가지 주제나 작업을 위해 만든 짧은 호흡의 브랜치다.

75. 리모트 브랜치  
리모트 Refs는 리모트 저장소에 있는 포인터인 레퍼런스다. 리모트 저장소에 있는 브랜치, 태그 등등을 의미한다. `git ls-remote (remote)` 명령으로 모든 리모트 Refs를 조회할 수 있다. `git remote show (remote)` 명령은 모든 리모트 브랜치와 그 정보를 보여준다. 리모트 Refs가 있지만 보통은 리모트 트래킹 브랜치를 사용한다.

76. 리모트 트래킹 브랜치는 리모트 브랜치를 추적하는 브랜치다. 이 브랜치는 로컬에 있지만 움직일 수 없다. 리모트 서버에 연결할 때마다 리모트 브랜치에 따라서 자동으로 움직일 뿐이다. 리모트 트래킹 브랜치는 일종의 북마크라고 할 수 있다. 리모트 저장소에 마지막으로 연결했던 순간에 브랜치가 무슨 커밋을 가리키고 있었는지를 나타낸다.

77. 리모트 브랜치의 이름은 (remote)/(branch) 형식으로 되어 있다.

78. 리모트 서버로부터 저장소 정보를 동기화하려면 git fetch origin 명령을 사용한다. 명령을 실행하면 우선 "origin" 서버의 주소 정보를 찾아서, 현재 로컬의 저장소가 갖고 있지 않은 새로운 정보가 있으면 모두 내려받고, 받은 데이터를 로컬 저장소에 업데이트하고 나서, origin/master 포인터의 위치를 최신 커밋으로 이동시킨다.

79. Push하기  
로컬의 브랜치를 서버로 전송하려면 쓰기 권한이 있는 리모트 저장소에 Push해야 한다. 로컬 저장소의 브랜치는 자동으로 리모트 저장소로 전송되지 않는다. 명시적으로 브랜치를 Push해야 정보가 전송된다.

80. Git은 serverfix라는 브랜치 이름을 refs/heads/serverfix:refs/heads/serverfix로 확장한다. 이것은 serverfix라는 로컬 브랜치를 서버로 Push하는데 리모트의 serverfix 브랜치로 업데이트한다는 것을 의미한다.

81. `git push origin serverfix:serverfix`라고 Push하는 것도 같은 의미인데 이것은 "로컬의 serverfix 브랜치를 리모트 저장소의 serverfix 브랜치로 Push하라"라는 뜻이다. 로컬 브랜치의 이름과 리모트 서버의 브랜치 이름이 다를 때 필요하다. 리모트 저장소에 serverfix라는 이름 대신 다른 이름을 사용하려면 `git push origin serverfix:awesomebranch처럼 사용한다.

82. Fetch 명령으로 리모트 트래킹 브랜치를 내려받는다고 해서 로컬 저장소에 수정할 수 있는 브랜치가 새로 생기는 것이 아니다. 다시 말해서 serverfix라는 브랜치가 생기는 것이 아니라 그저 수정 못하는 origin/serverfix 브랜치 포인터가 생기는 것이다.

83. 새로 받은 브랜치의 내용을 Merge하려면 `git merge origin/serverfix` 명령을 사용한다. Merge하지 않고 리모트 트래킹 브랜치에서 시작하는 새 브랜치를 만들려면 아래와 같은명령을 사용한다.
- `git checkout -b serverfix origin/serverfix`

84. 서버로부터 저장소를 Clone을 하면 Git은 자동으로 master 브랜치를 origin/master 브랜치의 트래킹 브랜치로 만든다. 트래킹 브랜치를 직접 만들 수 있는데 리모트를 origin이 아닌 다른 리모트로 할 수도 있고, 브랜치도 master가 아닌 다른 브랜치로 추적하게 할 수 있다. `git checout -b [branch] [remotename]/[branch]` 명령으로 간단히 트래킹 브랜치를 만들 수 있다. `--track` 옵션을 사용하여 로컬 브랜치 이름을 자동으로 생성할 수 있다.
- `$ git checkout --track origin/serverfix`

85. 이미 로컬에 존재하는 브랜치가 리모트의 특정 브랜치를 추적하게 하려면 `git branch` 명령에 `-u`나 `--set-upstream-to` 옵션을 붙여서 아래와 같이 설정한다.
- `git branch -u origin/serverfix`

86. 추적 브랜치를 설정했다면 추적 브랜치 이름을 @{upstream}이나 @{u}로 짧게 대체하여 사용할 수 있다. master 브랜치가 origin/master 브랜치를 추적하는 경우라면 `git merge origin/master` 명령과 `git merge @{u}` 명령을 똑같이 사용할 수 있다.

87. 추적 브랜치가 현재 어떻게 설정되어 있는지 확인하려면 `git branch` 명령에 `--v` 옵션을 더한다. 이 명령을 실행하면 로컬 브랜치 목록과 로컬 브랜치가 추적하고 있는 리모트 브랜치도 함게 보여준다. 게다가 로컬 브랜치가 앞서가는지 뒤처지는지에 대한 내용도 보여준다.
- `git branch --v`

88. 여기서 중요한 점은 명령을 실행했을 때 나타나는 경과는 모두 마지막으로 서버에서 데이터를 가져온(fetch) 시점을 바탕으로 게산한다는 점이다. 단순히 이 명령만으로는 서버의 최신 데이터를 반영하지는 않으며 로컬에 저장된 서버의 캐시 데이터를 사용한다. 현재 시점에서 진짜 최신 데이터로 추적 상황을 알아보려면 먼저 서버로부터 최신 데이터를 받아온 후에 추적 상황을 확인해야 한다. `$ git fetch --all; git branch --v`처럼 두 명령을 이어서 사용하는 것이 적당하다 하겠다.

89. 간단히 말하면 `git pull` 명령은 대부분 `git fetch` 명령을 실행하고 나서 자동으로 `git merge` 명령을 수행하는 것뿐이다.

90. 일반적으로 fetch와 merge 명령을 명시적으로 사용하는 것이 pull 명령으로 한 번에 두 작업을 하는 것보다 낫다.

91. `git push` 명령에 `--delete` 옵션을 사용하여 리모트 브랜치를 삭제할 수 있다. serverfix라는 리모트 브랜치를 삭제하려면 아래와 같이 실행한다.
- `git push origin --delete serverfix`

92. Rebase  
- `$ git checkout experiment`
- `$ git rebase master`
-> 마스터 바로 앞으로 가서 커밋 생성

93. Rebase 후 Merge(Fast-forward)
- `$ git checkout master`
- `$ git merge experimet`

94. Merge이든 Rebase든 둘 다 합치는 관점에서는 서로 다를 게 없다. 하지만, Rebase가 좀 더 깨끗한 히스토리를 만든다. Rebase한 브랜치의 Log의 히스토리를 살펴보면 히스토리가 선형이다. 일을 병렬로 동시에 진행해도 Rebase하고 나면 모든 작업이 차례대로 수행된 것처럼 보인다.

95. Rebase는 보통 리모트 브랜치에 커밋을 깔끔하게 적용하고 싶을 때 사용한다. 아마 이렇게 Rebase하는 리모트 브랜치는 직접 관리하는 것이 아니라 그냥 참여하는 브랜치일 것이다.

96. `$ git rebase --onto master server client`
이 명령은 "client 브랜치를 Checkout하고 server와 client의 공통조상 이후의 Patch를 만들어 master에 적용"하라는 내용이다. 조금 복잡하긴 해도 꽤 쓸모 있다.

97. 이제 master 브랜치로 돌아가서 Fast-forward할 수 있다.
- `$ git checkout master`
- `$ git merge client`

98. Rebase의 위험성  
이미 공개 저장소에 Push한 커밋을 Rebase하지 말라

99. 이 지침만 지키면 Rebase를 하는 데 문제 될 게 없다.

100. Rebase는 기존의 커밋을 그대로 사용하는 것이 아니라 내용은 같지만 다른 커밋을 새로 만든다. 새 커밋을 서버에 Push하고 동료 중 누군가가 그 커밋을 Pull해서 작업을 한다고 하자. 그런데 그 커밋을 `git rebase`로 바꿔서 Push해버리면 동료가 다시 Push했을 때 동료는 다시 Merge해야 한다. 그리고 동료가 다시 Merge한 내용을 Pull하면 내 코드는 정말 엉망이 된다.

101. `git pull` 명령을 실행할 때 옵션을 붙여서 `git pull --rebase`로 Rebase할 수도 있다. 물론 `git fetch`와 `git rebase teamone/master`이 두 명령을 직접 순서대로 실행해도 된다.

102. Rebase vs. Merge  
히스토리를 보는 관점 중에 하나는 작업한 내용의 기록으로 보는 것이다. 작업 내용을 기록한 문서이고, 각 기록은 각각 의미를 가지며, 변경할 수 없다. 이런 관점에서 커밋 히스토리를 변경한다는 것은 역사를 부정하는 꼴이 된다. 언제 무슨 일이 있었는지 기록에 대해 거짓말을 하게 되는 것이다. 이렇게 했을 때 지저분하게 수많은 Merge 커밋이 히스토리에 남게 되면 문제가 없을까? 역사는 후세를 위해 기록하고 보존해야 한다.

103. 히스토리를 프로젝트가 어떻게 진행되었냐에 대한 이야기로도 볼 수 있다. 소프트웨어를 주의 깊게 편집하는 방법에 매뉴얼이나 세세한 작업 내용을 초벌부터 공개하고 싶지 않을 수 있다. 나중에 다른 사람에게 들려주기 좋도록 Rebase나 filter-branch같은 도구로 프로젝트의 진행 이야기를 다듬으면 좋다.

104. 일반적인 해답을 굳이 드리자면 로컬 브랜치에서 작업할 땐ㄴ 히스토리를 정리하기 위해서 Rebase할 수도 있지만, 리모트 등 어딘가 밖으로 Push로 내보낸 커밋에 대해서는 절대 Rebase하지 말아야 한다.






### 4장. Git 서버
### 5장. 분산 환경에서의 Git
### 6장. GitHub
### 7장. Git 도구
### 8장. Git 맞춤
### 9장. Git과 여타 버전 관리 시스템
### 10장. Git의 내부
### 부록A. 다양한 환경에서 Git 사용하기
### 부록B. 애플리케이션에 Git 넣기
### 부록C. Git 명령어
