# You don't knwo JS (타입과 문법, 스코프와 클로저)
### 지은이 : 카일 심슨
### 옮긴이 : 이일웅, 최병현
### 출판사 : 한빛미디어
### 읽은 날 : 2020.03.18 ~

# 목차
# Part 1. 타입과 문법
### 1. 타입
### 2. 값
### 3. 네이티브
### 4. 강제변환
### 5. 문법
# Part 2. 스코프와 클로저
### 6. 스코프란 무엇인가
### 7. 렉시컬 스코프
### 8. 함수 vs 블록 스코프
### 9. 호이스팅
### 10. 스코프 클로저
### Appendix A. 다양한 환경의 자바스크립트
### Appendix B. 스코프와 렉시컬 this

# Part 1. 타입과 문법
### 1. 타입
1. 타입으로 null 값을 정확히 확인하려면 조건이 하나 더 필요하다.
var a = null;
(!a && typeof a === “object”); //true

2. “undefined”(값이 없는)와 “undeclared”(선언되지 않은)를 동의어처럼 생각하기 쉬운데, 자바스크립트에서 둘은 완전히 다른 개념이다.
“undefined”는 접근 가능한 스코프에 변수가 선언되었으나 현재 아무런 값도 할당되지 않은 상태를 가리키는 반면, “undeclared”는 접근 가능한 스코프에 변수 자체가 선언조차 되지 않은 상태를 의미한다.

### 2. 값
3. 표현식 void __는 어떤 값이든 ‘무효로 만들어void’, 항상 결괏값을 undefined로 만든다. 기존 값은 건드리지 않고 연산 후 값은 복구할 수 없다.

4. void 연산자는 (어떤 표현식으로부터) 존재하는 곳에서 그 값이 undefined가 되어야 좋을 경우에만 사용하자. 아마도 그렇게 해야 할 경우도 거의 없고 극히 제한적으로 쓰이겠지만 제법 쓸모는 있다.

5. NaN은 경계 값(Sentinel Value)의 일종으로 (또는 특별한 의미를 부여한 평범한 값으로) 숫자 집합 내에서 특별한 종류의 에러 상황(“난 당신이 내준 수학 연산을 해봤지만 실패했어 그러니 여기 실패한 숫자를 도로 가져가!”)을 나타낸다.

6. NaN은 너무 귀하신 몸이라 다른 어떤 NaN과도 동등하지 않다(즉, 자기 자신과도 같지 않다). 사실상 반사성(Reflexive)이 없는(x === x로 식별되지 않는) 유일무이한 값이다. 따라서 NaN !== NaN이다. 좀 이상하긴 하다.

7. NaN은 세상의 모든 언어를 통틀어 “자기 자신과도 동등하지 않은” 유일한 값이다.

8. Number.isNaN() !== isNaN() (Number.isNaN() 권장)

9. 값-복사냐 레퍼런스-복사냐를 여러분 마음대로 결정할 수 없음을 기억하자. 전적으로 값의 타입을 보고 엔진의 재량으로 결정된다.

### 3. 네이티브
10. 짐작하겠지만 네이티브는 사실 내장 함수다.

11. 네이티브란 특정 환경(브라우저 등의 클라이언트 프로그램)에 종속되지 않은, ECMAScript 명세의 내장 객체를 말합니다. 예를 들어 Object, Math, Function, Array, Window, Button 중 네이티비그 아닌 것은 Window, Button 두 가지입니다.

12. 요지는 new String(“abc”)은 “abc”를 감싸는 문자열 래퍼를 생성하며 원시 값 ”abc”는 아니라는 점이다.

13. Array() 생성자 앞에 new를 붙이지 않아도 된다. 붙이지 않아도 붙인 것처럼 작동한다. 즉, Array(1, 2, 3)와 new Array(1, 2, 3)은 결과적으로 같다.

14. 따라서 Array.apply()는 Array() 함수를 호출하는 동시에 { length: 3 } 객체 값을 펼쳐 인자로 넣는다.
var a = Array.apply( null, { length: 3 } );
a; // [ undefined, undefined, undefined ]

15. 지금까지 살펴본 다른 생성자와는 달리, RegExp()는 정규 표현식 패턴을 동적으로 정의할 경우 의미있는 유틸리티다.

16. 네이티브 생성자 Date()와 Error()는 리터럴 형식이 없으므로 다른 네이티브에 비해 유용하다.

17. 심벌은 객체가 아니다. 단순한 스칼라 원시 값이다.

18. 문서화 관례에 따라 String.prototype.XYZ는 String#XYZ로 줄여 쓴다. 다른 .prototype도 마찬가지다.

19. 그러고 보니 Function.prototype은 함수, RegExp.prototype은 정규 표현식, Array.prototype은 배열이다. 참 재미있고 쿨하지 않은가? (글쎄..)

20. 자바스크립트는 원시 값을 감싸는 객체 래퍼, 즉 네이티브(String, Number, Boolean 등)를 제공한다. 객체 래퍼에는 타입별로 쓸 만한 기능이 구현되어 있어 편리하게 사용할 수 있다.
“abc” 같은 단순 스칼라 원시 값이 있을 때, 이 값의 length 프로퍼티나 String.prototype에 정의된 메서드를 호출하면 자바스크립트는 자동으로 원시 값을 ‘박싱’(해당되는 객체 래퍼로 감싼다)하여 필요한 프로퍼티와 메서드를 쓸 수 있게 도와준다.
