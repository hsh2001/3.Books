# You don't knwo JS (타입과 문법, 스코프와 클로저)
### 지은이 : 카일 심슨
### 옮긴이 : 이일웅, 최병현
### 출판사 : 한빛미디어
### 읽은 날 : 2020.03.18 ~

# 목차
# Part 1. 타입과 문법
### 1. 타입
### 2. 값
### 3. 네이티브
### 4. 강제변환
### 5. 문법
# Part 2. 스코프와 클로저
### 6. 스코프란 무엇인가
### 7. 렉시컬 스코프
### 8. 함수 vs 블록 스코프
### 9. 호이스팅
### 10. 스코프 클로저
### Appendix A. 다양한 환경의 자바스크립트
### Appendix B. 스코프와 렉시컬 this

# Part 1. 타입과 문법
### 1. 타입
1. 타입으로 null 값을 정확히 확인하려면 조건이 하나 더 필요하다.
var a = null;
(!a && typeof a === “object”); //true

2. “undefined”(값이 없는)와 “undeclared”(선언되지 않은)를 동의어처럼 생각하기 쉬운데, 자바스크립트에서 둘은 완전히 다른 개념이다.
“undefined”는 접근 가능한 스코프에 변수가 선언되었으나 현재 아무런 값도 할당되지 않은 상태를 가리키는 반면, “undeclared”는 접근 가능한 스코프에 변수 자체가 선언조차 되지 않은 상태를 의미한다.

### 2. 값
3. 표현식 void __는 어떤 값이든 ‘무효로 만들어void’, 항상 결괏값을 undefined로 만든다. 기존 값은 건드리지 않고 연산 후 값은 복구할 수 없다.

4. void 연산자는 (어떤 표현식으로부터) 존재하는 곳에서 그 값이 undefined가 되어야 좋을 경우에만 사용하자. 아마도 그렇게 해야 할 경우도 거의 없고 극히 제한적으로 쓰이겠지만 제법 쓸모는 있다.

5. NaN은 경계 값(Sentinel Value)의 일종으로 (또는 특별한 의미를 부여한 평범한 값으로) 숫자 집합 내에서 특별한 종류의 에러 상황(“난 당신이 내준 수학 연산을 해봤지만 실패했어 그러니 여기 실패한 숫자를 도로 가져가!”)을 나타낸다.

6. NaN은 너무 귀하신 몸이라 다른 어떤 NaN과도 동등하지 않다(즉, 자기 자신과도 같지 않다). 사실상 반사성(Reflexive)이 없는(x === x로 식별되지 않는) 유일무이한 값이다. 따라서 NaN !== NaN이다. 좀 이상하긴 하다.

7. NaN은 세상의 모든 언어를 통틀어 “자기 자신과도 동등하지 않은” 유일한 값이다.

8. Number.isNaN() !== isNaN() (Number.isNaN() 권장)

9. 값-복사냐 레퍼런스-복사냐를 여러분 마음대로 결정할 수 없음을 기억하자. 전적으로 값의 타입을 보고 엔진의 재량으로 결정된다.

### 3. 네이티브
10. 짐작하겠지만 네이티브는 사실 내장 함수다.

11. 네이티브란 특정 환경(브라우저 등의 클라이언트 프로그램)에 종속되지 않은, ECMAScript 명세의 내장 객체를 말합니다. 예를 들어 Object, Math, Function, Array, Window, Button 중 네이티비그 아닌 것은 Window, Button 두 가지입니다.

12. 요지는 new String(“abc”)은 “abc”를 감싸는 문자열 래퍼를 생성하며 원시 값 ”abc”는 아니라는 점이다.

13. Array() 생성자 앞에 new를 붙이지 않아도 된다. 붙이지 않아도 붙인 것처럼 작동한다. 즉, Array(1, 2, 3)와 new Array(1, 2, 3)은 결과적으로 같다.

14. 따라서 Array.apply()는 Array() 함수를 호출하는 동시에 { length: 3 } 객체 값을 펼쳐 인자로 넣는다.
var a = Array.apply( null, { length: 3 } );
a; // [ undefined, undefined, undefined ]

15. 지금까지 살펴본 다른 생성자와는 달리, RegExp()는 정규 표현식 패턴을 동적으로 정의할 경우 의미있는 유틸리티다.

16. 네이티브 생성자 Date()와 Error()는 리터럴 형식이 없으므로 다른 네이티브에 비해 유용하다.

17. 심벌은 객체가 아니다. 단순한 스칼라 원시 값이다.

18. 문서화 관례에 따라 String.prototype.XYZ는 String#XYZ로 줄여 쓴다. 다른 .prototype도 마찬가지다.

19. 그러고 보니 Function.prototype은 함수, RegExp.prototype은 정규 표현식, Array.prototype은 배열이다. 참 재미있고 쿨하지 않은가? (글쎄..)

20. 자바스크립트는 원시 값을 감싸는 객체 래퍼, 즉 네이티브(String, Number, Boolean 등)를 제공한다. 객체 래퍼에는 타입별로 쓸 만한 기능이 구현되어 있어 편리하게 사용할 수 있다.
“abc” 같은 단순 스칼라 원시 값이 있을 때, 이 값의 length 프로퍼티나 String.prototype에 정의된 메서드를 호출하면 자바스크립트는 자동으로 원시 값을 ‘박싱’(해당되는 객체 래퍼로 감싼다)하여 필요한 프로퍼티와 메서드를 쓸 수 있게 도와준다.

### 4. 강제변환
21. 차이는 명확하다. ‘명시적 강제변환’은 코드만 봐도 의도적으로 타입변환을 일으킨다는 사실이 명백한 반면, ‘암시적 강제변환’은 다른 작업 도중 불분명한 부수 효과(Side Effect)로부터 발생하는 타입변환이다.
var b = a + “”; // 암시적 강제변환
var c = String(a); // 명시적 강제변환

22. JSON.stringify() 이야기가 나왔으니, 잘 알려지지 않은 유용한 기능 하나를 귀띔하겠다.
배열 아니면 함수 형태의 대체자(Replacer)를 JSON.stringify()의 두 번째 선택 인자로 지정하여 객체를 재귀적으로 직렬화하면서 (포함할 프로퍼티와 제외할 프로퍼티를 결정하는) 필터링 하는 방법이 있다.

23. JSON.stringify()은 세 번째 선택 인자는 스페이스(Space)라고 하며 사람이 읽기 쉽도록 들여 쓰기를 할 수 있다. 들여 쓰기를 할 빈 공간의 개수를 숫자로 지정하거나 문자열(10자 이상이면 앞에서 10자까지만 잘라 사용한다)을 지정하여 각 들여 쓰기 수준에 사용한다.

24. ‘숫자 아닌 값 -> 수식 연산이 가능한 숫자’ 변환 로직  
예를 들어 true는 1, false는 0이 된다. Undefined는 NaN으로, (희한하게도) null은 0으로 바뀐다.

25. 명세가 정의한 ‘falsy’ 값은 다음과 같다.  
- undefined
- null
- false
- +0, -0, NaN
- “”

26. 오픈 소스 자바스크립트 커뮤니티에서는 + 단항 연산자를 명시적 강제변환 형식으로 대부분 인정하는 분위기다.

27. 가급적 +/- 단항 연산자를 다른 연산자와 인접하여 사용하지 않기 바란다. 코드가 잘 돌아간다해도 별로 좋지 않은 생각이다.

28. ~x는 대략 –(x+1)와 같다. 이상한 것 같지만 왜 그런지 금방 알 수 있다.
~42; // -(42+1)  -43

29. 그러나 ~~ 사용시 유의할 점이 있다. 우선 ~~ 연산은 32비트 값에 한하여 안전하다. 그런데 그보다도 음수에서는 Math.floor()과 결괏값이 다르다는 사실을 조심하자!
Math.floor(-49.6); // -50
~~49.6; // -49
Math.floor()과의 다른 점은 차치하더라도 ~~x는 (32비트) 정수로 상위 비트를 잘라낸다. 하지만 같은 일을 하는 x | 0가 (조금이라도) 더 빠를 것 같다.

30. 인자가 비 문자열(Non-String)이면 제일 먼저 자동으로 문자열로 강제변환한다. 이는 일종의 감춰진 암시적 강제변환으로 프로그램에 이런 로직이 자꾸 들어가는 건 바람직하지 않다. 절대로 parseInt()에 비 문자열 값을 넘기지 말자.

31. 암시적 강제변환이 무엇인지, 어떻게 활용할지, 무조건 ‘선량한 명시적 강제변환의 적’으로 몰아가지만 말고 조금 다른 시각에서 바라보자! 너무 편협하고 중요한 의미를 놓치고 있는 것 같아 안쓰럽다.
암시적 강제변환의 목적은 중요한 내용으로부터 주의를 분산시켜 코드를 잡동사니로 가득 채워버리는 장황함(Verbosity), 보일러플레이트(Boilerplate), 불필요한 상세 구현을 줄이는 것이다.

32. b = String(a)(명시적)과 b = a + “”(암시적)를 비교해보자. 둘 다 경우에 따라 유용하게 코드에 쓰일 수 있지만 자바스크립트 프로그램에선 후자를 훨씬 더 많이 쓴다. 이것만 보더라도 암시적 강제변환이 좋다, 나쁘다 하는 감정과는 무관하게 그 가치를 인정받았다는 걸 알 수 있다.

33. 개발자가 직접 손으로 코딩하기보다는 자바스크립트 압축기(Minifier)에서 더 많이 쓰는, 또 다른 관용 코드가 있다. && 연산자는 첫 번째 피연산자의 평가 결과가 truthy일 때에만 두 번째 피연산자를 ‘선택’한다고 했는데 이런 특성을 ‘가드 연산자(Guard Operator)’라고 한다. 첫 번째 표현식이 두 번째 표현식의 ‘가드’ 역할을 하는 것이다.

34. 정확한 정의를 내리겠다. “동등함 비교시 ==는 강제변환을 허용하지만, ===는 강제변환을 허용하지 않는다.”

35. 어떠한 일이 있더라도, 절대로, 두 번 다시 == true, == false 같은 코드는 쓰지 말라고 개인적으로 강권하고 싶다.
하지만 여기서 쓰지 말라고 한 연산자는 ==이지, ===이 아니다. === true, === false는 강제변환을 허용하지 않기에 ToNumber 강제변환 따위는 신경 쓰지 않아도 된다.

36. null과 undefined를 느슨한 동등 비교(==)하면 서로에게 타입을 맞춘다(강제변환한다). 언어 전체를 눈 씻고 찾아봐도 다른 값은 끼어들 여지가 없다.
즉, null과 undefined는 느슨한 동등 비교시 상호 간의 암시적인 강제변환이 일어나므로 비교 관점에서 구분이 되지 않는 값으로 취급되는 것이다.

37. (강제변환의) 나쁜 부분 7인방을 모아 보자.
- “0” == false; // true
- false == 0; //true
- false == “”; // true
- false == []; // true
- “” == 0; // true
- “” == []; // true
- 0 == []; // true

38. 결국, 강제변환 때문에 골탕 먹을 경우의 수가 있다는 사실은 부인하기 어렵고 함정에 빠지지 않으려면 주의할 필요는 있지만, 코드 베이스 전체를 통틀어 그럴 만한 코드가 나올 가능성은 매우 희박하다는 걸 알 수 있다.

39.  
- 피연산자 중 하나가 true/false일 가능성이 있으면 ‘절대로’ == 연산자를 쓰지 말자.
- 피연산자 중 하나가 []. “ “, 0이 될 가능성이 있으면 가급적 == 연산자는 쓰지 말자.
이런 상황이라면 == 대신 ===를 사용하여 여러분이 의도하지 않은 강제변환을 차단하는 게 훨씬 좋다. 이 두 가지 원칙만 준수해도 웬만한 강제변환의 함정들은 효과적으로 피해갈 수 있으리라 생각한다.

40. 결국 ==냐 ===냐 하는 문제는 한 마디로 “동등 비교 시 강제변환을 허용할 거냐 말 거냐”와 본질적으로 같다.

41. a <= b는 실제로 b < 0의 평과 결과를 부정하도록 명세에 기술되어 있기 때문이다. 그래서 b < a가 false이므로 a <= b는 이를 부정한 true가 된다.

42. 여러분은 지금까지 <=이 ‘같거나 더 작은’이라는 부등호의 의미일 거라 당연시해왔겠지만, 참 짓궂게도 정반대일 가능성도 있다. 실제로 자바스크립트 엔진은 <=를 ‘더 크지 않은’(!(a > b) -> !(b < a)로 처리)의 의미로 해석한다. 더구나 a >= b는 먼저 b <= a로 재해석한 다음 동일한 추론을 적용한다.

43. 명시적 강제변환은 다른 타입의 값으로 변환하는 의도가 확실한 코드를 말하며 혼동의 여지를 줄이고 코드 가독성 및 유지 보수성을 높일 수 있는 장점이 있다.
암시적인 강제변환은 ‘숨겨진’ 로직에 의한 부수 효과가 있으며 타입변환이 처리되는 과정이 명확하지 않다. 그래서 암시적 강제변환이 명시적 강제변환의 정반대고 나쁜 것이라고들 하지만 (주변에 이렇게 얘기하는 사람들이 의외로 많다!) 실은 암시적 강제변환이 오히려 코드 가독성을 향상하는 장점도 있다.

44. 암시적 강제변환은 변환 과정이 구체적으로 어떻게 일어나는지 명확하게 알고 사용해야 한다. 여러분 스스로 지금 내가 무슨 코드를 짜고 있고 어떻게 작동할 거란 점은 알고 있어야 한다. 더 나아가 다른 개발자들도 쉽게 배우고 이해할 수 있는 코드를 작성하도록 노력하기 바란다.
