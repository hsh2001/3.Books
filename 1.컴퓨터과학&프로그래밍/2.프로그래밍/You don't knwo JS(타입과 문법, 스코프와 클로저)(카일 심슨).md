# You don't knwo JS (타입과 문법, 스코프와 클로저)
### 지은이 : 카일 심슨
### 옮긴이 : 이일웅, 최병현
### 출판사 : 한빛미디어
### 읽은 날 : 2020.03.18 ~

# 목차
# Part 1. 타입과 문법
### 1. 타입
### 2. 값
### 3. 네이티브
### 4. 강제변환
### 5. 문법
# Part 2. 스코프와 클로저
### 6. 스코프란 무엇인가
### 7. 렉시컬 스코프
### 8. 함수 vs 블록 스코프
### 9. 호이스팅
### 10. 스코프 클로저
### Appendix A. 다양한 환경의 자바스크립트
### Appendix B. 스코프와 렉시컬 this

# Part 1. 타입과 문법
### 1. 타입
1. 타입으로 null 값을 정확히 확인하려면 조건이 하나 더 필요하다.
var a = null;
(!a && typeof a === “object”); //true

2. “undefined”(값이 없는)와 “undeclared”(선언되지 않은)를 동의어처럼 생각하기 쉬운데, 자바스크립트에서 둘은 완전히 다른 개념이다.
“undefined”는 접근 가능한 스코프에 변수가 선언되었으나 현재 아무런 값도 할당되지 않은 상태를 가리키는 반면, “undeclared”는 접근 가능한 스코프에 변수 자체가 선언조차 되지 않은 상태를 의미한다.

### 2. 값
3. 표현식 void __는 어떤 값이든 ‘무효로 만들어void’, 항상 결괏값을 undefined로 만든다. 기존 값은 건드리지 않고 연산 후 값은 복구할 수 없다.

4. void 연산자는 (어떤 표현식으로부터) 존재하는 곳에서 그 값이 undefined가 되어야 좋을 경우에만 사용하자. 아마도 그렇게 해야 할 경우도 거의 없고 극히 제한적으로 쓰이겠지만 제법 쓸모는 있다.

5. NaN은 경계 값(Sentinel Value)의 일종으로 (또는 특별한 의미를 부여한 평범한 값으로) 숫자 집합 내에서 특별한 종류의 에러 상황(“난 당신이 내준 수학 연산을 해봤지만 실패했어 그러니 여기 실패한 숫자를 도로 가져가!”)을 나타낸다.

6. NaN은 너무 귀하신 몸이라 다른 어떤 NaN과도 동등하지 않다(즉, 자기 자신과도 같지 않다). 사실상 반사성(Reflexive)이 없는(x === x로 식별되지 않는) 유일무이한 값이다. 따라서 NaN !== NaN이다. 좀 이상하긴 하다.

7. NaN은 세상의 모든 언어를 통틀어 “자기 자신과도 동등하지 않은” 유일한 값이다.

8. Number.isNaN() !== isNaN() (Number.isNaN() 권장)

9. 값-복사냐 레퍼런스-복사냐를 여러분 마음대로 결정할 수 없음을 기억하자. 전적으로 값의 타입을 보고 엔진의 재량으로 결정된다.

### 3. 네이티브
10. 짐작하겠지만 네이티브는 사실 내장 함수다.

11. 네이티브란 특정 환경(브라우저 등의 클라이언트 프로그램)에 종속되지 않은, ECMAScript 명세의 내장 객체를 말합니다. 예를 들어 Object, Math, Function, Array, Window, Button 중 네이티비그 아닌 것은 Window, Button 두 가지입니다.

12. 요지는 new String(“abc”)은 “abc”를 감싸는 문자열 래퍼를 생성하며 원시 값 ”abc”는 아니라는 점이다.

13. Array() 생성자 앞에 new를 붙이지 않아도 된다. 붙이지 않아도 붙인 것처럼 작동한다. 즉, Array(1, 2, 3)와 new Array(1, 2, 3)은 결과적으로 같다.

14. 따라서 Array.apply()는 Array() 함수를 호출하는 동시에 { length: 3 } 객체 값을 펼쳐 인자로 넣는다.
var a = Array.apply( null, { length: 3 } );
a; // [ undefined, undefined, undefined ]

15. 지금까지 살펴본 다른 생성자와는 달리, RegExp()는 정규 표현식 패턴을 동적으로 정의할 경우 의미있는 유틸리티다.

16. 네이티브 생성자 Date()와 Error()는 리터럴 형식이 없으므로 다른 네이티브에 비해 유용하다.

17. 심벌은 객체가 아니다. 단순한 스칼라 원시 값이다.

18. 문서화 관례에 따라 String.prototype.XYZ는 String#XYZ로 줄여 쓴다. 다른 .prototype도 마찬가지다.

19. 그러고 보니 Function.prototype은 함수, RegExp.prototype은 정규 표현식, Array.prototype은 배열이다. 참 재미있고 쿨하지 않은가? (글쎄..)

20. 자바스크립트는 원시 값을 감싸는 객체 래퍼, 즉 네이티브(String, Number, Boolean 등)를 제공한다. 객체 래퍼에는 타입별로 쓸 만한 기능이 구현되어 있어 편리하게 사용할 수 있다.
“abc” 같은 단순 스칼라 원시 값이 있을 때, 이 값의 length 프로퍼티나 String.prototype에 정의된 메서드를 호출하면 자바스크립트는 자동으로 원시 값을 ‘박싱’(해당되는 객체 래퍼로 감싼다)하여 필요한 프로퍼티와 메서드를 쓸 수 있게 도와준다.

### 4. 강제변환
21. 차이는 명확하다. ‘명시적 강제변환’은 코드만 봐도 의도적으로 타입변환을 일으킨다는 사실이 명백한 반면, ‘암시적 강제변환’은 다른 작업 도중 불분명한 부수 효과(Side Effect)로부터 발생하는 타입변환이다.
var b = a + “”; // 암시적 강제변환
var c = String(a); // 명시적 강제변환

22. JSON.stringify() 이야기가 나왔으니, 잘 알려지지 않은 유용한 기능 하나를 귀띔하겠다.
배열 아니면 함수 형태의 대체자(Replacer)를 JSON.stringify()의 두 번째 선택 인자로 지정하여 객체를 재귀적으로 직렬화하면서 (포함할 프로퍼티와 제외할 프로퍼티를 결정하는) 필터링 하는 방법이 있다.

23. JSON.stringify()은 세 번째 선택 인자는 스페이스(Space)라고 하며 사람이 읽기 쉽도록 들여 쓰기를 할 수 있다. 들여 쓰기를 할 빈 공간의 개수를 숫자로 지정하거나 문자열(10자 이상이면 앞에서 10자까지만 잘라 사용한다)을 지정하여 각 들여 쓰기 수준에 사용한다.

24. ‘숫자 아닌 값 -> 수식 연산이 가능한 숫자’ 변환 로직  
예를 들어 true는 1, false는 0이 된다. Undefined는 NaN으로, (희한하게도) null은 0으로 바뀐다.

25. 명세가 정의한 ‘falsy’ 값은 다음과 같다.  
- undefined
- null
- false
- +0, -0, NaN
- “”

26. 오픈 소스 자바스크립트 커뮤니티에서는 + 단항 연산자를 명시적 강제변환 형식으로 대부분 인정하는 분위기다.

27. 가급적 +/- 단항 연산자를 다른 연산자와 인접하여 사용하지 않기 바란다. 코드가 잘 돌아간다해도 별로 좋지 않은 생각이다.

28. ~x는 대략 –(x+1)와 같다. 이상한 것 같지만 왜 그런지 금방 알 수 있다.
~42; // -(42+1)  -43

29. 그러나 ~~ 사용시 유의할 점이 있다. 우선 ~~ 연산은 32비트 값에 한하여 안전하다. 그런데 그보다도 음수에서는 Math.floor()과 결괏값이 다르다는 사실을 조심하자!
Math.floor(-49.6); // -50
~~49.6; // -49
Math.floor()과의 다른 점은 차치하더라도 ~~x는 (32비트) 정수로 상위 비트를 잘라낸다. 하지만 같은 일을 하는 x | 0가 (조금이라도) 더 빠를 것 같다.

30. 인자가 비 문자열(Non-String)이면 제일 먼저 자동으로 문자열로 강제변환한다. 이는 일종의 감춰진 암시적 강제변환으로 프로그램에 이런 로직이 자꾸 들어가는 건 바람직하지 않다. 절대로 parseInt()에 비 문자열 값을 넘기지 말자.

31. 암시적 강제변환이 무엇인지, 어떻게 활용할지, 무조건 ‘선량한 명시적 강제변환의 적’으로 몰아가지만 말고 조금 다른 시각에서 바라보자! 너무 편협하고 중요한 의미를 놓치고 있는 것 같아 안쓰럽다.
암시적 강제변환의 목적은 중요한 내용으로부터 주의를 분산시켜 코드를 잡동사니로 가득 채워버리는 장황함(Verbosity), 보일러플레이트(Boilerplate), 불필요한 상세 구현을 줄이는 것이다.

32. b = String(a)(명시적)과 b = a + “”(암시적)를 비교해보자. 둘 다 경우에 따라 유용하게 코드에 쓰일 수 있지만 자바스크립트 프로그램에선 후자를 훨씬 더 많이 쓴다. 이것만 보더라도 암시적 강제변환이 좋다, 나쁘다 하는 감정과는 무관하게 그 가치를 인정받았다는 걸 알 수 있다.

33. 개발자가 직접 손으로 코딩하기보다는 자바스크립트 압축기(Minifier)에서 더 많이 쓰는, 또 다른 관용 코드가 있다. && 연산자는 첫 번째 피연산자의 평가 결과가 truthy일 때에만 두 번째 피연산자를 ‘선택’한다고 했는데 이런 특성을 ‘가드 연산자(Guard Operator)’라고 한다. 첫 번째 표현식이 두 번째 표현식의 ‘가드’ 역할을 하는 것이다.

34. 정확한 정의를 내리겠다. “동등함 비교시 ==는 강제변환을 허용하지만, ===는 강제변환을 허용하지 않는다.”

35. 어떠한 일이 있더라도, 절대로, 두 번 다시 == true, == false 같은 코드는 쓰지 말라고 개인적으로 강권하고 싶다.
하지만 여기서 쓰지 말라고 한 연산자는 ==이지, ===이 아니다. === true, === false는 강제변환을 허용하지 않기에 ToNumber 강제변환 따위는 신경 쓰지 않아도 된다.

36. null과 undefined를 느슨한 동등 비교(==)하면 서로에게 타입을 맞춘다(강제변환한다). 언어 전체를 눈 씻고 찾아봐도 다른 값은 끼어들 여지가 없다.
즉, null과 undefined는 느슨한 동등 비교시 상호 간의 암시적인 강제변환이 일어나므로 비교 관점에서 구분이 되지 않는 값으로 취급되는 것이다.

37. (강제변환의) 나쁜 부분 7인방을 모아 보자.
- “0” == false; // true
- false == 0; //true
- false == “”; // true
- false == []; // true
- “” == 0; // true
- “” == []; // true
- 0 == []; // true

38. 결국, 강제변환 때문에 골탕 먹을 경우의 수가 있다는 사실은 부인하기 어렵고 함정에 빠지지 않으려면 주의할 필요는 있지만, 코드 베이스 전체를 통틀어 그럴 만한 코드가 나올 가능성은 매우 희박하다는 걸 알 수 있다.

39.  
- 피연산자 중 하나가 true/false일 가능성이 있으면 ‘절대로’ == 연산자를 쓰지 말자.
- 피연산자 중 하나가 []. “ “, 0이 될 가능성이 있으면 가급적 == 연산자는 쓰지 말자.
이런 상황이라면 == 대신 ===를 사용하여 여러분이 의도하지 않은 강제변환을 차단하는 게 훨씬 좋다. 이 두 가지 원칙만 준수해도 웬만한 강제변환의 함정들은 효과적으로 피해갈 수 있으리라 생각한다.

40. 결국 ==냐 ===냐 하는 문제는 한 마디로 “동등 비교 시 강제변환을 허용할 거냐 말 거냐”와 본질적으로 같다.

41. a <= b는 실제로 b < 0의 평과 결과를 부정하도록 명세에 기술되어 있기 때문이다. 그래서 b < a가 false이므로 a <= b는 이를 부정한 true가 된다.

42. 여러분은 지금까지 <=이 ‘같거나 더 작은’이라는 부등호의 의미일 거라 당연시해왔겠지만, 참 짓궂게도 정반대일 가능성도 있다. 실제로 자바스크립트 엔진은 <=를 ‘더 크지 않은’(!(a > b) -> !(b < a)로 처리)의 의미로 해석한다. 더구나 a >= b는 먼저 b <= a로 재해석한 다음 동일한 추론을 적용한다.

43. 명시적 강제변환은 다른 타입의 값으로 변환하는 의도가 확실한 코드를 말하며 혼동의 여지를 줄이고 코드 가독성 및 유지 보수성을 높일 수 있는 장점이 있다.
암시적인 강제변환은 ‘숨겨진’ 로직에 의한 부수 효과가 있으며 타입변환이 처리되는 과정이 명확하지 않다. 그래서 암시적 강제변환이 명시적 강제변환의 정반대고 나쁜 것이라고들 하지만 (주변에 이렇게 얘기하는 사람들이 의외로 많다!) 실은 암시적 강제변환이 오히려 코드 가독성을 향상하는 장점도 있다.

44. 암시적 강제변환은 변환 과정이 구체적으로 어떻게 일어나는지 명확하게 알고 사용해야 한다. 여러분 스스로 지금 내가 무슨 코드를 짜고 있고 어떻게 작동할 거란 점은 알고 있어야 한다. 더 나아가 다른 개발자들도 쉽게 배우고 이해할 수 있는 코드를 작성하도록 노력하기 바란다.

### 5. 문법
45. continue foo는 “foo라는 레이블 위치로 이동하여 계속 순회하라”는 의미가 아니라 “foo라는 레이블이 붙은 루프의 다음 순회를 계속하라”는 뜻이다. 따라서 사실 임의적인 goto와는 다르다.

46. 레이블 루프/블록은 사용 빈도가 극히 드물고 못마땅한 구석도 많아 가능한 한 피하는 게 상책이다. 이를테면 루프 점프를 할 바에야 차라리 함수 호출이 더 낫다. 하지만 제한적이나마 도움이 되는 경우가 없지 않으므로, 만약 레이블 점프 기능을 사용할 의도라면 여러분이 뜻한 바를 상세한 주석으로 잘 문서화하기 바란다!

46. 자바스크립트 문의 레이블은 따옴표를 감싸면 안 되기 때문에 “a:는 문법에 맞는 레이블이 아니며, 그래서 : 이 그 뒤에 오면 d나 된다. 따라서 JSON은 자바스크립트 구문의 하위 집합이라 할 수 있지만, 그 자체로 올바른 자바스크립트 문법은 아니다.

47. 다수의 문을 연결하는 연산자로 ,를 사용할 때에는 이 연산자의 우선순위가 최하위라는 사실 또한 반드시 알고 있어야 한다. 즉, 어떤 연산자라도 ,보다 먼저 묶인다.

48. &&는 언제나 || 보다 먼저 평가된다는 사실이 증명되었다.

49. 세미콜론 자동 삽입  
ASI(Automatic Semicolon Insertion, 자동 세미콜론 삽입)는 자바스크립트 프로그램의 세미콜론(;)이 누락된 곳에 엔진이 자동으로 ;을 삽입하는 것을 말한다.

50. 자바스크립트 코딩시 ;을 안 써도 될 것 같은 부분에 생략을 해도 프로그램이 실행되는 이유는 모두 ASI 덕분이다. 단, ASI는 새 줄(행 바꿈, Line Break)에만 적용되며 어떠한 경우에도 줄 중간에 삽입되는 일은 없다.

51. ES6는 ‘임시 데드 존(TDZ, Temporal Dead Zone)’이라는 새로운 개념을 도입했다. TDZ는 아직 초기화를 하지 않아 변수를 참조할 수 없는 코드 영역이다.

52. 만약 finally 절에서 (사고든, 고의든) 예외가 던져지면, 이전의 실행 결과는 모두 무시한다. 즉, 이전에 try 블록에서 생성한 완료 값이 있어도 완전히 사장된다.

# Part 2. 스코프와 클로저
### 6. 스코프란 무엇인가
53. 어떤 자바스크립트 조각이라도 실행되려면 먼저 (보통 바로 직전에!) 컴파일되어야 한다는 것이다. 즉, 자바스크립트 컴파일러는 프로그램 “var a = 2;”를 받아 컴파일하여 바로 실행될 수 있게 한다.

54. 
1) 컴파일러가 ‘var a’를 만나면 스코프에게 변수 a가 특정 스코프 컬렉션 안에 있는지 묻는다. 변수 a가 이미 있다면 컴파일러는 선언을 무시하고 지나가고, 그렇지 않으면 컴파일러는 새로운 변수 a를 스코프 컬렉션 내에 선언하라고 요청한다.
2) 그 후 컴파일러는 ‘a = 2’ 대입문을 처리하기 위해 나중에 엔진이 실행할 수 있는 코드를 생성한다. 엔진이 실행하는 코드는 먼저 스코프에게 a라 부르는 변수가 현재 스코프 컬렉션 내에서 접근할 수 있는지를 확인한다. 가능하다면 엔진은 변수 a를 사용하고, 아니라면 엔진은 다른 곳을 살핀다.
엔진이 마침내 변수를 찾으면 변수에 값 2를 넣고, 못 찾는다면 엔진은 손을 들고 에러가 발생했다고 소리칠 것이다. 요약하면, 별개의 두 가지 동작을 취하여 변수 대입문을 처리한다. 첫째, 컴파일러가 변수를 선언한다(현재 스코프에 미리 변수가 선언되지 않은 경우). 둘째, 엔진이 스코프에서 변수를 찾고 변수가 있다면 값을 대입한다.

55. 스코프는 어디서 어떻게 변수(확인자)를 찾는가를 결정하는 규칙의 집합이다. 변수를 검색하는 이유는 변수에 값을 대입하거나(LHS 참조) 변수의 값을 얻어오기 위해서다(RHS 참조)

### 7. 렉시컬 스코프
56. 스코프는 목표와 일치하는 대상을 찾는 즉시 검색을 중단한다.

57. 섀도잉과 상관없이 스코프 검색은 항상 실행 시점에서 가장 안쪽 스코프에서 시작하여 최초 목표와 일치하는 대상을 찾으면 멈추고, 그전까지는 바깥/위로 올라가면서 수행한다.

58. 자바스크립트에는 렉시컬 스코프를 속이는 두 가지 방식이 있는데, eval()과 with다. Eval()은 하나 이상의 선언문을 포함하는 코드 문자열을 해석하여 렉시컬 스코프가 있다면 런타임에 이를 수정한다. With는 객체 참조를 하나의 스코프로, 속성을 확인자로 간주하여 런타임에 완전히 새로운 렉시컬 스코프를 생성한다.
이런 방식의 단점은 eval()과 with가 엔진이 컴파일 단계에서 수행한 스코프 검색과 관련된 최적화 작업을 무산시킨다는 점이다. 이들이 수행되면 엔진은 최악의 경우를 대비해 진행했던 최적화 결과가 무효화됐다고 가정해야 하기 때문이다. 따라서 eval()과 with 중 하나라도 사용하면 코드는 더 느리게 동작하므로 이 방식은 사용하지 말자.

### 8. 함수 vs 블록 스코프
59. 이 원칙은 어떤 스코프가 변수와 함수를 포함하는지에 관한 문제와도 관련이 있다. 모든 변수와 함수가 글로벌 스코프에 존재한다면 어느 중첩된 하위 스코프에서도 이들에 접근할 수 있다. 이는 ‘최소…’의 원칙을 어기는 것이고, 코드를 적절하게 사용했을 때 접근할 필요가 없어서 비공개로 남겨둬야 할 많은 변수나 함수를 노출시키게 된다.

60. 명시적으로 블록을 선언하여 변수의 영역을 한정하는 것은 효과적인 코딩 방식이므로 익혀두면 좋다.

### 9. 호이스팅
61. 변수와 함수 선언문은 선언된 위치에서 코드의 꼭대기로 ‘끌어올려’ 진다. 이렇게 선언문을 끌어올리는 동작을 ‘호이스팅(Hoisting)’이라고 한다. 즉 달결(선언문)이 닭(대입문)보다 먼저다.

62. 함수가 먼저다  
함수와 변수 선언문은 모두 끌어올려진다. 그러나 (코드에서 여러 개의 ‘중복’선언을 하면 확인할 수 있는) 미묘한 차이가 있는데, 먼저 함수가 끌어올려지고 다음으로 변수가 올려진다.

63. 블록 내 함수 선언은 지양하는 것이 가장 좋다.

64. “var a = 2;”는 하나의 구문처럼 보이지만, 자바스크립트 엔진은 그렇게 보지 않는다. 엔진은 이를 “var a”와 “a = 2”라는 두 개의 독립된 구문으로 보고, 첫째 구문은 컴파일러 단계에서 처리하고 둘째 구문은 실행 단계에서 처리한다.

### 10. 스코프 클로저
65. 깨달음의 순간이 이럴 것이다. “아, 클로저는 내 코드 전반에서 이미 일어나고 있었구나! 이제 난 클로저를 볼 수 있어.” 클로저를 이해하는 것은 네오가 매트릭스를 처음 봤을 때와 같을 것이다.

66. 클로저는 함수가 속한 렉시컬 스코프를 기억하여 함수가 렉시컬 스코프 밖에서 실행될 때에도 이 스코프에 접근할 수 있게 하는 기능을 뜻한다.

67. 어떤 방식으로 내부 함수를 자신이 속한 렉시컬 스코프 밖으로 수송하든 함수는 처음 선언된 곳의 스코프에 대한 참조를 유지한다. 즉, 어디에서 해당 함수를 실행하든 클로저가 작용한다.

68. 그러나 그게 다가 아니다! Let 선언문이 for 반복문 안에서 사용되면 특별한 방식으로 작동한다. 반복문 시작 부분에서 let으로 선언된 변수는 한 번만 선언되는 것이 아니라 반복할 때마다 선언된다. 따라서 해당 변수는 편리하게도 반복마다 이전 반복이 끝난 이후의 값으로 초기화된다.

69. 멋지지 않은가? 블록 스코프와 클로저가 함께 활약해서 모든 문제를 해결했다. 여러분은 어떨지 모르지만, 나는 자바스크립트 사용자로서 무척 기쁘다.

70. 이 모듈 패턴을 사용하려면 두 가지 조건이 있다.
1) 하나의 최외곽 함수가 존재하고, 이 함수가 최소 한 번은 호출되어야 한다(호출할 때마다 새로운 모듈 인스턴스가 생성된다).
2) 최외곽 함수는 최소 한 번은 하나의 내부 함수를 반환해야 한다. 그래야 해당 내부 함수가 비공개 스코프에 대한 클로저를 가져 비공개 상태에 접근하고 수정할 수 있다.
하나의 함수 속성만을 가지는 객체는 진정한 모듈이 아니다. 함수 실행 결과로 반환된 객체에 데이터 속성들은 있지만 닫힌 함수가 없다면, 당연히 그 객체는 진정한 모듈이 아니다.

### Appendix A. 다양한 환경의 자바스크립트
71. 자바스크립트의 공식적인 언어 명칭이 ECMAScript(ECMA는 표준 관리 주체 기관임)라는 사실은 그리 잘 알려져 있지 않다. 그럼 ‘자바스크립트’는? 자바스크립트는 ECMAScript 언어의 상품명으로 통용되며, 더 정확하게는 명세의 브라우저 구현체다.

### Appendix B. 스코프와 렉시컬 this
72. 정확하게 말하면 자바스크립트는 동적 스코프를 사용하지 않고 렉시컬 스코프만 사용한다. 단, this 메커니즘이 동적 스코프와 비슷한 면이 있다.
주요 차이점은 다음과 같다.
- 렉시컬 스코프는 작성할 때, 동적 스코프는 (그리고 this)는 런타임에 결정된다.
- 렉시컬 스코프는 어디서 함수가 선언됐는지와 관련 있지만, 동적 스코프는 어디서 함수가 호출됐는지와 관련있다.
