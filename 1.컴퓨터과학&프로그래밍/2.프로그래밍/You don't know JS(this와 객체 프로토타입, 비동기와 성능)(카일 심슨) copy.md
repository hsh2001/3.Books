# You don't know JS(this와 객체 프로토타입, 비동기와 성능)
### 지은이 : 카일 심슨
### 옮긴이 : 이일웅
### 출판사 : 한빛미디어
### 읽은 날 : 2020.03.20 ~ 2020.03.23
### 두 번째 읽은 날 : 2020.06.10

# Part1. this와 객체 프로토타입
### 1. this라나 뭐라나
### 2. this가 이런 거로군!
### 3. 객체
### 4. 클래스와 객체의 혼합
### 5. 프로토타입
### 6. 작동 위임
# Part2. 비동기와 성능
### 1. 비동기성: 지금과 나중
### 2. 콜백
### 3. 프라미스
### 4. 제너레이터
### 5. 프로그램 성능
### 6. 벤치마킹과 튜닝
### Appendix A. ES6 class
### Appendix B. asynquence 라이브러리
### Appendix C. 고급 비동기 패턴

# Part1. this와 객체 프로토타입
### 1. this라나 뭐라나
1. 렉시컬 스코프를 사용하지 말라는 게 아니다. 렉시컬 스코프 그 자체는 훌륭하고 유용한 시스템이다. 그러나 this에 대해 어렴풋이 짐작만 하다가 뭐가 좀 안 된다 싶으면 그냥 렉시컬 스코프를 다시 찾는 식으로는 발전이 없다.

2. this는 작성 식점이 아닌 런타임 시점에 바인딩 되며 함수 호출 당시 상황에 따라 콘텍스트가 결정된다고 말했다. 함수 선언 위치와 상관없이 this 바인딩은 오로지 어떻게 함수를 호출했느냐에 따라 정해진다.

3. 어떤 함수를 호출하면 활성화 레코드(Activation Record), 즉 실행 콘텍스트(Execution Context)가 만들어진다. 여기엔 함수가 호출된 근원(콜스택, Call-Stack)과 호출 방법, 전달된 인자 등의 정보가 담겨있다. this 레퍼런스는 그중 하나로, 함수가 실행되는 동안 이용할 수 있다.

### 2. this가 이런 거로군!
4. 두 메서드는 this에 바인딩 할 객체를 첫째 인자로 받아 함수 호출 시 이 객체를 this로 세팅한다. this를 지정한 객체로 직접 바인딩 하므로 이를 ‘명시적 바인딩(Explicit Binding)’이라 한다.

5. Function.prototype.call()의 두 번째 이후 인자들은 호출된 함수에 차례로 전달되며 Function.prototype.apply()는 단지 이 인자를 배열 형태로 전달합니다.
Ex)
foo.call( obj, ‘인자1’, ‘인자2’, … );
foo.apply( obj, [‘인자1’, ‘인자2’, …]);

6. 함수 앞에 new를 붙여 생성자 호출을 하면 다음과 같은 일들이 저절로 일어난다.
1) 새 객체가 툭 만들어진다.
2) 새로 생성된 객체의 [[Prototype]]이 연결된다.
3) 새로 생성된 객체는 해당 함수 호출 시 this로 바인딩 된다.
4) 이 함수가 자신의 또 다른 객체를 반환하지 않는 한 new와 함께 호출된 함수는 자동으로 새로 생성된 객체를 반환한다.

7. 명시적 바인딩이 암시적 바인딩보다 우선순위가 높음을 알 수 있다. 따라서 암시적 바인딩을 확인하기 전에 먼저 명시적 바인딩이 적용됐는지 반드시 살펴야 한다.

8. this 확정 규칙  
이제 함수 호출부에서 this가 결정되는 규칙을 우선순위에 따라 차례대로 정리해보자. 다음 항목을 순서대로 따져보고 그중 맞아떨어지는 최초 규칙을 적용한다.
1) new로 함수를 호출(new 바인딩)했는가? -> 맞으면 새로 생성된 객체가 this다.
2) call과 apply로 함수를 호출(명시적 바인딩), 이를테면 bind 하드 바인딩 내부에 숨겨진 형태로 호출됐는가? -> 맞으면 명시적으로 지정된 객체가 this다.
3) 함수를 콘텍스트(암시적 바인딩), 즉 객체를 소유 또는 포함하는 형태로 호출했는가? -> 맞으면 바로 이 콘텍스트 객체가 this다.
4) 그 외의 경우에 this는 기본값(엄격 모드는 undefined, 비엄격 모드는 전역 객체)으로 세팅된다(기본 바인딩).
이 네 가지가 대부분 함수 호출 시 this가 바인딩 되는 규칙의 전부다. 음 … 거의 전부다.

9. call, apply, bind 메서드에 첫 번째 인자로 null 또는 undefined를 넘기면 this 바인딩이 무시되고 기본 바인딩 규칙이 적용된다.

10. 변수명이야 어떻든 빈 객체를 만드는 가장 간단한 방법은 Object.create(null)이다. Object.create(null)은 {}와 비슷하나 Object.prototype으로 위임하지 않으므로 {}보다 ‘더 텅 빈(More Empty)’ 객체라고 볼 수 있다.

11. 화살표 함수의 어휘적 바인딩은 절대로 (심지어 new로도!) 오버라이드할 수 없다.

12. 어쨌거나 this 스타일의 코드를 작성해야 할 경우 어휘적 self = this 든, 화살표 함수 꼼수든 꼭 다음 두 가지 중 하나만 선택하자.
1) 오직 렉시컬 스코프만 사용하고 가식적인 this 스타일의 코드는 접어둔다.
2) 필요하면 bind()까지 포함하여 완전한 this 스타일의 코드를 구사하되 self = this나 화살표 함수 같은 소위 ‘어휘적 this’ 꼼수는 삼가야 한다.
3) 두 스타일 모두 적절히 혼용하여 효율적인 프로그래밍을 할 수도 있겠지만 동일 함수 내에서 똑 같은 것을 찾는데 서로 다른 스타일이 섞여 있으면 관리도 잘 안 되고 개발자가 천재가 아닌 이상 이해하기 곤란한 골칫덩이 코드로 남게 될 것이다.

### 3. 객체
13. 객체 프로퍼티명은 언제나 문자열이다. 문자열 이외의 다른 원시 값을 쓰면 우선 문자열로 변환된다. 배열 인덱스로 사용하는 숫자도 마찬가지이므로 공연히 객체와 배열 사이에 숫자를 써서 헷갈리는 코드를 만들지 않도록 하자.

14. Object.freeze()를 적용하면 지금까지는 전혀 영향을 받지 않았던 해당 객체가 참조하는 모든 객체를 재귀 순회하면서 Object.freeze()를 적용하여 깊숙히 동결(Deep Freeze)한다. 하지만 자칫 의도하지 않은 다른 공유된 객체까지 동결시킬 수 있어 주의해야 한다.

### 4. 클래스와 객체의 혼합
15. 자바스크립트 클래스  
꽤 오래전부터 클래스와 비슷하게 생긴 (new나 instanceof 등의) 구문 요소도 갖추고 있고 최근 ES6부터는 아예 class라는 키워드가 명세에 정식으로 추가됐다. 그럼 정말 자바스크립트는 클래스가 있는 것일까? 단도직입적으로 말해서 ‘아니다’.

16. 클래스는 디자인 패턴이므로 적잖이 공을 들이면 고전적인 클래스 기능과 얼추 비슷하게 구현할 수 있는 건 사실이다. 그간 자바스크립트는 적어도 외관상으로는 클래스처럼 생긴 구문을 제공하여 클래스 디자인 패턴을 실현하려는 욕구를 충족시키고자 많은 변신을 거듭해왔다.

17. 자식 클래스가 마치 부모 클래스에 연결된 양 다형성을 혼동하지 않길 바란다. 자식은 그저 부모에게서 자신이 필요한 내용을 베껴왔을 뿐이니… 클래스 상속은 한 마디로 ‘복사’다.

18. 일반적으로 자바스크립트에서 클래스를 모방하는 건(믹스인 패턴) 당장 닥친 문제를 해결할 순 있어도 앞으로 터질 시한폭탄을 심어놓는 것과 다름없다.

### 5. 프로토타입
19. [[Prototype]] 연쇄가 끝나는 지점은 정확히 어디일까? 일반 [[Prototype]] 연쇄는 결국 내장 프로토타입 Object.prototype에서 끝난다. 모든 자바스크립트 객체(호스트에 의해 확장되지 않은 내장 객체)는 Object.prototype 객체(최상위 [[Prototype]] 연쇄는 Object.prototype이다)의 ‘자손’이므로 Object.prototype에는 자바스크립트에서 두루 쓰이는 다수의 공용 유틸리티가 포함되어 있다.

20. 
1) [[Prototype]] 연쇄의 상위 수준에서 foo라는 이름의 일반 데이터 접근 프로퍼티가 존재하는데, 읽기 전용이 아닐 경우(writable:false), myObject의 직속 프로퍼티 foo가 새로 추가되어 결국 ’가려짐 프로퍼티(Shadowed Property)’가 된다.
2) [[Prototype]] 연쇄의 상위 수준에서 발견한 foo가 읽기 전용(writable:false)이면 이 프로퍼티를 세팅하거나 myObject 객체에 가려짐 프로퍼티를 생성하는 따위의 일은 일어나지 않는다. 엄격 모드에선 에러가 나며 비엄격 모드에선 프로퍼티 세팅은 조용히 무시된다. 어쨌든 가려짐은 발생하지 않는다.
3) [[Prototype]] 연쇄의 상위 단계에서 발견된 foo가 세터일 경우 항상 이 세터가 호출된다. myObject에 가려짐 프로퍼티 foo를 추가하지 않으며 foo 세터를 재정의하는 일 또한 없다.

21. [[Prototype]] 연쇄의 상위 수준에 이미 존재하는 프로퍼티에 값을 할당하려면([[Put]]) 반드시 가려짐이 발생할 것 같지만 보다시피 1)번 경우에만 해당하는 얘기다.
2), 3)번에서 foo를 가리려면 = 할당 연산자를 쓰면 안 되고 Object.defineProperty() 메서드를 사용하여 myObject에 foo를 추가해야 한다.

22. 상속은 기본으로 복사를 수반하지만, 자바스크립트는 객체 프로퍼티를 복사하지 않는다(원래 처음부터 그랬다). 대신 두 객체에 링크를 걸어두고 한쪽이 다른 쪽의 프로퍼티/함수에 접근할 수 있게 위임한다. 위임(Delegation)이야말로 자바스크립트 객체-연결 체계를 훨씬 더 정확하게 나타낸 용어다.

23. 자바스크립트는 앞에 new를 붙여 호출한 함수를 모두 ‘생성자’라 할 수 있다. 함수는 결코 생성자가 아니지만 new를 사용하여 호출할 때에만 ‘생성자 호출’이다.

24. Bar.prototype = Object.create( Foo.prototype ) 부분이 중요하다. Object.create()를 실행하면 난데없이 ‘새로운’ 객체를 만들고 내부 [[Prototype]]을 지정한 객체(Foo.prototype)에 링크한다. 다른 말로, “Foo 점 프로토타입과 연결된 새로운 Bar 점 프로토타입 객체를 생성하라”는 뜻이다.

25. 기묘한 이름의 .__proto__ 프로퍼티(ES5까지는 비표준이다!)로 객체 내부의 [[Prototype]]을 ‘마술처럼’ 엿볼 수 있다. 프로토타입 연쇄를 직접 확인하고 싶을 때 (.__proto__.__proto__ 식으로 체이닝도 가능) 매우 유용하다.

26. 객체에 존재하지 않는 프로퍼티를 접근하려고 시도하면 [[Get]]은 해당 객체의 내부 [[Prototype]] 링크를 따라 다음 수색 장소를 결정한다. 프로퍼티를 찾아 이 객체에서 저 객체로 줄줄이 삼만리 순회를 하기 위한 연결 경로는 (중첩된 스코프 연쇄와 비슷한) ‘프로토타입 연쇄’에 잘 정의되어 있다.

27. 모든 일반 객체의 최상위 프로토타입 연쇄(스코프 식으로 말하면 전역 스코프)에는 내장 Object.prototype이 버티고 있다. 겨국, 이 지점까지 이르러서도 발견되지 않으면 프로퍼티 수색 작전은 그대로 종료된다. toString(), valueOf() 등의 공용 유틸리티들은 바로 Object.prototype에 구현된 덕분에 자바스크립트의 모든 객체가 언제든지 이용할 수 있다.

### 6. 작동 위임

# 두 번째 Reading

# Part1. this와 객체 프로토타입
### 1. this라나 뭐라나
1. arguments.callee도 실행 중인 함수 객체를 가리키지만 꽤 오래전 등자앟여 지금은 권장하지 않는Deprecated 레퍼런스다. 과거에는 익명 함수 객체를 내부에서 접근할 때 쓰는 유일한 방법이었지만 자기 참조가 필요하다면 익명 함수를 쓰기보단 이름 붙은 함수(표현식)를 사용하는 게 최선이다. arguments.callee는 이제 옛 유물이니 더는 쓰지 말자.

2. this는 작성 시점이 아닌 런타임 시점에 바인딩 되며 함수 호출 당시 상황에 따라 콘텍스트가 결정된다고 말했다. 함수 선언 위치와 상관없이 this 바인딩은 오로지 어떻게 함수를 호출했느냐에 따라 정해진다.

3. 어떤 함수를 호출하면 활성화 레코드Activation Record, 즉 실행 콘텍스트Execution Context가 만들어진다. 여기엔 함수가 호출된 근원(콜스택Call-Stack)과 호출 방법, 전달된 인자 등의 정보가 담겨있다. this 레퍼런스는 그중 하나로, 함수가 실행되는 동안 이용할 수 있다.

4. 정리하기  
this 바인딩은 그 작동 원리를 철저하게 학습하지 않은 자바스크립트 개발자에게 예나 지금이나 애매한 주제다. 대충 감으로 때려잡고 시행착오를 반복하다가 스택오버플로우 같은 사이트에서 아무렇게나 남의 코드를 카피 앤 페이스트하는 식으로는 this 체계의 핵심을 반의반도 파악하기 어렵다.  
this를 제대로 배우고 싶다면 먼저 가지고 있는 별의별 오해와 추측을 내버리고 this가 함수 자신이나 함수의 렉시컬 스코프를 가리키는 레퍼런스가 아니라는 점을 분명히 인지해야 한다.  
this는 실제로 함수 호출 시점에 바인딩 되며 무엇을 가리킬지는 전적으로 함수를 호출한 코드에 달렸다.

### 2. this가 이런 거로군!
5. this 바인딩의 개념을 이해하려면 먼저 호출부, 즉 함수 호출(선언이 아니다) 코드부터 확인하고 'this가 가리키는 것'이 무엇인지 찾아봐야 한다.  
호출부는 '함수를 호출한 지점'으로 돌아가면 금세 확인할 수 있을 것 같지만 코딩 패턴에 따라 '진짜' 호출부가 어디인지 모호할 때가 많아 생각만큼 그리 쉽지 않다. 중요한 건 호출 스택(현재 실행 지점에 오기까지 호출된 함수의 스택)을 생각해보는 것이다. 이 중 호출부는 현재 실행 중인 함수 '직전'의 호출 코드 '내부'에 있다.

6. 예제의 주석처럼 함수 호출 연쇄를 순서대로 잘 따라가면 호출 스택을 머릿속에 그려볼 수 있다. 하지만 그 과정에서 머리가 아프고 착오를 일으킬 수 있는데, 이럴 때 브라우저 디버거 툴을 사용하면 좋다. 요즘 대부분 데스크톱 브라우저에는 자바스크립트 디버가가 포함된 개발자 툴이 기본 탑재되어 있다. foo() 함수 첫째 줄을 디버거 툴에서 중단점으로 설정하거나 그냥 디버거에 코드 내용을 직접 쳐도 된다. 페이지를 로딩 하면 디버거는 중단점에서 잠시 실행을 멈추고 해당 라인까지 호출된 함수 목록, 즉 호출 스택을 표시한다. 따라서 this 바인딩을 분석하려면 일단 디버거 툴로 호출 스택을 확인하고 맨 위부터 아래로 죽 내려오면서 실제 호출부를 찾으면 된다.

7. 기본 바인딩이 적용되어 this는 전역 객체를 참조한다.

8. 암시적 바인딩  
function foo() {
    console.log(this.a);
}
var obj = {
    a: 2,
    foo: foo
}
obj.foo(); // 2
앞에서 선언한 foo()함수를 obj에서 프로퍼티로 참조하고 있다. foo()를 처음부터 foo 프로퍼티로 선언하든 이 예제처럼 나중에 레퍼런스로 추가하든 obj 객체가 이 함수를 정말로 '소유'하거나 '포함'한 것은 아니다. 그러나 호출부는 obj 콘텍스트로 foo()를 참조하므로 obj 객체는 함수 호출 시점에 함수의 레퍼런스를 '소유'하거나 '포함'한다고 볼 수 있다.  
이런 패턴을 뭐라 하건 foo() 호출 시점에 이미 obj 객체 레퍼런스는 준비된 상태다. 함수 레퍼런스에 대한 콘텍스트 객체가 존재할 때 암시적 바인딩Implicit Binding 규칙에 따르면 바로 이 콘텍스트 객체가 함수 호출 시 this에 바인딩 된다. foo() 호출 시 obj는 this이니 this.a는 obj.a가 된다.

9. 명시적 바인딩  
암시적 바인딩에선 함수 레퍼런스를 객체에 넣기 위해 객체 자신을 변형해야 했고 함수 레퍼런스 프로퍼티를 이용하여 this를 간접적으로(암시적으로) 바인딩 했다. 그런데 함수 레퍼런스 프로퍼티를 객체에 더하지 않고 어떤 객체를 this 바인딩에 이용하겠다는 의지를 코드에 명확히 밝힐 방도는 없을까?  
이럴 때 '모든' 자바스크립트 함수가 함께 사용할 수 있는 아주 적당한 유틸리티가 바로 call()과 apply() 메서드다. 극히 드물지만 일부 자바스크립트 호스트 환경은 두 메서드 대신 자신만의 특수한 함수를 제공하기도 한다. 어쨌든 여러분이 작성한 모든 함수를 포함하여 대부분 함수가 call()과 apply() 메서드를 이용할 수 있다.  
두 메서드는 this에 바인딩 할 객체를 첫째 인자로 받아 함수 호출 시 이 객체를 this로 세팅한다. this를 지정한 객체로 직접 바인딩 하므로 이를 '명시적 바인딩Explicit Binding'이라 한다.

10. Function.prototype.call()의 두 번째 이후 인자들은 호출된 함수에 차례로 전달되며 Function.prototype.apply()는 단지 이 인자를 배열 형태로 전달합니다.  
예 : foo.call(obj, '인자1', '인자2', ...);
     foo.apply(obj, ['인자1', '인자2', ...]);

11. bind()는 주어진 this 콘텍스트로 원본 함수를 호출하도록 하드 코딩된 새 함수를 반환한다. 

12. Number 생성자  
new 표현식의 일부로 호출 시 Number는 생성자이며 새로 만들어진 객체를 초기화한다.  
따라서 Number() 같은 부류의 내장 객체 함수는 물론이고 상당수의 옛 함수는 앞에 new를 붙여 호출할 수 있고 이는 결국 '생성자 호출Constructor Call'이나 다름없다. 미묘한 차이를 잘 구분하는 것이 중요한데, '생성자 함수Constructof Function'가 아니라(실제로 이런 건 없다) '함수를 생성하는 호출Construction Calls Of Functions'이라고 해야 옳다.  
함수 앞에 new를 붙여 생성자 호출을 하면 다음과 같은 일들이 저절로 일어난다.
1) 새 객체가 툭 만들어진다.
2) 새로 생성된 객체의 [[Prototype]]이 연결된다.
3) 새로 생성된 객체는 해당 함수 호출 시 this로 바인딩 된다.
4) 이 함수가 자신의 또 다른 객체를 반환하지 않는 한 new와 함께 호출된 함수는 자동으로 새로 생성된 객체를 반환한다.

13. 앞에 new를 붙여 foo()를 호출했고 새로 생성된 객체는 foo 호출 시 this에 바인딩 된다. 따라서 결국 new는 함수 호출 시 this를 새 객체와 바인딩 하는 방법이며 이것이 'new 바인딩'이다.

14. 명시적 바인딩이 암시적 바인딩보다 우선순위가 높음을 알 수 있다. 따라서 암시적 바인딩을 확인하기 전에 먼저 명시적 바인딩이 적용됐는지 반드시 살펴야 한다.

15. new 바인딩이 암시적 바인딩보다 우선순위가 높다.

16. 예제 코드를 보기 전에 하드 바인딩의 물리적인 작동 원리를 곱씹어보자. Function.prototype.bind()는 어떤 종류든 자체 this 바인딩을 무시하고 주어진 바인딩을 적용하여 하드 코딩된 새 래퍼 함수를 생성한다.

17. 따라서 명시적 바인딩의 한 형태인 하드 코딩이 new 바인딩보다 우선순위가 높고 new로 오버라이드할 수 없다는 사실을 짐작할 수 있다.

18. this 확정 규칙  
이제 함수 호출부에서 this가 결정되는 규칙을 우선순위에 따라 차례대로 정리해보자. 다음 항목을 순서대로 따져보고 그중 맞아떨어지는 최초 규칙을 적용한다.  

1) new로 함수를 호출(new 바인딩)했는가? -> 맞으면 새로 생성된 객체가 this다.  
var bar = new foo();

2) call과 apply로 함수를 호출(명시적 바인딩), 이를테면 bind 하드 바인딩 내부에 숨겨진 형태로 호출됐는가? -> 맞으면 명시적으로 지정된 객체가 this다.
var bar = foo.call(obj2);

3) 함수 콘텍스트(암시적 바인딩), 즉 객체를 소유 또는 포함하는 형태로 호출했는가? -> 맞으면 바로 이 콘텍스트 객체가 this다.
var bar = obj1.foo();

4) 그 외의 경우에 this는 기본값(엄격 모드는 undefined, 비엄격 모드는 전역 객체)으로 세팅된다(기본 바인딩).

이 네 가지가 대부분 함수 호출 시 this가 바인딩 되는 규칙의 전부다. 음.. 거의 전부다.

19. this 무시  
call, apply, bind 메서드에 첫 번째 인자로 null 또는 undefined를 넘기면 this 바인딩이 무시되고 기본 바인딩 규칙이 적용된다.

20. 변수명이야 어떻든 빈 객체를 만드는 가장 간단한 방법은 Object.create(null)이다. Object.create(null)은 {}와 비슷하나 Object.prototype으로 위임하지 않으므로 {}보다 '더 텅 빈More Empty' 객체라고 볼 수 있다.

21. 소프트 바인딩  
함수 호출 시 애초 의도와는 다르게 기본 바인딩 규칙이 적용되는 걸 막기 위해 (new로 오버라이드하지 않고!) this를 강제하는 하드 바인딩 기법은 앞에서 이미 언급했다. 그런데 문제는 하드 바인딩은 함수의 유연성을 크게 떨어뜨리기 때문에 this를 암시적 바인딩 하거나 나중에 다시 명시적 바인딩 하는 식으로 수동으로 오버라이드하는 것이 불가능하다.

22. 어휘적 this  
일반적인 함수는 지금까지 살펴본 4가지 규칙을 준수한다. 하지만 ES6부터는 이 규칙들을 따르지 않는 특별한 함수가 있따. 바로 화살표 함수다. 화살표 함수는 function키워드 대신 뚱뚱한 화살표 연산자로 불리는 '=>'를 써서 표현하며, 4가지 표준 규칙 대신 에두른 스코프Enclosing Scope(함수 또는 전역)를 보고 this를 알아서 바인딩 한다.

23. foo() 내부에서 생성된 화살표 함수는 foo() 호출 당시 this를 무조건 어휘적으로 포착한다. foo()는 obj1에 this가 바인딩 되므로 bar(반환된 화살표 함수를 가리키는 변수)의 this 역시 obj1로 바인딩 된다. 화살표 함수의 어휘적 바인딩은 절대로 (심지어 new로도!) 오버라이드할 수 없다.

24. 화살표 함수는 this를 확실히 보장하는 수단으로 bind()를 대체할 수 있고 겉보기에도 끌리는 구석이 있지만, 결과적으로 더 잘 알려진 렉시컬 스코프를 쓰겠다고 기존의 this 체계를 포기하는 형국이라는 점을 간과하면 안 된다. ES6 이전에도 화살표 함수의 기본 기능과 크게 다르지 않은, 나름대로 많이 쓰이던 패턴이 있었다.  
self = this나 화살표 함수 모두 bind() 대신 사용 가능한 좋은 해결책이지만 this를 제대로 이해하고 수용하기보단 골치 아픈 this에서 도망치려는 꼼수라고 할 수 있다.

25. 어쨌거나 this 스타일의 코드를 작성해야 할 경우 어휘적 self = this든 화살표 함수 꼼수든 꼭 다음 두 가지 중 하나만 선택하자.  
1) 오직 렉시컬 스코프만 사용하고 가식적인 this 스타일 코드는 접어둔다.  
2) 필요하면 bind()까지 포함하여 완전한 this 스타일의 코드를 구사하되 self = this나 화살표 함수 같은 소휘 '어휘적 this' 꼼수는 삼가야 한다.
3) 두 스타일 모두 적절히 혼용하여 호율적인 프로그래밍을 할 수도 있겠지만 동일 함수 내에서 똑같은 것을 찾는데 서로 다른 스타일이 섞여 있으면 관리도 잘 안되고 개발자가 천재가 아닌 이상 이해하기 곤란한 골칫덩이 코드로 남게 될 것이다.

26. 정리하기  
함수 실행에 있어서 this 바인딩은 함수의 직접적인 호출부에 따라 달라진다. 일단 호출부를 식별한 후 다음 4가지 규칙을 열거한 우선순위에 따라 적용한다.
1) new로 호출했다면 새로 생성된 객체로 바인딩 된다.  
2) call이나 apply 또는 bind로 호출됐다면 주어진 객체로 바인딩 된다.  
3) 호출의 주체인 콘텍스트 객체로 호출됐다면 바로 이 콘텍스트 객체로 바인딩 된다.  
4) 기본 바인딩에서 엄격 모드는 undefined, 그 밖엔 전역 객체로 바인딩 된다.  

실수로 또는 예기치 않게 기본 바인딩 규칙이 적용되는 경우를 조심해야 한다. this 바인딩을 안전하게 하고 싶으면 공집합기호 = Object.create(null)처럼 DMZ 객체를 자리 끼움 값으로 바꿔 넣어 뜻하지 않은 부수 효과가 전역 객체에서 발생하지 ㅇ낳게 한다.  
ES6 화살표 함수는 표준 바인딩 규칙을 무시하고 렉시컬 스코프로 this를 바인딩 한다. 즉, 에두른 함수 호출로부터 어떤 값이든 this 바인딩을 상속한다. 이는 ES6 이전 시절 self = this 구문을 대체한 장치다.

### 3. 객체
27. 한편, 얕은 복사는 이해하기 쉽고 별다른 이슈가 없기에 ES6부터는 Object.assign() 메서드를 제공한다. 이 메서드의 첫째 인자는 타깃 객체고 둘째 인자 이후는 하나 또는 둘 이상의 소스 객체Source Object로, 소스 객체의 모든 열거 가능한 것Enumerable과 보유 키Owned Keys를 순회하면서(= 할당문만으로) 타깃 객체로 복사한다. 그래서 다음과 같이 타깃 객체를 간편하게 만들 수 있다.  
var newObj = Object.assign({}, myObject);

28. 다음 절에서는 '프로퍼티 서술자(프로퍼티 특성)'를 설명하고 Object.defineProperty()의 사용법을 예로 보여준다. Object.assign()은 순수하게 = 할당에 의해서만 복사하므로 writable같은 특수한 프로퍼티의 속성은 타깃 객체에 복사되지 않는다.

29. 보다시피, 평범한 객체 프로퍼티 a의 프로퍼티 서술자(데이터값을 담아두는 프로퍼티여서 '데이터 서술자'라고도 한다)를 조회해보니 2 말고도 writable, enumerable, configurable의 세 가지 특성이 더 있다.  
Object.getOwnPropertyDescriptor(myObject, "a");

30. configurable은 일단 false가 되면 돌아올 수 없는 강을 건너게 되어 절대로 복구되지 않으니 유의하자.

31. 
var myObject = {
    a: 2
};
myObject.a; // 2  
myObject.a는 누가 봐도 프로퍼티 접근이지만 보이는 것처럼 a란 이름의 프로퍼티를 myObject에서 찾지 않는다. 명세에 따르면 실제로 이 코드는 myObject에 대해 [[Get]] 연산([[Get]]()같은 함수 호출)을 한다.  
기본으로 [[Get]] 연산은 주어진 이름의 프로퍼티를 먼저 찾아보고 있으면 그 값을 반환한다. 프로퍼티를 찾아보고 없으면 [[Get]] 연산 알고리즘은 다른 중요한 작업을 하도록 정의되어 있는데, 이 부분([[Prototype]] 연쇄 순회)은 5장 프로토타입에서 따로 설명한다.

32. in 연산자는 어떤 프로퍼티가 해당 객체에 존재하는지 아니면 이 객체의 [[Prototype]] 연쇄를 따라갔을 때 상위 단계에 존재하는지 확인한다. 이와 달리 hasOwnProperty()는 단지 프로퍼티가 객체에 있는지만 확인하고 [[Prototype]] 연쇄는 찾지 않는다.

33. 거의 모든 일반 객체는 Object.prototype 위임을 통해 hasOwnProperty()에 접근할 수 있지만 간혹 (Object.create(null)) Object.prototype과 연결되지 않은 객체는 myObject.hasOwnProperty() 처럼 사용할 수 없다.  
이럴 경우엔 Object.prototype.hasOwnProperty.call(myObject, "a")처럼 기본 hasOwnProperty() 메서드를 빌려와 myObject에 대해 명시적으로 바인딩하면 좀 더 확실하게 확인할 수 있다.

34. 정리하기  
자바스크립트 객체는 리터럴 형식(예 : var a = {})과 생성자 형식(예 : var a = new Array()) 두 가지 형태를 가진다. 대부분 리터럴 형식을 쓰는 편이 좋지만 생성 시 옵션을 더 주기 위해 생성자 형식을 쓰는 경우도 더러 있다.

많은 사람이 "자바스크립트는 모든 것이 다 객체다"라고 말하지만 사실과 다르다. 객체는 6개(관점에 따라 7개가 될 수도 있다)의 원시 타입 중 하나고 함수를 비롯한 하위 타입이 있따. 이를테면 내부적으로 [object Array]라는 레이블로 표시되는 배열 객체라는 독특한 하위 타입도 가능하다.

객체는 키/값의 쌍을 모아 놓은 저장소고 값은 프로퍼티를 통해 (.propName 또는 ["propName"] 식으로) 접근할 수 있다. 프로퍼티에 접근하면 엔진 내부에서는 실제로 기본 [[Get]](값을 세팅할 땐 [[Put]]) 연산을 호출하는데, 객체 자체에 포함된 프로퍼티뿐만 아니라 필요하면 [[Prototype]] 연쇄를 순회하며 찾아본다.

프로퍼티는 프로퍼티 서술자를 통해 제어 가능한 writable, configurable 등의 특정한 속성을 지닌다. 그리고 객체는 Object.preventExtensions(), Object.seal(), Object.freeze() 등을 이용하여 자신에게 (그리고 자신이 가지고 있는 프로퍼티까지) 여러 단계의 불변성을 적용할 수 있다.

프로퍼티가 반드시 값을 가져야 하는 것은 아니며 게터/세터로 '접근자 프로퍼티' 형태를 취할 수도 있다. 예를 들어, 열거 가능성을 조정하여 for ... in 루프 순회 시 노출 여부를 마음대로 바꿀 수 있다.

ES6부터는 for ... of 구문에서 한 번에 하나씩 다음 데이터값으로 이동하는 next() 메서드를 가진 내장/커스텀 @@iterator 객체를 통해 자료 구조(배열, 객체 등)에서 여러 값을 순회할 수 있다.

### 4. 클래스와 객체의 혼합
35. 클래스 지향 개념은 자바스크립트 객체 체계와는 태생부터 잘 맞지 않아 지금껏 수많은 개발자가 이런 한계를 극복하고 기능을 확장(믹스인Mixin 등)하고자 노력해 왔다.

36. 함수형 프로그래밍(모나드Monads 등)을 경험해 봤다면 클래스가 단지 많이 쓰는 서너 개 디자인 패턴 중 하나라는 사실 또한 잘 알고 있을 것이다. 하지만 대부분 독자에게 클래스가 과연 모든 코드의 근본적인 기초일까 아니면 코드를 선택적으로 추상화한 것일까란 의문을 품는 자체가 어색하게 느껴질 것이다.

37. 자바스크립트 클래스  
자, 그렇다면 자바스크립트는 어떤가? 꽤 오래전부터 클래스와 비슷하게 생긴 (new나 instanceof 등의) 구문 요소도 갖추고 있고 최근 ES6부터는 아예 class라는 키워드가 명세에 정식으로 추가됐다. 그럼 정말 자바스크립트는 클래스가 있는 것일까? 단도직입적으로 말해서 '아니다'.

38. 클래스는 디자인 패턴이므로 적잖이 공을 드리면 고전적인 클래스 기능과 얼추 비슷하게 구현할 수 있는 건 사실이다. 그간 자바스크립트는 적어도 외관상으로는 클래스처럼 생긴 구문을 제공하여 클래스 디자인 패턴을 실현하려는 욕구를 충족시키고자 많은 변신을 거듭해왔다.

39. 어쨌거나 결론은, 클래스는 소프트웨어 디자인 패턴 중 한 가지 옵션일 뿐이니 자바스크립트에서 클래스를 쓸지 말지는 결국 자신이 결정할 문제라는 것이다. 워낙 많은 개발자가 클래스 지향 소프트웨어 디자인에 익숙한 터라 지금부터 이 장이 끝날 때까지 자바스크립트가 제공하는 클래스라는 환상을 유지하기 위해 치러야 하는 대가와 내가 겪은 시행착오를 이야기하고자 한다.

40. 완공된 건물은 청사진 (가능하다면 본질적으로 완벽한 사본인) 물리적 인스턴스다. 시공사는 이제 다음 부지로 옮겨 같은 건물을 처음부터 다시 짓는다.

41. 클래스가 바로 청사진에 해당한다. 개발자가 상호 작용할 실제 객체는 클래스라는 붕어빵 틀에서 구워낸다(인스턴스화한다). 이 '구워냄'의 최종 결과가 인스턴스라는 객체고 개발자는 객체 메서드를 직접 호출하거나 공용Public 데이터 프로퍼티에 접근한다. 객체는 클래스에 기술된 모든 특성을 그대로 가진 사본이다.

42. 대부분 언어는 예제에서 만들어낸 inherited 대신 uper라는 키워드를 사용하며, 이는 'superclass'를 현재 클래스의 부모/조상이라고 간주하는 것이다.  
같은 이름의 메서드가 상속 연쇄의 수준별로 다르게 구현되어 있고 이 중 어떤 메서드가 적절한 호출 대상인지 자동으로 선택하는 것 또 한 다형성(Polymorphism)의 특징이다.

43. 정리하기  
클래스는 디자인 패턴의 일종이다. 많은 언어에서 클래스 지향 소프트웨어 디자인이 가능한 구문을 처음부터 제공하는데, 자바스크립트에도 역시 유사한 구문이 있다. 그러나 자바스크립트에서 클래스의 의미는 다른 언어들과 다르다.

클래스는 복사를 의미한다. 전통적인 클래스는 인스턴스화하면[클래스 -> 인스턴스]로 복사가 일어난다. 클래스를 상속하면 역시 [부모 -> 자식] 방향으로 복사된다. 다형성(같은 이름을 가진 복수의 함수가 상속 연쇄의 여러 수준에 존재)은 얼핏 보면 [자식 -> 부모] 방향의 상대적 레퍼런스가 아닐까 싶지만 그냥 복사 작업의 결과물일 뿐이다.

자바스크립트는 (클래스의 취지에 맞게) 객체 간 사본을 자동으로 생성하지 않는다. 믹스인 패턴(명시적/암시적)은 클래스의 복사 기능을 모방하기 위해 종종 쓰이지만 대부분 명시적 의사다형성(OtherObj.method Name.call(this, ...))처럼 보기 싫고 취약한 구문이 되어 가독성이 점점 더 떨어지고 유지 보수도 어려운 코드가 된다.

명시적 믹스인은 클래스의 복사 기능과 같지 않다. 이는 객체(그리고 함수!) 그 자체가 아니라 단지 공유된 레퍼런스만 복사하기 때문이다. 이런 부분에 유의하지 않으면 이상한 함정에 빠져 고생할 수 있다.

일반적으로 자바스크립트에서 클래스를 모방하는 건 당장 닥친 문제를 해결할 순 있어도 앞으로 터질 시한폭탄을 심어놓는 것과 다름없다.

### 5. 프로토타입
44. 하지만 myObject에 a란 프로퍼티가 없으면 다음 관심사는 이 객체의 [[Prototype]] 링크다. [[Get]]은 주어진 프로퍼티를 객체에서 찾지 못하면 곧바로 [[Prototype]] 링크를 따라가면서 수색작전을 벌인다.

45. for ... in 루프에서 객체를 순회할 때도 [[Prototype]] 연쇄의 검색 과정과 비슷한 방식으로 연쇄를 통해 손길이 닿는 프로퍼티라면 죄다 열거한다. in 연산자로 객체에 프로퍼티 유무를 확인할 때에는 (열거 가능 여부와 상관없이) 객체의 연쇄를 전부 샅샅이 뒤진다.

46. 어떤 방식이든 객체에서 프로퍼티를 검색할 때 [[Prototype]] 연쇄를 한 번에 한 링크씩(해당 프로퍼티를 찾거나 연쇄가 끝날 때까지) 계속 뒤진다.

47. Object.prototype  
[[Prototype]] 연쇄가 끝나는 지점은 정확히 어디일까? 일반 [[Prototype]] 연쇄는 결국 내장 프로토타입 Object.prototype에서 끝난다. 모든 자바스크립트 객체(호스트에 의해 확장되지 않은 내장 객체)는 Object.prototype 객체(최상위 [[Prototype]] 연쇄는 Object.prototype이다)의 '자손'이므로 Object.prototype에는 자바스크립트에서 두루 쓰이는 다수의 공용 유틸리티가 포함되어 있다.

48. .toString()이나 .valueOf()처럼 익숙한 유틸리티도 그렇고 3장 객체에서 봤던 hasOwnProperty()와 이 장 뒷부분에서 설명할 .isPrototypeOf() 역시 마찬가지다.

49. myObject.foo = "bar";  
foo라는 프로퍼티명이 myObject 객체와 이 객체를 기점으로 한 [[Prototype]] 연쇄의 상위 수준 두 곳에서 동시에 발견될 때 이를 가려짐Shadowing이라 한다. myObject에 직속한 foo 때문에 상위 연쇄의 foo가 가려지는 것이다. 이는 myObject.foo로 검색하면 언제나 연쇄의 최하위 수준에서 가장 먼저 foo 프로퍼티를 찾기 때문에 그렇다.  

50. 짐작하겠지만 myObject 객체에서 foo의 가려짐은 생각보다 그리 간단한 문제가 아니다. myObject에 직속한 foo는 없으나 myObject [[Prototype]] 연쇄의 상위 수준에 foo가 있을 때 myObject.foo = "bar" 할당문의 실행 결과 다음 세 가지 경우의 수가 따른다.

1) [[Prototype]] 연쇄의 상위 수준에서 foo라는 이름의 일반 데이터 접근 프로퍼티가 존재하는데, 읽기 전용이 아닐 경우(writable:false), myObject의 직속 프로퍼티 foo가 새로 추가되어 결국 '가려짐 프로퍼티Shadowed Property'가 된다.

2) [[Prototype]] 연쇄의 상위 수준에서 발견한 foo가 읽기 전용(writable:false)이면 이 프로퍼티를 세팅하거나 myObject 객체에 가려짐 프로퍼티를 생성하는 따위의 일은 일어나지 않는다. 엄격 모드에선 에러가 나며 비엄격 모드에선 프로퍼티 세팅은 조용히 무시된다. 어쨌든 가려짐은 발생하지 않는다.

3) [[Prototype]] 연쇄의 상위 단계에서 발견된 foo가 세터일 경우 항상 이 세터가 호출된다. myObject에 가려짐 프로퍼티 foo를 추가하지 않으며 foo 세터를 재정의하는 일 또한 없다.

[[Prototype]] 연쇄의 상위 수준에 이미 존재하는 프로퍼티에 값을 할당하면 ([[Put]]) 반드시 가려짐이 발생할 것 같지만 보다시피 1)번 경우에만 해당하는 얘기다.  
2), 3)번에서 foo를 가리려면 = 할당 연산자를 쓰면 안 되고 Object.defineProperty() 메서드를 사용하여 myObject에 foo를 추가해야 한다.

51. 상속은 기본으로 복사를 수반하지만, 자바스크립트는 객체 프로퍼티를 복사하지 않는다(원래 처음부터 그랬다). 대신 두 객체에 링크를 걸어두고 한쪽이 다른 쪽의 프로퍼티/함수에 접근할 수 있게 위임한다. 위임Delegation이야말로 자바스크립트 객체-연결 체계를 훨씬 더 정확하게 나타낸 용어다.

52. 실은 new 키워드는 일반 함수 호출을 도중에 가로채어 원래 수행할 작업 외에 객체 생성이라는 잔업을 더 부과하는 지시자다.

53. 자바스크립트는 앞에 new를 붙여 호출한 함수를 모두 '생성자'라 할 수 있다. 함수는 결코 생성자가 아니지만 new를 사용하여 호출할 때에만 '생성자 호출'이다.

54. 
ES5)
Bar.prototype = Object.create(Foo.prototype);

ES6)
Object.setPrototypeOf(Bar.prototype, Foo.prototype);

55. isPrototypeOf()는 'a은 전체 [[Prototype]] 연쇄에 Foo.prototype이 있는가'라는 질문에 대답한다. 똑같은 원리지만 isPrototypeOf를 쓰면 간접적으로 참조할 함수(Foo)의 .prototype 프로퍼티를 거치는 등의 잡다한 과정이 생략되는 장점이 있다.

56. Object.create()는 먼저 새로운 객체(bar)를 생성하고 주어진 객체(foo)와 연결한다. 이것만으로도 난 클래스나 생성자 호출, 헷갈리는 .prototype이나 .constructor 레퍼런스 등을 동원한 함수로 쓸데없이 골치 아프게 하지 않으면서도 [[Prototype]] 체계의 진정한 힘(위임)을 실감하게 된다.

57. Object.create(null)은 [[Prototype]] 링크가 빈(null) 객체를 생성하므로 이젠 위임할 곳이 전혀 없다. 이런 객체는 프로토타입 연쇄 자체가 존재하지 않기 때문에 instanceof 연산 결과는 항상 false다(체크할 대상이 없다). 이렇듯 빈 [[Prototype]]을 가진 객체는 특이하게도 [[Prototype]]이 위임된 프로퍼티/함수들로부터 어떠한 영향도 받을 일도 없고 일차원적인 데이터 저장소로 제격이므로 순수하게 프로퍼티에 데이터를 저장하는 용도로 사용하며, 이를 보통 '딕셔너리Dictionary'라고 한다.

58. 정리하기  
객체에 존재하지 않는 프로퍼티를 접근하려고 시도하면 [[Get]]은 해당 객체의 내부 [[Prototype]] 링크를 따라 다음 수색 장소를 결정한다. 프로퍼티를 찾아 이 객체에서 저 객체로 줄줄이 삼만리 순회를 하기 위한 연결 경로는 (중첨된 스코프 연쇄와 비슷한) '프로토타입 연쇄'에 잘 정의되어 있다.

모든 일반 객체의 최상위 프로토타입 연쇄(스코프 식으로 말하면 전역 스코프)에는 내장 Object.prototype이 버티고 있다. 결국, 이 지점까지 이르러서도 발견되지 않으면 프로퍼티 수색작전은 그대로 종료된다. toString(), valueOf() 등의 공용 유틸리티들은 바로 Object.prototype에 구현된 덕분에 자바스크립트의 모든 객체가 언제든지 이용할 수 있다.

두 객체를 서로 연결 짓는 가장 일반적인 방법은 함수 호출 시 new 키워드를 앞에 붙이는 것이다. 네 가지 절차를 거쳐 다른 객체와 연결된 새로운 객체가 탄생한다.

새로운 객체와 손잡은 '다른 객체'는 new를 이용하여 호출된 함수의 .prototype이라고 임의로 명명한 프로퍼티를 통해 참조할 수 있다. 여기서 new로 호출한 함수를 '생성자'라고 보통 일컫는데, 여타의 클래스 지향 언어에서 말하는 (진짜 클래스를 인스턴스화하는) 생성자와는 개념이 전혀 다르다.

자바스크립트 체계가 전통적인 클래스 지향 언어의 '클래스 인스턴스화 및 클래스 상속'과 유사해 보이지만 자바스크립트에서는 복사가 일어나지 않는다는 결정적인 차이가 있다. 그러나 객체는 결국 다른 객체와 내부 [[Prototype]] 연쇄를 통해 연결된다.

상속 (그리고 '프로토타입 상속') 등의 일반적인 객체 지향 용어들이 (멘탈 모델에 억지로 끼워 맞춘 것 말고) 실제로 자바스크립트가 작동하는 방식과는 커다란 격차가 있다는 사실은 여러 측면에서 설명할 수 있다.

사실 자바스크립트 객체 간의 관계는 복사되는 게 아니라 위임 연결이 맺어진 것이므로 '위임'이라고 해야 더 적절한 표현이다.

5장 프로토타입의 결론을 한 문장으로 요약하면 이렇다. [[Prototype]] 체계는 한 객체가 다른 객체를 참조하기 위한 내부 링크다.

### 6. 작동 위임

# Part2. 비동기와 성능
### 1. 비동기성: 지금과 나중
59. 다시 말해, 자바스크립트 엔진은 애당초 시간이란 관념 따윈 없었고 임의의 자바스크립트 코드 조각을 시시각각 주는 대로 받아 처리하는 실행기일 뿐, '이벤트'(자바스크립트 코드 실행)를 스케줄링하는 일은 언제나 엔진을 감싸고 있던 주위 환경의 몫이었다.

60. setTimeout()은 콜백을 이벤트 루프 큐에 넣지 않는다. 헷갈리지 말자. setTimeout()은 타이머를 설정하는 함수다. 타이머가 끝나면 환경이 콜백을 이벤트 루프에 삽입한 뒤 틱에서 콜백을 꺼내어 실행한다.

61. 이벤트 루프가 20개의 원소로 가득 차 있을 땐? 일단 콜백은 기다린다. 먼저 앞으로 가려고 새치기하지 않고 얌전히 줄 맨 끝에서 대기한다. setTimeout() 타이머가 항상 완벽하게 정확한 타이밍으로 작동하지 않는 게 바로 이 때문이다. (대략 말하면) 적어도 지정한 시간Interval 이전에 콜백이 실행되지 않을 거란 사실은 보장할 수 있지만 정확히 언제, 혹은 좀 더 시간이 경과한 이후에 실행될지는 이벤트 루프 큐의 상황에 따라 달라진다.

62. 자바스크립트 프로그램은 수많은 덩이로 잘게 나누어지고 이벤트 루프 큐에서 한 번에 하나씩 차례대로 실행된다. 엄밀히 말해 이 큐엔 개발자가 작성한 프로그램과 직접 상관없는 여타 이벤트들도 중간에 끼어들 가능성도 있다.

63. 정리하기  
자바스크립트 프로그램은 (사실상) 언제나 2개 이상의 덩이로 쪼개지며 이벤트 응답으로 첫 번째 덩이는 '지금', 다음 덩이는 '나중'에 실행된다. 한 덩이씩 실행되어도 모든 덩이가 프로그램의 스코프/상태에 똑같이 접근할 수 있으므로 상태 변화는 차례대로 반영된다.

실행할 이벤트가 있으면 이벤트 루프는 큐를 다 비울 때까지 실행한다. 이벤트 루프를 한 차례 순회하는 것을 틱이라 한다. UI, IO, 타이머는 이벤트 큐에 이벤트를 넣는다.

언제나 한 번에 정확히 한 개의 이벤트만 큐에서 꺼내 처리한다. 이벤트 실행 도중, 하나 또는 그 이상의 후속 이벤트를 직/간접적으로 일으킬 수 있다.

동시성은 복수의 이벤트들이 연쇄적으로 시간에 따라 인터리빙 되면서 고수준의 관점에서 볼 때 (실제로는 특정 시점에 1개 이벤트만 처리되고 있지만) 꼭 동시에 실행되는 것처럼 보인다.

(OS의 시스템 프로세스와는 달리) 동시 "프로세스"들은 어떤 형태로든 서로 영향을 미치는 작업을 조정하여 실행 순서를 보장하거나 경합 조건을 예방하는 등의 조치를 해야 한다. 이 "프로세스" 자체를 더 작은 덩이로 잘게 나누어 다른 "프로세스"에 인터리빙 되는 형태의 협동 또한 가능하다.

64. 스레드가 1개 -> 이벤트 루프에서 '하나씩' 순차 실행 -> 비동기 처리는? -> 동시성을 야기함

### 2. 콜백
65. 의심할 바 없이 아직 콜백은 자바스크립트에서 비동기성을 표현하고 관리하는 가장 일반적인 기법이자, 사실상 자바스크립트 언어에서 가장 기본적인 비동기 패턴이다. 무수히 많은 정교하고 복잡한 자바스크립트 프로그램이 콜백으로 개발됐다. 자바스크립트의 충실한 비동기 일개미인 콜백 함수는 소임을 잘해왔다.

66. 그러나 만사가 그렇듯 콜백에도 단점이 있어 많은 개발자는 더 나은 비동기 패턴이 나오리란 기대(프라미스)로 들떠 있다. 그런데 무엇을, 왜 추상화하는지 모르고선 그 결과물을 효과적으로 활용할 수 없을 것이다.

67. 눈여겨볼 부분이 있다. 2, 3, 4단계를 죽 연결하여 연속 실행하고 싶을 때 콜백만으로 할 수 있는 일은 1단계 코드에 2단계 코드를, 3단계 코드에 2단계 코드를, 4단계 코드에 3단계 코드를 하드 코딩하여 넣는 정도다. 반드시 2단계가 3단계를 선행한다는 고정 조건이 있을 때 하드 코딩이 나쁜 선택이라고 탓할 수만은 없다.

68. 그러나 하드 코딩은 기본적으로 부실한 코드를 양산하기에 단계가 나아가는 도중 엉뚱한 일들이 발생하여 오류가 나는 것까지 대비할 수는 없다. 가령, 2단계에서 실패하면 2단계 재시도는 물론이고 3단계는 아예 시작도 못 하거나 별도의 에러 처리 루틴으로 빠져버린다.

69. 정리하기  
콜백은 자바스크립트에서 비동기성을 표현하는 기본 단위다. 그러나 자바스크립트와 더불어 점점 진화하는 비동기 프로그래밍 환경에서 콜백만으로는 충분치 않다

첫째, 사람의 두뇌는 순차적, 중단적, 단일-스레드 방식으로 계획하는 데 익숙하지만 콜백은 비동기 흐름을 비선형적, 비순차적인 방향으로 나타내므로 구현된 코드를 제대로 이해하기가 매우 어렵다. 추론하기 곤란한 코드는 곧 악성 버그를 품은 나쁜 코드로 이어진다.

그래서 비동기성을 좀 더 동기적, 순차적, 중단적인 모습으로, 우리 두뇌가 사고하는 방식과 유사하게 표현할 방법이 필요하다.

둘째, 이 부분이 더 중요한데, 콜백은 프로그램을 진행하기 위해 제어를 역전, 즉 제어권을 다른 파트(종종 여러분 손을 떠나 어찌할 수 없는 서드 파티 유틸리티)에 암시적으로 넘겨줘야 하므로 골치가 아프다. 이렇게 제어권이 넘어가면서 예상보다 더 자주 콜백을 호출하는 등 여러 가지 믿음성 문제에 봉착하게 된다.

믿음성 문제를 해결하고자 임시 로직을 짜 넣으면 당장은 난관을 모면할 순 있지만 생각만큼 구현하기가 쉽지 않은 데다 계속 그렇게 하다 보면 거칠고 유지 보수가 어려운 코드로 변질된다. 또 나중에 버그가 발견되어 된통 당해보기 전까진 막대한 피해로부터 보호받을 마땅한 방법 또한 없다.

관용 코드를 여기저기 흩뿌리지 않고도 생성한 콜백들을 재사용할 수 있는, 그런 일반적인 해결 방안이 강구되어야 믿음성 문제를 해결할 수 있다.

아무래도 콜백을 능가하는 뭔가가 필요하다. 지금까지 콜백은 임무를 훌륭히 수행해왔지만 미래의 자바스크립트 환경에서는 더욱 정교하고 역량 있는 비동기 패턴이 절실하다.

### 3. 프라미스
70. 그런데 만일 제어의 역전을 되역전시킬 수 있다면? 그러니까... 프로그램의 진행을 다른 파트에 넘겨주지 않고도 개발자가 언제 작업이 끝날지 알 수 있고 그다음에 무슨 일을 해야 할지 스스로 결정할 수 있다면...?  
이러한 체계가 바로 프라미스(Promise)다.

71. 프라미스는 개발자와 명세 작성자가 함께 코딩/설계 단계에서 콜백 지옥의 실타래를 풀기 위해 지푸라기 잡는 심정으로 매달리면서 자바스크립트 세상에 혜성처럼 등장했다. 실상 자바스크립트/DOM 플랫폼에 추가된 최신 비동기 API 대부분이 모두 프라미스에 기반을 두고 개발됐다. 

### 4. 제너레이터
### 5. 프로그램 성능
### 6. 벤치마킹과 튜닝
### Appendix A. ES6 class
### Appendix B. asynquence 라이브러리
### Appendix C. 고급 비동기 패턴